<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://leecss.com</id>
    <title>当下</title>
    <updated>2021-06-20T02:53:42.615Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://leecss.com"/>
    <link rel="self" href="https://leecss.com/atom.xml"/>
    <logo>https://leecss.com/images/avatar.png</logo>
    <icon>https://leecss.com/favicon.ico</icon>
    <rights>All rights reserved 2021, 当下</rights>
    <entry>
        <title type="html"><![CDATA[git-相对引用]]></title>
        <id>https://leecss.com/post/git-xiang-dui-yin-yong/</id>
        <link href="https://leecss.com/post/git-xiang-dui-yin-yong/">
        </link>
        <updated>2021-06-20T02:53:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>通过哈希值指定提交记录很不方便，所以 Git 引入了相对引用。</p>
<p>使用相对引用的话，你就可以从一个易于记忆的地方（比如bugFix 分支或 HEAD）开始计算。</p>
<h2 id="分类">分类</h2>
<h3 id="操作符~">操作符~</h3>
<p>HEAD 表示当前分支的最新提交</p>
<p>HEAD~ 表示当前分支的最新提交的前一个提交（即最新的第二个提交，也就是最新提交的父提交）</p>
<p>HEAD~~ 表示当前分支的最新提交的前前提交（即最新的第三个提交，也就是最新提交的祖父提交）</p>
<p>HEAD~~~ 表示当前分支的最新提交的前前前提交（即最新的第四个提交，也就是最新提交的曾祖父提交）</p>
<blockquote>
<p>HEAD~~~等效于HEAD~3</p>
<p>HEAD~~等效于HEAD~2</p>
<p>HEAD<sub>等效于HEAD</sub>1</p>
<p>HEAD等效于HEAD~0</p>
</blockquote>
<h3 id="操作符">操作符^</h3>
<h4 id="单个直系父提交">单个直系父提交</h4>
<p>把这个符号加在引用名称的后面，表示让 Git 寻找指定提交记录的父提交。</p>
<p>方式一</p>
<p><code>main^</code> 相当于“<code>main</code> 的父节点”。</p>
<p><code>main^^</code> 是 <code>main</code> 的第二个父节点</p>
<p>方式二</p>
<p>我们也可以多次使用 <code>HEAD^</code> 向上移动。</p>
<pre><code class="language-sh">git checkout HEAD^
git checkout HEAD^
</code></pre>
<h4 id="多个直系父提交">多个直系父提交</h4>
<p>假如当前提交不只一个父节点，有多个直系父提交呢？</p>
<p>如果一个提交有多个父提交，那么 <code>~</code> 只会找第一个父提交。</p>
<p>使用<code>HEAD^2</code>来找到第二个父提交</p>
<pre><code class="language-sh">
G   H   I   J
 \ /     \ /
  D   E   F
   \  |  / \
    \ | /   |
     \|/    |
      B     C
       \   /
        \ /
         A
 
A =      = A^0
B = A^   = A^1     = A~1
C = A^2
D = A^^  = A^1^1   = A~2
E = B^2  = A^^2
F = B^3  = A^^3
G = A^^^ = A^1^1^1 = A~3
H = D^2  = B^^2    = A^^^2  = A~2^2
I = F^   = B^3^    = A^^3^
J = F^2  = B^3^2   = A^^3^2
</code></pre>
<h2 id="应用">应用</h2>
<h3 id="强制修改分支位置">强制修改分支位置</h3>
<p>使用相对引用最多的就是移动分支。可以直接使用 <code>-f</code> 选项让分支指向另一个提交。例如:</p>
<pre><code class="language-shell">git branch -f main HEAD~3
</code></pre>
<p>相对引用为我们提供了一种简洁的引用提交记录 的方式， 而 <code>-f</code> 则容许我们将分支强制移动到那个位置。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git-reference(指针)]]></title>
        <id>https://leecss.com/post/git-referencezhi-zhen/</id>
        <link href="https://leecss.com/post/git-referencezhi-zhen/">
        </link>
        <updated>2021-06-19T15:28:49.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>所谓指针（reference），只是一个链接，用来指向其他物体，方便引用。Git有三种指针，但是所有指针归根结底都是指向某个commit。</p>
<h2 id="分类">分类</h2>
<h3 id="head指针">HEAD指针</h3>
<p>头指针：指向目前所在的Branch，用来区分目前在哪个分支。</p>
<p>查看HEAD 指向</p>
<pre><code class="language-sh">cat .git/HEAD
</code></pre>
<p>结果：ref: refs/heads/master</p>
<p>可以看出HEAD指针指向的是refs/heads/master文件，即master分支</p>
<hr>
<p>如果 HEAD 指向的是一个引用,可以通过以下命令查看它的指向</p>
<pre><code class="language-sh">git symbolic-ref HEAD
</code></pre>
<h3 id="branch指针">Branch指针</h3>
<p>分支指针：指向某个commit。每次该分支有新的commit，指针就会变动，指向当前分支的最新提交。</p>
<p>当我们从master新建一个test分支时，git只会创建一个test分支指针，并且让test分支指针指向master分支对应的最新的提交。</p>
<p>查看master分支文件的内容</p>
<pre><code class="language-sh">cat .git/refs/heads/master
</code></pre>
<p>可以看到，这个文件的内容是一串哈希码，而这个哈希码正是master分支上最新的提交所对应的哈希码。</p>
<h2 id="分离头">分离头</h2>
<p>通常情况下，HEAD指针总是通过分支指针，间接的指向了当前分支的最新提交。</p>
<p>不通常的情况便是分离头（detached HEAD）：就是头指针和分支指针分开了，HEAD指针没有指向分支指针，而是直接指向了某个提交。</p>
<p>我们随便检出到某个提交，都可以进入分离头状态</p>
<pre><code>git checkout cbd3348
</code></pre>
<p><strong>分离头的应用</strong></p>
<p>由于刚才我们直接检出了’cbd3348’这个提交，所以，我们处于分离头状态，而且当前仓库中各个文件的内容也回到了’cbd3348’这个提交对应的状态。此时创建了两个新提交，这两个新提交与分叉点之前的提交组成了一条匿名分支，没有任何一个分支标签指向这个匿名分支。我们现在有两个选择，如下：</p>
<p>选择一：丢弃这个匿名分支</p>
<blockquote>
<p>直接检出到任何一个别的分支，就相当于放弃了这些提交</p>
</blockquote>
<p>选择二：保留这个匿名分支</p>
<blockquote>
<p>只需要将这些提交创建成一条新的分支就行了</p>
</blockquote>
<pre><code class="language-sh">git checkout -b newtest
</code></pre>
<pre><code class="language-sh">git branch newtest dca15df
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git-rebase]]></title>
        <id>https://leecss.com/post/git-rebase/</id>
        <link href="https://leecss.com/post/git-rebase/">
        </link>
        <updated>2021-06-17T03:43:53.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>将当前分支移植到指定分支或指定commit之上。</p>
<p>Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。</p>
<p>Rebase 的优势就是可以创造更线性的提交历史，这听上去有些难以理解。如果只允许使用 Rebase 的话，代码库的提交历史将会变得异常清晰。</p>
<pre><code class="language-sh">git rebase master
</code></pre>
<p>将当前分支移植到master分支之上。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git-merge]]></title>
        <id>https://leecss.com/post/git-merge/</id>
        <link href="https://leecss.com/post/git-merge/">
        </link>
        <updated>2021-06-17T03:36:56.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p><code>git merge</code>命令用于合并指定分支到当前分支</p>
<p>将develop分支合并到当前分支，当前分支会创建新的commit对象，它有两个父节点，分别指向当前分支和develop分支。</p>
<pre><code class="language-sh">git merge develop
</code></pre>
<h2 id="合并方式">合并方式</h2>
<h3 id="普通方式">普通方式</h3>
<p>假如此时在C1节点master分支上，创建了一个新的分支dev,然后在master分支创建新的提交C2,在dev分支上创建新的提交C3。</p>
<p><strong>如果合并分支之前，master分支和dev分支都有了属于自己分支的独有提交，此时只能使用普通方式进行合并。</strong></p>
<p>此时可以将master合并到dev,也可以将dev合并到master</p>
<p>以dev合并到master为例：</p>
<p>在maser分支执行<code>git merge dev</code>，会有新的变更进入到master，新变更进入后，base分支的内容会产生变化，因此master分支需要一个新的提交来对应变化后的状态，于是，master分支的指针会指向最新产生的合并提交。</p>
<p>而对于dev分支来说，并没有任何内容发生变动，所以dev分支的指针仍然保持原位。</p>
<h3 id="fast-forward快进">fast-forward（快进）</h3>
<p>假如此时在C1节点master分支上，创建了一个新的分支dev,然后在dev分支上创建新的提交C2。</p>
<p><strong>如果合并分支之前，master分支和dev分支中只有一个分支创建了属于自己分支的独有提交，此时可以使用fast-forward进行合并。</strong></p>
<p>由于基于maste分支创建dev分支以后，master分支中并没有产生任何新的提交，如果此时想要将dev分支合并到master分支，只需要将master分支的指针指向到dev分支的最新提交，即可让master分支包含dev分支中的所有新变更。即：</p>
<p><u>如果“指定分支”本身是当前分支的一个直接子节点，则会产生fast-forward合并，即合并不会产生新的节点，只是让当前分支指向“指定分支”的最新commit。</u></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git-commit]]></title>
        <id>https://leecss.com/post/git-commit/</id>
        <link href="https://leecss.com/post/git-commit/">
        </link>
        <updated>2021-06-17T03:29:39.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p><code>git commit</code>命令用于将暂存区中的变化提交到仓库区。</p>
<p><code>-m</code>参数用于指定 commit 信息，是必需的。如果省略<code>-m</code>参数，<code>git commit</code>会自动打开文本编辑器，要求输入。</p>
<pre><code class="language-sh">git commit -m &quot;message&quot;
</code></pre>
<h2 id="命令行参数">命令行参数</h2>
<h3 id="-a">-a</h3>
<p><code>-a</code>参数用于先将所有工作区的变动文件，提交到暂存区，再运行<code>git commit</code>。</p>
<pre><code class="language-sh">git commit -am &quot;message&quot;
</code></pre>
<blockquote>
<p>用了<code>-a</code>参数，是不是就不用执行<code>git add .</code>命令了？不是。</p>
<p><code>-m</code>参数用于提交暂存区的文件</p>
<p><code>-a</code>参数用于提交追踪过的文件</p>
<p>文件状态按已追踪和未追踪区分，新增的文件为未追踪，<code>git add</code>后的文件为已追踪</p>
<p>所以新增的文件还是要执行<code>git add .</code>命令</p>
</blockquote>
<h3 id="amend">—amend</h3>
<p><code>--amend</code>参数用于撤销上一次 commit，然后生成一个新的 commit。</p>
<pre><code class="language-sh">git commit --amend -m &quot;new commit message&quot;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git-add]]></title>
        <id>https://leecss.com/post/git-add/</id>
        <link href="https://leecss.com/post/git-add/">
        </link>
        <updated>2021-06-17T02:46:24.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p><code>git add</code>命令用于将变化的文件，从工作区提交到暂存区。</p>
<p>将指定文件放入暂存区</p>
<pre><code class="language-sh">git add &lt;file&gt;
</code></pre>
<p>将指定目录下所有变化的文件，放入暂存区</p>
<pre><code class="language-sh">git add &lt;directory&gt;
</code></pre>
<p>将当前目录下所有变化的文件，放入暂存区</p>
<pre><code class="language-sh">git add .
</code></pre>
<h2 id="参数">参数</h2>
<p><code>-u</code>参数表示只添加暂存区已有的文件（包括删除操作），但不添加新增的文件。</p>
<pre><code class="language-sh">git add -u
</code></pre>
<p><code>-A</code>或者<code>--all</code>参数表示追踪所有操作，包括新增、修改和删除。</p>
<p>Git 2.0 版开始，<code>-A</code>参数成为默认，即<code>git add .</code>等同于<code>git add -A</code>。</p>
<pre><code class="language-sh">git add -A
</code></pre>
<p><code>-f</code>参数表示强制添加某个文件，不管<code>.gitignore</code>是否包含了这个文件。</p>
<pre><code class="language-sh">git add -f &lt;fileName&gt;
</code></pre>
<p><code>-p</code>参数表示进入交互模式，指定哪些修改需要添加到暂存区。即使是同一个文件，也可以只提交部分变动。</p>
<p>未跟踪(即新增的)文件不在此参数范围内</p>
<pre><code class="language-sh">git add -p
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git-branch]]></title>
        <id>https://leecss.com/post/git-branch/</id>
        <link href="https://leecss.com/post/git-branch/">
        </link>
        <updated>2021-06-16T14:59:51.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-查看分支">1、查看分支</h2>
<p>*表示当前分支</p>
<p>查看所有本地分支</p>
<pre><code class="language-sh">git branch
</code></pre>
<p>查看分支的详细信息（commitID及message）</p>
<pre><code class="language-sh">git branch -v
</code></pre>
<p>查看本地分支与远程分支的关联</p>
<pre><code class="language-sh">git branch -vv
</code></pre>
<p>查看所有远程分支</p>
<pre><code class="language-shell">git branch -r
</code></pre>
<p>查看所有本地分支和远程分支</p>
<pre><code class="language-sh">git branch -a
</code></pre>
<h2 id="2-新建分支">2、新建分支</h2>
<h3 id="新建本地分支">新建本地分支</h3>
<p>直接在<code>git branch</code>后面跟上分支名，就表示新建该分支。</p>
<pre><code class="language-sh">git branch [branch-name]
</code></pre>
<p>创建后，还是停留在原来分支，需要用<code>git checkout</code>切换到新建分支</p>
<pre><code class="language-sh">git checkout [branch-name]
</code></pre>
<p>使用<code>-b</code>参数，可以新建的同时，切换到新分支。</p>
<pre><code class="language-sh">git checkout -b [branch-name]
</code></pre>
<p>新建一个分支，与指定的远程分支建立追踪关系</p>
<pre><code class="language-sh">git branch --track [branch] origin/[remote-branch]
</code></pre>
<h3 id="新建远程分支">新建远程分支</h3>
<p>创建远程分支</p>
<p>创建远程分支的前提是本地有这个分支，推送到远程后，因为远程没有此分支，所以会新建</p>
<p>在远程主机<code>origin</code>上创建一个分支</p>
<pre><code class="language-sh">git push origin &lt;本地分支名&gt;
</code></pre>
<p>在远程主机<code>origin</code>上创建一个<code>MyBranch</code>的分支，并与本地的同名分支建立追踪关系。</p>
<pre><code class="language-sh">git push -u origin MyBranch
</code></pre>
<h2 id="3-删除分支">3、删除分支</h2>
<h3 id="删除本地分支">删除本地分支</h3>
<p>需要当前不在被删除的分支上</p>
<p><code>-d</code>参数用来删除一个分支，前提是该分支没有未合并的变动。</p>
<pre><code class="language-sh">git branch -d [branch-name]
</code></pre>
<p>强制删除一个分支，不管有没有未合并变化。</p>
<pre><code class="language-sh">git branch -D [branch-name]
</code></pre>
<h3 id="删除远程分支">删除远程分支</h3>
<pre><code class="language-sh">git push origin --delete [branch-name]
</code></pre>
<pre><code class="language-sh">git branch -dr origin/[remote-branch]
</code></pre>
<h2 id="4-分支改名">4、分支改名</h2>
<p>为当前分支改名</p>
<pre><code class="language-sh">git branch -m [branch-name]
</code></pre>
<p>为指定分支改名</p>
<pre><code class="language-sh">git branch -m dev develop
</code></pre>
<h2 id="5-关联远程分支">5、关联远程分支</h2>
<p>建立追踪关系，在现有分支与指定的远程分支之间</p>
<pre><code class="language-sh">git branch --set-upstream-to=origin/[remote-branch] [branch]
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[生活网站导航]]></title>
        <id>https://leecss.com/post/sheng-huo-wang-zhan-dao-hang/</id>
        <link href="https://leecss.com/post/sheng-huo-wang-zhan-dao-hang/">
        </link>
        <updated>2021-06-16T13:56:31.000Z</updated>
        <content type="html"><![CDATA[<h2 id="其他">其他</h2>
<p><a href="http://www.tiqianhuandai.cc/">房贷计算</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git-简介]]></title>
        <id>https://leecss.com/post/git-jian-jie/</id>
        <link href="https://leecss.com/post/git-jian-jie/">
        </link>
        <updated>2021-06-15T23:29:57.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>git是目前世界上最先进的 <strong>分布式</strong>  <strong>版本控制</strong>系统。</p>
<h3 id="分布式">分布式</h3>
<blockquote>
<p>集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。</p>
</blockquote>
<blockquote>
<p>分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库,安全性要更高。</p>
</blockquote>
<h3 id="版本控制">版本控制</h3>
<p>通常我们保存多版本的方式，是通过拷贝一份副本，然后在副本上操作，假如我们在副本上的修改不满意，就可以从原版再拷贝一份，重新进行编辑。</p>
<p>git就是帮我们做版本控制的一个系统。</p>
<h2 id="特点">特点</h2>
<h3 id="直接记录快照而非差异比较">直接记录快照，而非差异比较</h3>
<p>Git 仓库中的提交记录保存的是你的目录下所有文件的快照，就像是把整个目录复制，然后再粘贴一样，但比复制粘贴优雅许多！</p>
<p>Git 希望提交记录尽可能地轻量，因此在你每次进行提交时，它并不会盲目地复制整个目录。条件允许的情况下，它会将当前版本与仓库中的上一个版本进行对比，并把所有的差异打包到一起作为一个提交记录。</p>
<p>Git 还保存了提交的历史记录。这也是为什么大多数提交记录的上面都有父节点的原因 —— 我们会在图示中用箭头来表示这种关系。对于项目组的成员来说，维护提交历史对大家都有好处。</p>
<figure data-type="image" tabindex="1"><img src="https://leecss.com/post-images/1623799889637.png" alt="" loading="lazy"></figure>
<h3 id="以我们拷贝副本的思路来认识一下git">以我们拷贝副本的思路来认识一下git</h3>
<h4 id="目录仓库">目录==仓库</h4>
<p>为了方便管理，我们通常会把拷贝的副本放在一个目录(文件夹)中，git仓库也是如此，只有git仓库里面保存记录了你的各个版本的文件</p>
<h4 id="各版本副本每次commit">各版本副本==每次commit</h4>
<p>我们拷贝的过程，在git中是通过以下方式来实现的</p>
<pre><code class="language-sh">// 选择要拷贝的文件
git add &lt;file&gt;
// 拷贝操作
git commit -m '拷贝一次副本'
</code></pre>
<h4 id="版本标记哈希码">版本标记==哈希码</h4>
<p>当我们使用git进行版本管理时，git会将我们的文件和目录结构转化成git方便操作的数据，也就是说，git会将我们的文件和目录转化成一种叫做”git对象”的东西，然后再对这些”git对象”进行管理，从而实现版本管理的目的，这些git对象存放在git的对象库中。</p>
<p>我们眼中的文件会被git转化成”块”(blob)</p>
<p>我们眼中的目录会被git转化成”树”(tree)</p>
<p>我们眼中的版本会被git转化成”提交”(commit)</p>
<p>blob、tree、commit都是git对象，是三种不同类型的git对象</p>
<p>一个blob就是由一个文件转换而来，blob对象中只会存储文件的数据，而不会存储文件的元数据。</p>
<p>一个tree就是由一个目录转化而来，tree对象中只会存储一层目录的信息，它只存储它的直接文件和直接子目录的信息，但是子目录中的内容它并不会保存。</p>
<p>一个commit就是一个我们所创建的提交，它指向了一个tree，这个tree保存了某一时刻项目根目录中的直接文件信息和直接目录信息，也就是说，这个tree会指向直接文件的blob对象，并且指向直接子目录的tree对象，子目录的tree对象又指向了子目录中直接文件的blob，以及子目录的直接子目录的tree，依此类推。</p>
<p>每个git对象都有一个”身份证号”，这个身份证号是一个哈希码，这个哈希码通过SHA1算法得出，如果git对象的内容相同，那么他们的哈希码就是相同的，如果git对象的内容不同，那么他们的哈希码必定不同（通常来说，SHA1算法能够保证内容不同时，得到的哈希码必定不同，不过，理论上来说，即使内容不同，也有可能产生相同的哈希码，不过几率非常之小，我们可以忽略这种可能性），一个git对象的哈希码通常长成如下模样：</p>
<p>875925683e755d94e26a2dc1a1bc4c645a91acbe</p>
<p>它是一个40位的十六进制数。</p>
<p>刚才提到，每个git对象都有一个这样的哈希码，所以，每个”提交”（commit）也有一个这样的哈希码，在后文中，我们会使用提交的哈希码来表示某个提交，不过由于这个哈希码比较长，所以通常情况下，我们只会使用哈希码的前几位来表示一个提交，只要这个哈希码的前几位与别的哈希码的前几位不同，能体现出唯一性，我们就能用这个哈希码的前几位来表示这个提交，比如，刚才示例的哈希码如下</p>
<p>875925683e755d94e26a2dc1a1bc4c645a91acbe</p>
<p>我们可以使用8759256来表示这个哈希码。</p>
<p><strong>图例说明</strong></p>
<p>下图中的圆形代表commit（即前文中的”小圆球”），三角形代表tree(由目录转化成的git对象)，长方形代表blob(由文件转化成的git对象)。假设，第一次提交之前，目录中只有两个文件，file1和file2，file1的内容为f1，file2的内容为f2，那么当第一个提交创建以后，git的对象库中会存在如下图的git对象</p>
<figure data-type="image" tabindex="2"><img src="https://leecss.com/post-images/1624084982475.png" alt="" loading="lazy"></figure>
<p>也就是说 ，当我们创建第一个提交以后，项目当时的状态已经被转化成了上图中的git对象，我们创建的第一个提交的哈希为8759256，它指向一个tree，这个tree就是当时根目录的状态，这个tree的哈希为e890df4，从上图可以看出，当时的根目录中只有两个文件，也就是两个blob，这个tree指向了这两个blob，这两个blob就是由file1和file2转化而来的。</p>
<p>如果此时，我们修改了file2，我们将file2的内容从f2修改成f22，并且在根目录中创建一个新的子目录dir1，在dir1中又添加了一个文件d1file1，d1file1的内容是df1，但是我们并没有对file1进行任何修改，那么，当我们再次提交以后，git对象库中会存在如下对象。</p>
<figure data-type="image" tabindex="3"><img src="https://leecss.com/post-images/1624085012006.png" alt="" loading="lazy"></figure>
<p>如上图所示，我们修改了file2，将其内容从f2修改成了f22，当第二个提交创建以后，git会将file2的新状态转化成一个新的blob对象，file2之前的状态对应的blob对象仍然保存在git对象库中，并且被初始提交引用，以便我们随时能够通过初始提交找到file2当时的状态，file2新的状态被新的提交引用，我们并没有修改file1，也就是说，file1的状态一直没有发生改变，所以，新的提交只是通过tree对象指向了之前file1对应的blob，由于我们在根目录中创建了一个子目录dir1，所以，在新的根目录的tree对象中，也包含了它的直接子目录信息，并且指向了新子目录对应的tree对象，子目录tree对象中又保存了自己目录中的信息，也就是d1file1文件对应的blob对象。</p>
<p><strong>因此，一个commit就代表项目的一个版本（手动创建的副本），一个commit背后是一堆git对象，git将这些git对象巧妙的组织在了一起，从而实现了版本管理的目的。</strong></p>
<h2 id="状态">状态</h2>
<ul>
<li>Workspace：工作区</li>
<li>Index / Stage：暂存区</li>
<li>Repository：仓库区（或本地仓库）</li>
<li>Remote：远程仓库</li>
</ul>
<p>git项目中.git目录为仓库区，除了.git目录以外的其他所有文件目录为工作区</p>
<figure data-type="image" tabindex="4"><img src="https://leecss.com/post-images/1623800678351.png" alt="" loading="lazy"></figure>
<p>查看文件的变更状态</p>
<pre><code class="language-shell">git status
</code></pre>
<h2 id="推荐阅读">推荐阅读</h2>
<p><a href="https://www.zsythink.net/archives/3329">https://www.zsythink.net/archives/3329</a><br>
<a href="https://www.zsythink.net/archives/3354">https://www.zsythink.net/archives/3354</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[前端教程导航]]></title>
        <id>https://leecss.com/post/qian-duan-jiao-cheng-dao-hang/</id>
        <link href="https://leecss.com/post/qian-duan-jiao-cheng-dao-hang/">
        </link>
        <updated>2021-06-15T23:08:43.000Z</updated>
        <content type="html"><![CDATA[<h2 id="git">git</h2>
<p>1、<a href="https://learngitbranching.js.org/?locale=zh_CN">游戏化教程</a></p>
<p>2、<a href="https://www.bookstack.cn/read/git-tutorial/README.md">阮一峰</a></p>
<p>​      <a href="http://www.ruanyifeng.com/blog/2014/06/git_remote.html">阮一峰blog1</a></p>
<p>​      <a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">阮一峰blog2</a></p>
<p>3、<a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰</a></p>
<p>4、<a href="https://www.zsythink.net/">朱双印</a></p>
<p>5、<a href="https://marklodato.github.io/visual-git-guide/index-zh-cn.html">图解git</a></p>
<p>6、<a href="https://git-scm.com/book/zh/v2">官网</a></p>
]]></content>
    </entry>
</feed>