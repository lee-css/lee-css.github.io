<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://leecss.com/</id>
    <title>当下</title>
    <updated>2021-09-14T00:58:23.739Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://leecss.com/"/>
    <link rel="self" href="https://leecss.com//atom.xml"/>
    <logo>https://leecss.com//images/avatar.png</logo>
    <icon>https://leecss.com//favicon.ico</icon>
    <rights>All rights reserved 2021, 当下</rights>
    <entry>
        <title type="html"><![CDATA[JavaScript-webApi-window方法requestAnimationFrame]]></title>
        <id>https://leecss.com//post/javascript-webapi-window-fang-fa-requestanimationframe/</id>
        <link href="https://leecss.com//post/javascript-webapi-window-fang-fa-requestanimationframe/">
        </link>
        <updated>2021-09-14T00:16:01.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p><code>window.requestAnimationFrame()</code>告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行</p>
<h2 id="示例">示例</h2>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
        &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
        &lt;title&gt;JS 真题演示&lt;/title&gt;

        &lt;style&gt;
            #div1 {
                width: 100px;
                height: 50px;
                background-color: red;
            }
        &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;p&gt;JS 真题演示&lt;/p&gt;

        &lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;

        &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.4.0/jquery.js&quot;&gt;&lt;/script&gt;
        &lt;script src=&quot;./RAF.js&quot;&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="language-js">// 3s 把宽度从 100px 变为 640px ，即增加 540px
// 60帧/s ，3s 180 帧 ，每次变化 3px

const $div1 = $('#div1')
let curWidth = 100
const maxWidth = 640

// // setTimeout
// function animate() {
//     curWidth = curWidth + 3
//     $div1.css('width', curWidth)
//     if (curWidth &lt; maxWidth) {
//         setTimeout(animate, 16.7) // 自己控制时间
//     }
// }
// animate()

// RAF
function animate() {
    curWidth = curWidth + 3
    $div1.css('width', curWidth)
    if (curWidth &lt; maxWidth) {
        window.requestAnimationFrame(animate) // 时间不用自己控制
    }
}
animate()
</code></pre>
<h2 id="推荐阅读">推荐阅读</h2>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame">https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript-数组去重]]></title>
        <id>https://leecss.com//post/javascript-shu-zu-qu-chong/</id>
        <link href="https://leecss.com//post/javascript-shu-zu-qu-chong/">
        </link>
        <updated>2021-09-13T23:59:07.000Z</updated>
        <content type="html"><![CDATA[<h2 id="示例">示例</h2>
<pre><code class="language-js">// 传统方式
function unique(arr) {
    const res = []
    arr.forEach(item =&gt; {
        if (res.indexOf(item) &lt; 0) {
            res.push(item)
        }
    })
    return res
}

// 使用 Set （无序，不能重复）
function unique(arr) {
    const set = new Set(arr)
    return [...set]
}

const res = unique([30, 10, 20, 30, 40, 10])
console.log(res)

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript-实例-解析url参数]]></title>
        <id>https://leecss.com//post/javascript-shi-li-jie-xi-url-can-shu/</id>
        <link href="https://leecss.com//post/javascript-shi-li-jie-xi-url-can-shu/">
        </link>
        <updated>2021-09-13T14:15:47.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>不想看正则，以后复习再看</p>
<h2 id="获取参数值">获取参数值</h2>
<pre><code class="language-js">// 传统方式
function query(name) {
    const search = location.search.substr(1) // 类似 array.slice(1)
    // search: 'a=10&amp;b=20&amp;c=30'
    const reg = new RegExp(`(^|&amp;)${name}=([^&amp;]*)(&amp;|$)`, 'i')
    const res = search.match(reg)
    if (res === null) {
        return null
    }
    return res[2]
}
query('d')

// URLSearchParams
function query(name) {
    const search = location.search
    const p = new URLSearchParams(search)
    return p.get(name)
}
console.log( query('b') )

</code></pre>
<h2 id="url参数解析为js对象">url参数解析为js对象</h2>
<pre><code class="language-js">// url参数解析为js对象

// 传统方式，分析search
function queryToObj() {
  const res = {}
  const search = location.search.substr(1) // 去掉前面的`?`
  search.split('&amp;').forEach(paramStr =&gt; {
    const arr = paramStr.split('=')
    const key = arr[0]
    const val = arr[1]
    res[key] = val
  })
  return res
}

// 使用URLSearchParams
function queryToObj() {
  const res = {}
  const pList = new URLSearchParams(location.search)
  pList.forEach((val, key) =&gt; {
    res[key] = val
  })
  return res
}

</code></pre>
<h2 id="mdn">MDN</h2>
<p><code>URLSearchParams</code> 接口定义了一些实用的方法来处理 URL 的查询字符串。</p>
<pre><code class="language-js">var paramsString = &quot;q=URLUtils.searchParams&amp;topic=api&quot;
var searchParams = new URLSearchParams(paramsString);

for (let p of searchParams) {
  console.log(p);
}

// ['q', 'URLUtils.searchParams']
// ['topic', 'api']

</code></pre>
<h2 id="推荐阅读">推荐阅读</h2>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams">https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ js手写-max]]></title>
        <id>https://leecss.com//post/js-shou-xie-max/</id>
        <link href="https://leecss.com//post/js-shou-xie-max/">
        </link>
        <updated>2021-09-13T13:53:43.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>获取多个数字中的最大值</p>
<h2 id="示例">示例</h2>
<pre><code class="language-js">function max() {
  const nums = Array.prototype.slice.call(arguments) // 变为数组
  let max = 0
  nums.forEach(n =&gt; {
    if (n &gt; max) {
      max = n
    }
  })
  return max
}
</code></pre>
<h2 id="感受">感受</h2>
<p>换一种写法</p>
<pre><code class="language-js">function max(...array) {
  const length = array == null ? 0 : array.length
  return length
    ? array.reduce((acc,cur) =&gt; {
      return acc &gt; cur ? acc : cur
    })
    : void 0
}
max(1,2,3)
</code></pre>
<h2 id="当然没必要">当然没必要</h2>
<p>直接用Math.max()就好</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ js手写-trim]]></title>
        <id>https://leecss.com//post/js-shou-xie-trim/</id>
        <link href="https://leecss.com//post/js-shou-xie-trim/">
        </link>
        <updated>2021-09-13T13:37:04.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>原型，this,正则</p>
<h2 id="示例">示例</h2>
<pre><code class="language-js">String.prototype.trim = function() {
  return this.replace(/^\s+/,'').replace(/\s+$/,'')
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ js手写-isEqual]]></title>
        <id>https://leecss.com//post/js-shou-xie-isequal/</id>
        <link href="https://leecss.com//post/js-shou-xie-isequal/">
        </link>
        <updated>2021-09-12T23:50:58.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>比较两个对象或数组是否属性值全部一致</p>
<h2 id="示例">示例</h2>
<pre><code class="language-js">// 判断是否是对象或数组
function isObject(obj) {
    return typeof obj === 'object' &amp;&amp; obj !== null
}
// 全相等（深度）
function isEqual(obj1, obj2) {
    if (!isObject(obj1) || !isObject(obj2)) {
        // 值类型（注意，参与 equal 的一般不会是函数）
        return obj1 === obj2
    }
    if (obj1 === obj2) {
        return true
    }
    // 两个都是对象或数组，而且不相等
    // 1. 先取出 obj1 和 obj2 的 keys ，比较个数
    const obj1Keys = Object.keys(obj1)
    const obj2Keys = Object.keys(obj2)
    if (obj1Keys.length !== obj2Keys.length) {
        return false
    }
    // 2. 以 obj1 为基准，和 obj2 一次递归比较
    for (let key in obj1) {
        // 比较当前 key 的 val —— 递归！！！
        const res = isEqual(obj1[key], obj2[key])
        if (!res) {
            return false
        }
    }
    // 3. 全相等
    return true
}

// 测试
const obj1 = {
    a: 100,
    b: {
        x: 100,
        y: 200
    }
}
const obj2 = {
    a: 100,
    b: {
        x: 100,
        y: 200
    }
}
// console.log( obj1 === obj2 )
console.log( isEqual(obj1, obj2) )

const arr1 = [1, 2, 3]
const arr2 = [1, 2, 3, 4]

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[js手写-throttle]]></title>
        <id>https://leecss.com//post/js-shou-xie-throttle/</id>
        <link href="https://leecss.com//post/js-shou-xie-throttle/">
        </link>
        <updated>2021-09-12T23:07:29.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>当拖拽事件执行时，频率太快，减少事件的执行次数，以一个固定频率来执行。</p>
<h2 id="示例">示例</h2>
<pre><code class="language-js">const div1 = document.getElementById('div1')

let timer = null
div1.addEventListener('drag', function (e) {
    if (timer) {
        return
    }
    timer = setTimeout(() =&gt; {
        console.log(e.offsetX, e.offsetY)

        timer = null
    }, 100)
})
</code></pre>
<pre><code class="language-js">const div1 = document.getElementById('div1')

// 节流
function throttle(fn, delay = 100) {
    let timer = null

    return function () {
        if (timer) {
            return
        }
        timer = setTimeout(() =&gt; {
            fn.apply(this, arguments)
            timer = null
        }, delay)
    }
}

div1.addEventListener('drag', throttle(function (e) {
    console.log(e.offsetX, e.offsetY)
}))
</code></pre>
<h3 id="apply">apply</h3>
<pre><code class="language-js">div1.addEventListener('drag', function(event) {

})
</code></pre>
<p><code>fn.apply(this, arguments)</code>:由上述代码可知，arguments参数是传递到throttle返回的函数中的，所以需要将参数传递给fn</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ js手写-debounce]]></title>
        <id>https://leecss.com//post/js-shou-xie-debounce/</id>
        <link href="https://leecss.com//post/js-shou-xie-debounce/">
        </link>
        <updated>2021-09-12T22:53:49.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>输入框中防止连续触发事件，用户输入结束或暂停时再触发</p>
<h2 id="示例">示例</h2>
<pre><code class="language-js">const input1 = document.getElementById('input1')

let timer = null
input1.addEventListener('keyup', function () {
    if (timer) {
        clearTimeout(timer)
    }
    timer = setTimeout(() =&gt; {
        // 模拟触发 change 事件
        console.log(input1.value)

        // 清空定时器
        timer = null
    }, 500)
})
</code></pre>
<pre><code class="language-js">const input1 = document.getElementById('input1')

// 防抖
function debounce(fn, delay = 500) {
    // timer 是闭包中的
    let timer = null

    return function () {
        if (timer) {
            clearTimeout(timer)
        }
        timer = setTimeout(() =&gt; {
            fn.apply(this, arguments)
            timer = null
        }, delay)
    }
}

input1.addEventListener('keyup', debounce(function (e) {
    console.log(e.target)
    console.log(input1.value)
}, 600))
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript-webApi-Ajax]]></title>
        <id>https://leecss.com//post/javascript-webapi-ajax/</id>
        <link href="https://leecss.com//post/javascript-webapi-ajax/">
        </link>
        <updated>2021-09-12T08:52:56.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p><code>ajax</code>是一种技术方案，但并不是一种<strong>新技术</strong>。它依赖的是现有的<code>CSS</code>/<code>HTML</code>/<code>Javascript</code>，而其中最核心的依赖是浏览器提供的<code>XMLHttpRequest</code>对象，是这个对象使得浏览器可以发出<code>HTTP</code>请求与接收<code>HTTP</code>响应。</p>
<p>所以我用一句话来总结两者的关系：我们使用<code>XMLHttpRequest</code>对象来发送一个<code>Ajax</code>请求。</p>
<h2 id="xmlhttprequest">XMLHttpRequest</h2>
<pre><code class="language-js">const xhr = new XMLHttpRequest()
xhr.open('GET', '/data/test.json', true)
xhr.onreadystatechange = function () {
    if (xhr.readyState === 4) {
        if (xhr.status === 200) {
            // console.log(
            //     JSON.parse(xhr.responseText)
            // )
            alert(xhr.responseText)
        } else if (xhr.status === 404) {
            console.log('404 not found')
        }
    }
}
xhr.send(null)
</code></pre>
<h2 id="手写简易ajax">手写简易ajax</h2>
<pre><code class="language-js">function ajax(url) {
    const p = new Promise((resolve, reject) =&gt; {
        const xhr = new XMLHttpRequest()
        xhr.open('GET', url, true)
        xhr.onreadystatechange = function () {
            if (xhr.readyState === 4) {
                if (xhr.status === 200) {
                    resolve(
                        JSON.parse(xhr.responseText)
                    )
                } else if (xhr.status === 404 || xhr.status === 500) {
                    reject(new Error('404 not found'))
                }
            }
        }
        xhr.send(null)
    })
    return p
}

const url = '/data/test.json'
ajax(url)
.then(res =&gt; console.log(res))
.catch(err =&gt; console.error(err))
</code></pre>
<h2 id="推荐阅读">推荐阅读</h2>
<p><a href="https://juejin.cn/post/6844903469896171533">Ajax 知识体系大梳理</a></p>
<p><a href="https://segmentfault.com/a/1190000004322487">你真的会使用<code>XMLHttpRequest</code>吗</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript-webApi-事件]]></title>
        <id>https://leecss.com//post/javascript-webapi-shi-jian/</id>
        <link href="https://leecss.com//post/javascript-webapi-shi-jian/">
        </link>
        <updated>2021-09-12T02:50:14.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>事件绑定：普通绑定和代理绑定</p>
<p>事件冒泡</p>
<h2 id="事件绑定">事件绑定</h2>
<pre><code class="language-js">// 通用的事件绑定函数
function bindEvent(elem, type, fn) {
    elem.addEventListener(type, fn)
}

// 普通绑定
const btn1 = document.getElementById('btn1')
bindEvent(btn1, 'click', function (event) {
    // console.log(event.target) // 获取触发的元素
    event.preventDefault() // 阻止默认行为
    alert(this.innerHTML)
})
</code></pre>
<h2 id="事件冒泡">事件冒泡</h2>
<p>事件冒泡：由触发元素一层一层向上传递</p>
<p>阻止事件冒泡：<code>event.stopPropagation()</code></p>
<pre><code class="language-html">&lt;div id=&quot;div1&quot;&gt;
    &lt;p id=&quot;p1&quot;&gt;激活&lt;/p&gt;
    &lt;p id=&quot;p2&quot;&gt;取消&lt;/p&gt;
    &lt;p id=&quot;p3&quot;&gt;取消&lt;/p&gt;
    &lt;p id=&quot;p4&quot;&gt;取消&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;div2&quot;&gt;
    &lt;p id=&quot;p5&quot;&gt;取消&lt;/p&gt;
    &lt;p id=&quot;p6&quot;&gt;取消&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-js">const p1 = document.getElementById('p1')
bindEvent(p1, 'click', event =&gt; {
    // event.stopPropagation() // 阻止冒泡
    console.log('激活')
})
const body = document.body
bindEvent(body, 'click', event =&gt; {
    console.log('body clicked')
    console.log(event.target)
})
const div2 = document.getElementById('div2')
bindEvent(div2, 'click', event =&gt; {
    console.log('div2 clicked')
    console.log(event.target)
})
</code></pre>
<h2 id="事件代理">事件代理</h2>
<p>由于冒泡机制，所以事件会传递到触发元素的父级元素，不需要使用循环为每个同级元素添加事件。</p>
<p>当许多同级元素都需要相同的事件行为时，将事件加在他们的父元素上，比如瀑布流。</p>
<p>由于父级元素可能包含其他的元素，不需要添加事件，所以需要区分。</p>
<pre><code class="language-js">function bindEvent(elem, type, selector, fn) {
    if (fn == null) {
        fn = selector
        selector = null
    }
    elem.addEventListener(type, event =&gt; {
        const target = event.target
        if (selector) {
            // 代理绑定
            if (target.matches(selector)) {
                fn.call(target, event)
            }
        } else {
            // 普通绑定
            fn.call(target, event)
        }
    })
}
</code></pre>
<pre><code class="language-html">&lt;div id=&quot;div3&quot;&gt;
    &lt;a href=&quot;#&quot;&gt;a1&lt;/a&gt;&lt;br&gt;
    &lt;a href=&quot;#&quot;&gt;a2&lt;/a&gt;&lt;br&gt;
    &lt;a href=&quot;#&quot;&gt;a3&lt;/a&gt;&lt;br&gt;
    &lt;a href=&quot;#&quot;&gt;a4&lt;/a&gt;&lt;br&gt;
    &lt;button&gt;加载更多...&lt;/button&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-js">// 代理绑定
const div3 = document.getElementById('div3')
bindEvent(div3, 'click', 'a', function (event) {
    event.preventDefault()
    alert(this.innerHTML)
})
</code></pre>
<h3 id="targetmatchesselector"><code>target.matches(selector)</code></h3>
<h4 id="mdn">MDN</h4>
<blockquote>
<p><code>Element.matches()</code></p>
<p>如果元素被指定的选择器字符串选择，<code>Element.matches()</code>方法返回true; 否则返回false。</p>
</blockquote>
<pre><code class="language-js">let result = element.matches(selectorString);
</code></pre>
<ul>
<li><code>result</code> 的值为 <code>true</code> 或 <code>false</code>.</li>
<li><code>selectorString</code> 是个css选择器字符串.</li>
</ul>
<h4 id="示例">示例</h4>
<p>比如我们有这样的一个 HTML 片段：</p>
<pre><code class="language-html">&lt;ul id=&quot;list&quot;&gt;
  &lt;li&gt;item 1&lt;/li&gt;
  &lt;li&gt;item 2&lt;/li&gt;
  &lt;li&gt;item 3&lt;/li&gt;
  ......
  &lt;li&gt;item n&lt;/li&gt;
&lt;/ul&gt;
// ...... 代表中间还有未知数个 li
</code></pre>
<p>我们来实现把 #list 下的 li 元素的事件代理委托到它的父层元素也就是 #list 上：</p>
<pre><code class="language-js">// 给父层元素绑定事件
document.getElementById('list').addEventListener('click', function (e) {
  // 兼容性处理
  var event = e || window.event;
  var target = event.target || event.srcElement;
  // 判断是否匹配目标元素
  if (target.nodeName.toLocaleLowerCase === 'li') {
    console.log('the content is: ', target.innerHTML);
  }
});
</code></pre>
<p>在上述代码中， target 元素则是在 #list 元素之下具体被点击的元素，然后通过判断 target 的一些属性（比如：nodeName，id 等等）可以更精确地匹配到某一类 #list li 元素之上；</p>
<p><strong>使用 Element.matches 精确匹配</strong></p>
<p>如果改变下 HTML 成：</p>
<pre><code class="language-js">&lt;ul id=&quot;list&quot;&gt;
  &lt;li className=&quot;class-1&quot;&gt;item 1&lt;/li&gt;
  &lt;li&gt;item 2&lt;/li&gt;
  &lt;li className=&quot;class-1&quot;&gt;item 3&lt;/li&gt;
  ......
  &lt;li&gt;item n&lt;/li&gt;
&lt;/ul&gt;
// ...... 代表中间还有未知数个 li
</code></pre>
<p>这里，我们想把 #list 元素下的 li 元素（并且它的 class 为 class-1）的点击事件委托代理到 #list 之上；</p>
<p>如果通过上述的方法我们还需要在 <code>if (target.nodeName.toLocaleLowerCase === 'li')</code> 判断之中在加入一个判断 <code>target.nodeName.className === 'class-1'</code>；</p>
<p>但是如果想像 CSS 选择器般做更加灵活的匹配的话，上面的判断未免就太多了，并且很难做到灵活性，这里可以使用 <code>Element.matches API</code> 来匹配；</p>
<p><code>Element.matches API</code>的基本使用方法: <code>Element.matches(selectorString)</code>，<code>selectorString</code> 既是 CSS 那样的选择器规则，比如本例中可以使用 <code>target.matches('li.class-1')</code>，他会返回一个布尔值，如果 target 元素是标签 li 并且它的类是 class-1 ，那么就会返回 true，否则返回 false；</p>
<h2 id="参考">参考</h2>
<p><a href="https://zhuanlan.zhihu.com/p/26536815">JavaScript 事件委托详解</a></p>
<h2 id="推荐阅读">推荐阅读</h2>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/matches">MDN-Element/matches</a></p>
]]></content>
    </entry>
</feed>