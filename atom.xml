<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://leecss.com</id>
    <title>当下</title>
    <updated>2021-06-24T23:04:01.200Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://leecss.com"/>
    <link rel="self" href="https://leecss.com/atom.xml"/>
    <logo>https://leecss.com/images/avatar.png</logo>
    <icon>https://leecss.com/favicon.ico</icon>
    <rights>All rights reserved 2021, 当下</rights>
    <entry>
        <title type="html"><![CDATA[git-pull]]></title>
        <id>https://leecss.com/post/git-pull/</id>
        <link href="https://leecss.com/post/git-pull/">
        </link>
        <updated>2021-06-24T00:30:53.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>既然我们已经知道了如何用 <code>git fetch</code> 获取远程的数据, 现在我们学习如何将这些变化更新到我们的工作当中。</p>
<p>其实有很多方法的 —— 当远程分支中有新的提交时，你可以像合并本地分支那样来合并远程分支。也就是说就是你可以执行以下命令:</p>
<ul>
<li><code>git cherry-pick o/main</code></li>
<li><code>git rebase o/main</code></li>
<li><code>git merge o/main</code></li>
<li>等等</li>
</ul>
<p>实际上，由于先抓取更新再合并到本地分支这个流程很常用，因此 Git 提供了一个专门的命令来完成这两个操作。它就是我们要讲的 <code>git pull</code>。</p>
<p>即<code>git pull</code>相当于<code>git fetch</code> 和 <code>git merge o/main</code>的缩写，取回远程主机某个分支的更新，再与本地的指定分支合并。</p>
<h2 id="注意点">注意点</h2>
<p>即使当前分支有没有 commit 的变动，也可以使用<code>git pull</code>从远程拉取分支。</p>
<h2 id="命令">命令</h2>
<p>git pull完整格式</p>
<pre><code class="language-sh">git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;
git pull origin next:master
</code></pre>
<p>如果远程分支是与当前分支合并，则冒号后面的部分可以省略。</p>
<pre><code class="language-sh">git pull origin next
// 相当于
git fetch origin
git merge origin/next
</code></pre>
<h2 id="追踪关系">追踪关系</h2>
<p>在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。比如，在<code>git clone</code>的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的<code>master</code>分支自动&quot;追踪&quot;<code>origin/master</code>分支。</p>
<p>建立追踪关系，在现有分支与指定的远程分支之间</p>
<pre><code class="language-sh">git branch --set-upstream-to=origin/[remote-branch] [branch]
</code></pre>
<p>如果当前分支与远程分支存在追踪关系，<code>git pull</code>就可以省略远程分支名。</p>
<p>即本地的当前分支自动与对应的<code>origin</code>主机&quot;追踪分支&quot;（remote-tracking branch）进行合并。</p>
<pre><code class="language-sh">git pull origin
</code></pre>
<p>如果当前分支只有一个追踪分支，连远程主机名都可以省略。</p>
<p>即当前分支自动与唯一一个追踪分支进行合并。</p>
<pre><code class="language-sh">git pull
</code></pre>
<h2 id="参数">参数</h2>
<p>如果合并需要采用rebase模式，可以使用<code>--rebase</code>选项。</p>
<pre><code class="language-sh">git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;
</code></pre>
<p>如果远程主机删除了某个分支，默认情况下，<code>git pull</code> 不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止，由于其他人操作了远程主机，导致<code>git pull</code>不知不觉删除了本地分支。</p>
<p>但是，你可以改变这个行为，加上参数 <code>-p</code> 就会在本地删除远程已经删除的分支。</p>
<pre><code class="language-sh">git pull -p
// 等同于
git fetch --prune origin
git fetch -p
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git-fetch]]></title>
        <id>https://leecss.com/post/git-fetch/</id>
        <link href="https://leecss.com/post/git-fetch/">
        </link>
        <updated>2021-06-24T00:04:39.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>从远程仓库获取数据，一旦远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地，这时就要用到<code>git fetch</code>命令。</p>
<h3 id="git-fetch-做了些什么">git fetch 做了些什么</h3>
<p><code>git fetch</code> 完成了仅有的但是很重要的两步:</p>
<ul>
<li>从远程仓库下载本地仓库中缺失的提交记录</li>
<li>更新远程分支指针(如 <code>o/main</code>)</li>
</ul>
<p><code>git fetch</code> 实际上将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态。</p>
<p><code>git fetch</code> 通常通过互联网（使用 <code>http://</code> 或 <code>git://</code> 协议) 与远程仓库通信。</p>
<h3 id="git-fetch-不会做的事">git fetch 不会做的事</h3>
<p><code>git fetch</code> 并不会改变你本地仓库的状态。它不会更新你的 <code>main</code> 分支，也不会修改你磁盘上的文件。</p>
<p>理解这一点很重要，因为许多开发人员误以为执行了 <code>git fetch</code> 以后，他们本地仓库就与远程仓库同步了。它可能已经将进行这一操作所需的所有数据都下载了下来，但是<strong>并没有</strong>修改你本地的文件。</p>
<p>所以, 你可以将 <code>git fetch</code> 的理解为单纯的下载操作。</p>
<h2 id="命令">命令</h2>
<h3 id="获取更新">获取更新</h3>
<p>将某个远程主机的更新，全部取回本地。</p>
<pre><code class="language-sh">git fetch &lt;远程主机名&gt;
git fetch origin
</code></pre>
<p><code>git fetch</code>命令通常用来查看其他人的进程，因为它取回的代码对你本地的开发代码没有影响。</p>
<p>默认情况下，<code>git fetch</code>取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名。</p>
<pre><code class="language-sh">git fetch &lt;远程主机名&gt; &lt;分支名&gt;
git fetch origin master
</code></pre>
<h3 id="使用更新">使用更新</h3>
<p>取回远程主机的更新以后，可以在它的基础上，使用<code>git checkout</code>命令创建一个新的分支。</p>
<pre><code class="language-sh">git checkout -b newBrach origin/master
</code></pre>
<p>在本地分支上合并远程分支。</p>
<pre><code class="language-sh">git merge origin/master
git rebase origin/master
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git-clone]]></title>
        <id>https://leecss.com/post/git-clone/</id>
        <link href="https://leecss.com/post/git-clone/">
        </link>
        <updated>2021-06-23T23:55:52.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>在<strong>本地</strong>创建一个远程仓库的拷贝，<code>git clone</code>命令用于克隆远程分支。</p>
<h2 id="远程仓库">远程仓库</h2>
<p>远程仓库相当于本地仓库的上游仓库，两者之间可以相互同步；</p>
<p>可以为本地仓库添加多个远程仓库，同步的时候，指定远程仓库的名称即可。</p>
<h2 id="远程分支">远程分支</h2>
<p>远程分支有一个命名规范 —— 它们的格式是:</p>
<ul>
<li><code>&lt;remote name&gt;/&lt;branch name&gt;</code></li>
</ul>
<p>因此，如果你看到一个名为 <code>o/main</code> 的分支，那么这个分支就叫 <code>main</code>，远程仓库的名称就是 <code>o</code>。</p>
<p>大多数的开发人员会将它们主要的远程仓库命名为 <code>origin</code>，并不是 <code>o</code>。这是因为当你用 <code>git clone</code> 某个仓库时，Git 已经帮你把远程仓库的名称设置为 <code>origin</code> 了</p>
<p>远程分支有一个特别的属性，在你检出时自动进入分离 HEAD 状态。Git 这么做是出于不能直接在这些分支上进行操作的原因, 你必须在别的地方完成你的工作。</p>
<h2 id="命令">命令</h2>
<p>从远程主机克隆一个版本库</p>
<pre><code class="language-sh">git clone https://github.com/jquery/jquery.git
</code></pre>
<p>从远程主机克隆一个版本库并指定本地目录名</p>
<pre><code class="language-sh">git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;
</code></pre>
<p>从远程主机克隆一个版本库并指定主机名</p>
<pre><code class="language-sh">git clone -o jQuery https://github.com/jquery/jquery.git
</code></pre>
<p>克隆某个指定分支的代码</p>
<pre><code class="language-sh">git clone -b &lt;branch name&gt; &lt;remote url&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git-describe]]></title>
        <id>https://leecss.com/post/git-describe/</id>
        <link href="https://leecss.com/post/git-describe/">
        </link>
        <updated>2021-06-23T00:05:00.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>由于标签在代码库中起着“锚点”的作用，Git 还为此专门设计了一个命令用来<strong>描述</strong>离你最近的锚点（也就是标签），它就是 <code>git describe</code>！</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>由于标签在代码库中起着“锚点”的作用，Git 还为此专门设计了一个命令用来<strong>描述</strong>离你最近的锚点（也就是标签），它就是 <code>git describe</code>！</p>
<!-- more -->
<pre><code class="language-sh">git describe &lt;ref&gt;
git describe &lt;branch&gt;
</code></pre>
<p><code>&lt;ref&gt;</code> 可以是任何能被 Git 识别成提交记录的引用，如果你没有指定的话，Git 会以你目前所检出的位置（<code>HEAD</code>）。</p>
<p>它输出的结果是这样的：</p>
<pre><code class="language-sh">&lt;tag&gt;_&lt;numCommits&gt;_g&lt;hash&gt;
</code></pre>
<p><code>tag</code> 表示的是离 <code>ref</code> 最近的标签， <code>numCommits</code> 是表示这个 <code>ref</code> 与 <code>tag</code> 相差有多少个提交记录， <code>hash</code> 表示的是你所给定的 <code>ref</code> 所表示的提交记录哈希值的前几位。</p>
<p>当 <code>ref</code> 提交记录上有某个标签时，则只输出标签名称</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git-tag]]></title>
        <id>https://leecss.com/post/git-tag/</id>
        <link href="https://leecss.com/post/git-tag/">
        </link>
        <updated>2021-06-23T00:04:06.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>标签<em>永远</em>指向某个提交记录。</p>
<p>当软件发布新的大版本，或者是修正一些重要的 Bug 或是增加了某些新特性，我们可以打一个标签，标识了某个特定的位置。</p>
<p>标签不会随着新的提交而移动。你也不能检出到某个标签上面进行修改提交，它就像是提交树上的一个锚点，标识了某个特定的位置。</p>
<p>标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。</p>
<h2 id="命令">命令</h2>
<h3 id="新建标签">新建标签</h3>
<h4 id="普通标签">普通标签</h4>
<p>新建一个tag在当前commit</p>
<p>如果你不指定提交记录，Git 会用 <code>HEAD</code> 所指向的位置。</p>
<pre><code class="language-sh">git tag [tag]
git tag v1
</code></pre>
<p>新建一个tag在指定commit</p>
<pre><code>git tag [tag] [commit]
git tag v1 C1
</code></pre>
<h4 id="注解标签">注解标签</h4>
<p>创建带有说明的标签，用<code>-a</code>指定标签名，<code>-m</code>指定说明文字</p>
<pre><code class="language-sh">git tag -a [VERSION] -m &quot;released [VERSION]&quot;
git tag -a v0.1 -m &quot;version 0.1 released&quot;
git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb
</code></pre>
<h3 id="删除标签">删除标签</h3>
<h4 id="删除本地标签">删除本地标签</h4>
<pre><code class="language-sh">git tag -d &lt;tagname&gt;
git tag -d v1.0
</code></pre>
<h4 id="删除远程标签">删除远程标签</h4>
<p>删除本地标签后，推送到远程</p>
<pre><code class="language-sh">git push &lt;remote&gt; :refs/tags/&lt;tagname&gt;
git push origin :refs/tags/v1.0
</code></pre>
<p>删除远程标签</p>
<pre><code class="language-sh">git push origin --delete &lt;tagname&gt;
</code></pre>
<h3 id="查看标签">查看标签</h3>
<p>列出所有tag，标签不是按时间顺序列出，而是按字母排序的。</p>
<pre><code class="language-sh">git tag
</code></pre>
<p>查看tag信息</p>
<pre><code class="language-sh">git show [tag]
</code></pre>
<h3 id="提交标签">提交标签</h3>
<p>提交指定tag</p>
<pre><code class="language-sh">git push [remote] [tag]
git push origin v1
</code></pre>
<p>提交所有tag</p>
<pre><code class="language-sh">git push [remote] --tags
git push origin --tags
</code></pre>
<h3 id="使用标签">使用标签</h3>
<p>新建一个分支，指向某个tag</p>
<pre><code class="language-sh">git checkout -b [branch] [tag]
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git-cherry-pick]]></title>
        <id>https://leecss.com/post/git-cherry-pick/</id>
        <link href="https://leecss.com/post/git-cherry-pick/">
        </link>
        <updated>2021-06-22T00:13:27.000Z</updated>
        <summary type="html"><![CDATA[<p><code>git cherry-pick</code>命令”复制”一个提交节点并在当前分支做一次完全一样的新提交。</p>
]]></summary>
        <content type="html"><![CDATA[<p><code>git cherry-pick</code>命令”复制”一个提交节点并在当前分支做一次完全一样的新提交。</p>
<!-- more -->
<pre><code class="language-sh">git cherry-pick commitID
git cherry-pick c2 c4
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git-revert]]></title>
        <id>https://leecss.com/post/git-revert/</id>
        <link href="https://leecss.com/post/git-revert/">
        </link>
        <updated>2021-06-21T23:38:48.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="概述">概述</h2>
<p><code>git revert</code>命令用于撤销某个具体的commit。</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p><code>git revert</code>命令用于撤销某个具体的commit。</p>
<!-- more -->
<pre><code class="language-sh">git revert &lt;commitID&gt;
</code></pre>
<p>撤销上一个commit,之后推送到远程</p>
<pre><code class="language-sh">git revert HEAD
</code></pre>
<h2 id="revert和reset的区别">revert和reset的区别</h2>
<p>reset（重置）：将版本回退到某个commit</p>
<p>恢复（revert）:  回滚某个具体的commit,将它撤销</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git-reset]]></title>
        <id>https://leecss.com/post/git-reset/</id>
        <link href="https://leecss.com/post/git-reset/">
        </link>
        <updated>2021-06-21T23:37:30.000Z</updated>
        <content type="html"><![CDATA[<h2 id="撤销区域">撤销区域</h2>
<h3 id="暂存区">暂存区</h3>
<p>撤销已经添加到暂存区中的修改，即让暂存区与最近的提交保持一致，可以使用如下命令，如下三条命令等效</p>
<pre><code class="language-sh">git reset
git reset HEAD
git reset --mixed HEAD
</code></pre>
<p>撤销上一次向暂存区添加的某个指定文件，不影响工作区中的该文件</p>
<pre><code class="language-sh">git reset -- &lt;filename&gt;
git reset -- file1 file2
</code></pre>
<h3 id="暂存区和工作区">暂存区和工作区</h3>
<p>撤销所有暂存区和工作区中的所有变更,回复到上一次提交的状态</p>
<pre><code class="language-sh">git reset --hard
</code></pre>
<p>回退到指定的提交</p>
<pre><code class="language-sh">git reset --hard commitID
</code></pre>
<h2 id="参数">参数</h2>
<ul>
<li>soft: 不改变工作区和缓存区，只移动 HEAD 到指定 commit。</li>
<li>mixed: 只改变缓存区，不改变工作区。这是默认参数，通常用于撤销<code>git add</code>。</li>
<li>hard：改变工作区和暂存区到指定 commit。该参数等同于重置，可能会引起数据损失。<code>git reset --hard</code>等同于<code>git reset --hard HEAD</code>。</li>
<li><code>-p</code>表示键入交互模式，指定暂存区的哪些部分需要撤销。</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>工作区</th>
<th>缓存区</th>
<th>HEAD</th>
</tr>
</thead>
<tbody>
<tr>
<td>–soft</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>–mixed</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>–hard</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
</tbody>
</table>
<pre><code class="language-shell">// 将当期分支的指针倒退一个 commit，只改变仓库
git reset --soft HEAD~
// 将当期分支的指针倒退一个 commit，改变仓库，并且会改变暂存区
git reset HEAD~
// 将当期分支的指针倒退一个 commit，改变仓库，暂存区，工作区
git reset --hard HEAD~
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git-相对引用]]></title>
        <id>https://leecss.com/post/git-xiang-dui-yin-yong/</id>
        <link href="https://leecss.com/post/git-xiang-dui-yin-yong/">
        </link>
        <updated>2021-06-20T02:53:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>通过哈希值指定提交记录很不方便，所以 Git 引入了相对引用。</p>
<p>使用相对引用的话，你就可以从一个易于记忆的地方（比如bugFix 分支或 HEAD）开始计算。</p>
<h2 id="分类">分类</h2>
<h3 id="操作符~">操作符~</h3>
<p>HEAD 表示当前分支的最新提交</p>
<p>HEAD~ 表示当前分支的最新提交的前一个提交（即最新的第二个提交，也就是最新提交的父提交）</p>
<p>HEAD~~ 表示当前分支的最新提交的前前提交（即最新的第三个提交，也就是最新提交的祖父提交）</p>
<p>HEAD~~~ 表示当前分支的最新提交的前前前提交（即最新的第四个提交，也就是最新提交的曾祖父提交）</p>
<blockquote>
<p>HEAD~~~等效于HEAD~3</p>
<p>HEAD~~等效于HEAD~2</p>
<p>HEAD<sub>等效于HEAD</sub>1</p>
<p>HEAD等效于HEAD~0</p>
</blockquote>
<h3 id="操作符">操作符^</h3>
<h4 id="单个直系父提交">单个直系父提交</h4>
<p>把这个符号加在引用名称的后面，表示让 Git 寻找指定提交记录的父提交。</p>
<p>方式一</p>
<p><code>main^</code> 相当于“<code>main</code> 的父节点”。</p>
<p><code>main^^</code> 是 <code>main</code> 的第二个父节点</p>
<p>方式二</p>
<p>我们也可以多次使用 <code>HEAD^</code> 向上移动。</p>
<pre><code class="language-sh">git checkout HEAD^
git checkout HEAD^
</code></pre>
<h4 id="多个直系父提交">多个直系父提交</h4>
<p>假如当前提交不只一个父节点，有多个直系父提交呢？</p>
<p>如果一个提交有多个父提交，那么 <code>~</code> 只会找第一个父提交。</p>
<p>使用<code>HEAD^2</code>来找到第二个父提交</p>
<pre><code class="language-sh">
G   H   I   J
 \ /     \ /
  D   E   F
   \  |  / \
    \ | /   |
     \|/    |
      B     C
       \   /
        \ /
         A
 
A =      = A^0
B = A^   = A^1     = A~1
C = A^2
D = A^^  = A^1^1   = A~2
E = B^2  = A^^2
F = B^3  = A^^3
G = A^^^ = A^1^1^1 = A~3
H = D^2  = B^^2    = A^^^2  = A~2^2
I = F^   = B^3^    = A^^3^
J = F^2  = B^3^2   = A^^3^2
</code></pre>
<h2 id="混合链式调用">混合链式调用</h2>
<pre><code class="language-sh">git checkout HEAD~^2~2
</code></pre>
<p>选择直系父节点的 第二个父节点的 直系第二个父节点</p>
<h2 id="应用">应用</h2>
<h3 id="强制修改分支位置">强制修改分支位置</h3>
<p>使用相对引用最多的就是移动分支。可以直接使用 <code>-f</code> 选项让分支指向另一个提交。例如:</p>
<pre><code class="language-shell">git branch -f main HEAD~3
git branch -f dev c2
</code></pre>
<p>相对引用为我们提供了一种简洁的引用提交记录 的方式， 而 <code>-f</code> 则容许我们将分支强制移动到那个位置。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git-reference(指针)]]></title>
        <id>https://leecss.com/post/git-referencezhi-zhen/</id>
        <link href="https://leecss.com/post/git-referencezhi-zhen/">
        </link>
        <updated>2021-06-19T15:28:49.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>所谓指针（reference），只是一个链接，用来指向其他物体，方便引用。Git有三种指针，但是所有指针归根结底都是指向某个commit。</p>
<h2 id="分类">分类</h2>
<h3 id="head指针">HEAD指针</h3>
<p>头指针：指向目前所在的Branch，用来区分目前在哪个分支。</p>
<p>查看HEAD 指向</p>
<pre><code class="language-sh">cat .git/HEAD
</code></pre>
<p>结果：ref: refs/heads/master</p>
<p>可以看出HEAD指针指向的是refs/heads/master文件，即master分支</p>
<hr>
<p>如果 HEAD 指向的是一个引用,可以通过以下命令查看它的指向</p>
<pre><code class="language-sh">git symbolic-ref HEAD
</code></pre>
<h3 id="branch指针">Branch指针</h3>
<p>分支指针：指向某个commit。每次该分支有新的commit，指针就会变动，指向当前分支的最新提交。</p>
<p>当我们从master新建一个test分支时，git只会创建一个test分支指针，并且让test分支指针指向master分支对应的最新的提交。</p>
<p>查看master分支文件的内容</p>
<pre><code class="language-sh">cat .git/refs/heads/master
</code></pre>
<p>可以看到，这个文件的内容是一串哈希码，而这个哈希码正是master分支上最新的提交所对应的哈希码。</p>
<h2 id="分离头">分离头</h2>
<p>通常情况下，HEAD指针总是通过分支指针，间接的指向了当前分支的最新提交。</p>
<p>不通常的情况便是分离头（detached HEAD）：就是头指针和分支指针分开了，HEAD指针没有指向分支指针，而是直接指向了某个提交。</p>
<p>我们随便检出到某个提交，都可以进入分离头状态</p>
<pre><code>git checkout cbd3348
</code></pre>
<p><strong>分离头的应用</strong></p>
<p>由于刚才我们直接检出了’cbd3348’这个提交，所以，我们处于分离头状态，而且当前仓库中各个文件的内容也回到了’cbd3348’这个提交对应的状态。此时创建了两个新提交，这两个新提交与分叉点之前的提交组成了一条匿名分支，没有任何一个分支标签指向这个匿名分支。我们现在有两个选择，如下：</p>
<p>选择一：丢弃这个匿名分支</p>
<blockquote>
<p>直接检出到任何一个别的分支，就相当于放弃了这些提交</p>
</blockquote>
<p>选择二：保留这个匿名分支</p>
<blockquote>
<p>只需要将这些提交创建成一条新的分支就行了</p>
</blockquote>
<pre><code class="language-sh">git checkout -b newtest
</code></pre>
<pre><code class="language-sh">git branch newtest dca15df
</code></pre>
]]></content>
    </entry>
</feed>