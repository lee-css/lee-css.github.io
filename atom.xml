<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://leecss.com</id>
    <title>当下</title>
    <updated>2021-07-07T14:43:16.546Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://leecss.com"/>
    <link rel="self" href="https://leecss.com/atom.xml"/>
    <logo>https://leecss.com/images/avatar.png</logo>
    <icon>https://leecss.com/favicon.ico</icon>
    <rights>All rights reserved 2021, 当下</rights>
    <entry>
        <title type="html"><![CDATA[http-TCP/IP三次握手]]></title>
        <id>https://leecss.com/post/http-tcpip-san-ci-wo-shou/</id>
        <link href="https://leecss.com/post/http-tcpip-san-ci-wo-shou/">
        </link>
        <updated>2021-07-07T14:33:24.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>目的是为了保证可靠的通信</p>
<h2 id="三个版本的解释">三个版本的解释</h2>
<h3 id="版本一">版本一</h3>
<p>简单说，让双方都证实对方能发收。<br>
知道对方能收是因为收到对方的因为收到而发的回应。<br>
具体：<br>
1：A发，B收， B知道A能发<br>
2：B发，A收， A知道B能发收<br>
3：A发，B收， B知道A能收</p>
<h3 id="版本二图解http">版本二：图解HTTP</h3>
<p>按层次分，TCP 位于传输层，提供可靠的字节流服务。</p>
<p>所谓的字节流服务（Byte Stream Service）是指，为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理。而可靠的传输服务是指，能够把数据准确可靠地传给对方。一言以蔽之，TCP 协议为了更容易传送大数据才把数据分割，而且 TCP 协议能够确认数据最终是否送达到对方。</p>
<p><strong>确保数据能到达目标</strong></p>
<p>为了准确无误地将数据送达目标处，TCP 协议采用了三次握手（three-way handshaking）策略。用 TCP 协议把数据包送出去后，TCP不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了 TCP 的标志（flag） —— SYN（synchronize） 和ACK（acknowledgement）。</p>
<p>发送端首先发送一个带 SYN 标志的数据包给对方。接收端收到后，回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。最后，发送端再回传一个带 ACK 标志的数据包，代表“握手”结束。</p>
<p>若在握手过程中某个阶段莫名中断，TCP 协议会再次以相同的顺序发送相同的数据包。</p>
<figure data-type="image" tabindex="1"><img src="https://leecss.com/post-images/1625668531620.jpg" alt="" loading="lazy"></figure>
<p>除了上述三次握手，TCP 协议还有其他各种手段来保证通信的可靠性。</p>
<h3 id="版本三车小胖">版本三：车小胖</h3>
<p>TCP作为一种可靠传输控制协议，其<strong>核心思想</strong>：既要保证数据可靠传输，又要提高传输的效率，而用<strong>三次恰恰可以满足以上两方面的需求！</strong></p>
<p><strong>TCP可靠传输的精髓</strong>：TCP连接的一方A，由操作系统动态随机选取一个<strong>32位长的序列号（Initial Sequence Number）</strong>，假设A的初始序列号为1000，以该序列号为原点，对自己将要发送的每个字节的数据进行编号，1001，1002，1003…，并把自己的初始序列号ISN告诉B，<strong>让B有一个思想准备</strong>，什么样编号的数据是合法的，什么编号是非法的，比如编号900就是非法的，同时B还可以对A每一个编号的字节数据进行确认。如果A收到B确认编号为2001，则意味着字节编号为1001-2000，共1000个字节已经安全到达。</p>
<p>同理B也是类似的操作，假设B的初始序列号ISN为2000，以该序列号为原点，对自己将要发送的每个字节的数据进行编号，2001，2002，2003…，并把自己的初始序列号ISN告诉A，以便A可以确认B发送的每一个字节。如果B收到A确认编号为4001，则意味着字节编号为2001-4000，共2000个字节已经安全到达。</p>
<p><strong>一句话概括，TCP连接握手，握的是啥？</strong></p>
<p><strong>通信双方数据原点的序列号！</strong></p>
<p>以此核心思想我们来分析二、三、四次握手的过程。</p>
<p>A &lt;-------&gt; B</p>
<p><strong>四次握手的过程：</strong></p>
<p><strong>1.1</strong> A 发送同步信号<strong>SYN</strong> + <strong>A'sInitial sequence number</strong></p>
<p><strong>1.2</strong> B 确认收到A的同步信号，并记录A's ISN 到本地，命名 <strong>B's ACK sequence number<br>
**<br>
<strong>1.3</strong> B发送同步信号</strong>SYN** + **B's Initial sequence number<br>
**<br>
<strong>1.4</strong> A确认收到B的同步信号，并记录B's ISN 到本地，命名 <strong>A's ACK sequence number</strong></p>
<p>很显然1.2和1.3 这两个步骤可以合并，**只需要三次握手，**可以提高连接的速度与效率。</p>
<p><strong>二次握手的过程：</strong></p>
<p><strong>2.1</strong> A 发送同步信号<strong>SYN</strong> + <strong>A'sInitial sequence number</strong></p>
<p><strong>2.2</strong> B发送同步信号<strong>SYN</strong> + <strong>B'sInitial sequence number</strong> + <strong>B's ACK sequence number</strong></p>
<p>这里有一个问题，A与B就A的初始序列号达成了一致，这里是1000。<strong>但是</strong>B无法知道A是否已经接收到自己的同步信号，如果这个同步信号丢失了，<strong>A和B就B的初始序列号将无法达成一致。</strong></p>
<p>于是TCP的设计者将<strong>SYN这个同步标志位SYN设计成占用一个字节的编号（FIN标志位也是）</strong>，既然是一个字节的数据，按照TCP对有数据的TCP segment 必须确认的原则，所以在这里A必须给B一个确认，以确认A已经接收到B的同步信号。</p>
<p>有童鞋会说，如果A发给B的确认丢了，该如何？<br>
A会超时重传这个ACK吗？不会！<strong>TCP不会为没有数据的ACK超时重传</strong>。</p>
<p>那该如何是好？<strong>B如果没有收到A的ACK，会超时重传自己的SYN同步信号，一直到收到A的ACK为止。</strong></p>
<p><strong>补充阅读</strong></p>
<p><strong>第一个包，即A发给B的SYN 中途被丢，没有到达B</strong></p>
<p>A会周期性超时重传，直到收到B的确认</p>
<p><strong>第二个包，即B发给A的SYN +ACK 中途被丢，没有到达A</strong></p>
<p>B会周期性超时重传，直到收到A的确认</p>
<p><strong>第三个包，即A发给B的ACK 中途被丢，没有到达B</strong></p>
<p>A发完ACK，单方面认为TCP为 Established状态，而B显然认为TCP为Active状态：</p>
<p>a. 假定此时双方都没有数据发送，B会周期性超时重传，直到收到A的确认，收到之后B的TCP 连接也为 Established状态，双向可以发包。</p>
<p>b. 假定此时A有数据发送，B收到A的 Data + ACK，自然会切换为established 状态，并接受A的Data。</p>
<p>c. 假定B有数据发送，数据发送不了，会一直周期性超时重传SYN + ACK，直到收到A的确认才可以发送数据。</p>
<hr>
<p>记得第一次看TCP握手连接的时候，有同样的疑问，我的疑问是，为何不是两次呢？</p>
<p>后来随着对网络的理解深入，明白TCP报文是交由IP网络来负责运输，IP网络并不能保证TCP报文到达目的地，既然IP网络是指望不上了，那TCP就自力更生吧，TCP必须依赖自身的努力来保证数据传输的可靠。</p>
<p>TCP看似复杂，其实可以归纳为以下5种报文：</p>
<p><strong>（1）</strong>   <strong>SYN</strong></p>
<p><strong>（2）</strong>   <strong>Data</strong> <strong>（唯一携带用户数据）</strong></p>
<p><strong>（3）</strong>   <strong>FIN</strong></p>
<p><strong>（4）</strong>   <strong>Reset</strong></p>
<p><strong>（5）</strong>   <strong>ACK</strong></p>
<p>其中1、2、3分别为<strong>建立连接、数据传输、断开连接</strong>，这三种报文对方接收到一定要ACK确认，为何要确认，因为这就是可靠传输的依赖的机制。如果对方在超时时间内不确认，发送方会一直重传，直到对方确认为止、或到达重传上限次数而Reset连接。</p>
<p>4、5 为<strong>重置连接报文、确认ACK报文</strong>，这两种报文对方接收到要ACK确认吧？不需要！自然发送方也不会重传这2种类型的报文。</p>
<p><strong>为何Reset报文不需要ACK确认?</strong></p>
<p>因为发送Reset报文的一端，在发送完这个报文之后，和该TCP Session有关的内存结构体瞬间全部释放，无论对方收到或没有收到，关系并不大。</p>
<p>如果对方收到Reset报文，也会释放该TCP Session 的相关内存结构体。</p>
<p>如果对方没有收到Reset 报文，可能会继续发送让接收方弹射出Reset报文的报文，到最后对方一样会收到Reset 报文，并最终释放内存。</p>
<p><strong>为何ACK报文不需要ACK确认?</strong></p>
<p>这里的ACK报文，是指没有携带任何数据的裸ACK报文，对方收到这样的ACK报文，自然也不需要ACK。否则，对方为了ACK己方的ACK，那己方收到对方的ACK，也要ACK对方的ACK，这就是一个死循环，永无止息。</p>
<p>所以为了避免这个死循环，一律不允许ACK对方的裸ACK报文。</p>
<p>有同学会说，按照这么说，TCP连接应该是四次消息交互啊。</p>
<p><strong>1.A 发送SYN 报文给B，这是第一次报文交互。</strong></p>
<p><strong>2. B发送ACK确认A的SYN报文，这是第二次报文交互</strong></p>
<p><strong>3. B发送自己的SYN报文给A，这是第三次报文交互</strong></p>
<p><strong>4. A需要ACK确认B的SYN报文，这是第四次报文交互</strong></p>
<p>以上的演绎没有问题，但是报文2、3为何要分开发送呢？增加了延迟不说，同时还白白浪费了网络的带宽，完全可以将报文2、3合并起来，不就是在报文2的ACK状态位的位置置“1”就结了吗？</p>
<p>这就是三次消息交互的由来！</p>
<h2 id="推荐阅读">推荐阅读</h2>
<p><a href="https://mp.weixin.qq.com/s/NIjxgx4NPn7FC4PfkHBAAQ">车小胖谈网络</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[http-连接管理]]></title>
        <id>https://leecss.com/post/http-lian-jie-guan-li/</id>
        <link href="https://leecss.com/post/http-lian-jie-guan-li/">
        </link>
        <updated>2021-07-07T13:12:39.000Z</updated>
        <content type="html"><![CDATA[<h1 id="http-连接管理">http-连接管理</h1>
<h2 id="概述">概述</h2>
<p>http连接的几种方式：串行连接、并行连接、持久连接、管道化连接……</p>
<h2 id="分类">分类</h2>
<h3 id="串行连接">串行连接</h3>
<p>也称为短连接、短轮询。</p>
<p>HTTP事务需要按顺序进行传输，等待服务端完成处理并回传。</p>
<p>缺点：</p>
<p>每次HTTP通信后都要断开TCP连接，所以每个新的HTTP请求都需要建立一个新的tcp连接，极大的增加了通信开销。</p>
<figure data-type="image" tabindex="1"><img src="https://leecss.com/post-images/1625668312340.png" alt="" loading="lazy"></figure>
<h3 id="并行连接">并行连接</h3>
<p>并发的执行多条HTTP请求，且每个请求都有自己的TCP连接。</p>
<p>特点：</p>
<p>并行连接的速度可能会更快，但不一定总是更快。</p>
<p>实际上多条连接会产生一些额外的开销，使用并行连接装载整个页面所需的时间很可能比串行下载的时间更长。</p>
<p>如果并行加载多个对象，每个对象都会去竞争这有限的带宽，每个对象都会以比较慢的速度按比例加载，这样带来的性能提升就很小，甚至没什么提升。</p>
<p>而且打开大量连接会消耗很多内存资源，从而引发自身的性能问题。</p>
<p>假如一百个用户同时发出申请，每个用户打开100个连接，服务器就要处理10 000个连接。这会造成服务器性能的严重下降。</p>
<hr>
<p>实际上，浏览器确实使用了并行连接，但它们并行连接的总数限制为一个较小的值(通常是4个)。</p>
<p>服务器可以随意的关闭来自特定客户端的超量连接。</p>
<figure data-type="image" tabindex="2"><img src="https://leecss.com/post-images/1625668321507.png" alt="" loading="lazy"></figure>
<h3 id="持久连接">持久连接</h3>
<p>也叫长连接、长轮询</p>
<p>在事务处理结束之后仍然保持在打开状态的TCP连接称为持久连接。</p>
<p><strong>方式</strong></p>
<p>持久连接有两种方式，分别为HTTP/1.0+的“Keep-alive”连接，以及HTTP/1.1的“persistent”连接。</p>
<p><strong>Keep-alive</strong>：该首部只是请求将连接保持在活跃状态，客户端和服务端可以随时关闭空闲的Keep-alive连接。</p>
<p>限制和规则：</p>
<p>1、必须客户端发送一个Connection：Keep-alive请求首部来激活Keep-alive连接，服务端不一定答应启用Keep-Alive会话；</p>
<p>2、必须随每个希望保持持久连接的请求的头部一起发送，如果某个请求没有带Keep-Alive头部，则服务器会在这个请求后关闭该连接。</p>
<hr>
<p><strong>Persistent</strong>：该首部默认情况下是激活的，除非特别指明，否则HTTP/1.1假定所有连接都是持久的。</p>
<p>限制和规则：</p>
<p>1、发送了 Connection: close 请求首部之后，客户端就无法在那条连接上发送更多的请求了。</p>
<p>如果客户端不想在连接上发送其他请求了，就应该在最后一条请求中发送一个Connection: close 请求首部。</p>
<p>2、只有当连接上所有的报文都有正确的、自定义报文长度时——也就是说，实体主体部分的长度都和相应的Content-Length 一致，或者是用分块传输编码方式编码的——连接才能持久保持。</p>
<figure data-type="image" tabindex="3"><img src="https://leecss.com/post-images/1625668334800.png" alt="" loading="lazy"></figure>
<h3 id="管道化连接">管道化连接</h3>
<p>在持久连接的基础上可选的使用请求管道。在响应到达之前，可以将多条请求放入队列。</p>
<p>限制：</p>
<p>1、如果HTTP客户端无法确认连接是持久的,就不应该使用管道。</p>
<p>2、必须按照与请求相同的顺序回送HTTP响应。HTTP报文中没有序列号标签,因此如果收到的响应失序了,就没办法将其与请求匹配起来了。</p>
<p>3、HTTP 客户端必须做好连接会在任意时刻关闭的准备,还要准备好重发所有未完成的管道化请求。如果客户端打开了一条持久连接,并立即发出了10条请求,服务器可能在只处理了,比方说,5条请求之后关闭连接。剩下的5 条请求会失败,客户端必须能够应对这些过早关闭连接的情况,重新发出这些请求。</p>
<p>4、HTTP 客户端不应该用管道化的方式发送会产生副作用的请求(比如POST)。总之,出错的时候,管道化方式会阻碍客户端了解服务器执行的是一系列管道化请求中的哪一些。由于无法安全地重试POST这样的非幂等请求,所以出错时,就存在某些方法永远不会被执行的风险。</p>
<figure data-type="image" tabindex="4"><img src="https://leecss.com/post-images/1625668345578.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[http-版本历史]]></title>
        <id>https://leecss.com/post/http-ban-ben-li-shi/</id>
        <link href="https://leecss.com/post/http-ban-ben-li-shi/">
        </link>
        <updated>2021-07-06T14:54:48.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>现在使用的HTTP协议有几个版本。HTTP程序要尽量强健地处理各种不同的HTTP协议变体。</p>
<h2 id="版本">版本</h2>
<h3 id="http09">HTTP/0.9</h3>
<p><strong>特点</strong></p>
<p>HTTP/0.9只支持GET方法。</p>
<hr>
<p>不支持多媒体内容的MIME类型、各种HTTP首部，或者版本号。</p>
<p>服务器发送完毕，就关闭TCP连接。</p>
<p><strong>命名</strong></p>
<p>HTTP 于 1990 年问世。那时的 HTTP 并没有作为正式的标准被建立。</p>
<p>实含有 HTTP1.0 之前版本的意思，因此被称为HTTP/0.9。</p>
<h3 id="http10">HTTP/1.0</h3>
<p><strong>特点</strong></p>
<p>HTTP/1.0添加了status code、header(各种HTTP首部)、版本号、一些额外的方法。</p>
<p>多字符集支持、多部分发送、权限、缓存等。</p>
<hr>
<p>每次请求都打开一个新的TCP链接，收到响应之后立即断开连接。</p>
<p><strong>命名</strong></p>
<p>HTTP 正式作为标准被公布是在 1996 年的 5 月，版本被命名为HTTP/1.0，并记载于 <a href="https://www.ietf.org/rfc/rfc1945.txt">RFC1945</a>。</p>
<p>虽说是初期标准，但该协议标准至今仍被广泛使用在服务器端。</p>
<h3 id="http11">HTTP/1.1</h3>
<p><strong>特点</strong></p>
<h4 id="持久化">持久化</h4>
<p><u>HTTP/1.1 默认开启持久连接，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。</u></p>
<p>在1.0版本中，每进行一次HTTP通信就要断开一次TCP连接。</p>
<p>TCP连接的新建成本很高，频繁地打开关闭会极大地增加开销，影响性能。</p>
<p>于是在1.1版本中引入持久连接的方法。其特点就是任意一端没有明确提出断开连接，则保持TCP连接的状态。</p>
<h4 id="管线化">管线化</h4>
<p><u>HTTP/1.1增加了pipeline支持。</u></p>
<p>管线化的连接建立在持久化连接的基础上，且响应需要顺序返回。</p>
<figure data-type="image" tabindex="1"><img src="https://leecss.com/post-images/1625583403314.jpg" alt="" loading="lazy"></figure>
<p>非管线化的请求：如上图中第一幅</p>
<p>客户端发送一个请求之后，必须等待服务器响应之后才能发送下一个请求，不能同时并行发送多个请求。</p>
<hr>
<p>管线化的请求：如上图中第二幅</p>
<p>客户端一次性发送多个请求，不用等待服务器响应就可以发送下一个请求。</p>
<hr>
<p><strong>队头阻塞</strong></p>
<p>管线化：如上图中第三幅</p>
<p>http1.1规定，服务器端的响应的发送要根据请求被接收的顺序排队，即先接收到的请求需要先响应回来。所以当第一个请求阻塞后，后面的请求都需要等待。</p>
<p>请求可以并行发出，但是响应必须串行返回。后一个响应必须在前一个响应之后。原因是，没有序号标明顺序，只能串行接收，阻塞发生在服务端，http响应阻塞。</p>
<p>非管线化: 如上图中第一幅</p>
<p>后一个请求必须在前一个响应之后发送，发生在客户端，http请求阻塞。</p>
<hr>
<p>HTTP2多路复用：如上图中第四幅</p>
<p>解决第二个请求不被第一个请求阻塞，最好的办法就是来两个TCP连接。传统上浏览器也是这么干的。但是TCP要握手，这个效率低，所以HTTP2把多个这种请求流塞到一个TCP连接里面，这样的连接复用方式就提高了效率，又节省了连接握手。</p>
<p>为了解决HTTP1.1管线化队头阻塞的问题，http2中，将多个请求复用到同一个tcp通道中，通过<strong>二进制分帧</strong>并且<strong>给每个帧</strong>打上<strong>流</strong>的 <strong>ID</strong> 去避免依次响应的问题，对方接收到帧之后<strong>根据 ID 拼接出流</strong>，这样就可以做到乱序响应从而避免请求时的队首阻塞问题。</p>
<p>但是HTTP2没有完全解决队头阻塞问题，因为实际中TCP的连接buffer有限，一个响应又慢，又大的请求会把链接buffer完全占满，导致buffer阻塞，从而导致跟队头阻塞一样的效果。</p>
<h4 id="增加host字段">增加HOST字段</h4>
<p>HTTP/1.1 的请求消息和响应消息都必须包含<code>Host</code>头部，以区分同一个物理主机中的不同虚拟主机的域名。</p>
<p>1.0版本中，认为每台物理服务器对应唯一的IP地址。所以，在1.0版本中是没有主机名这个概念的。但随着Web技术的发展，一台物理服务器可以存在多个虚拟主机，他们共享同一个IP地址。为了解决这个问题，HOST字段应运而生。</p>
<p><strong>命名</strong></p>
<p>1997 年 1 月公布的 HTTP/1.1 是目前主流的 HTTP 协议版本。当初的标准是 RFC2068，之后发布的修订版 <a href="https://www.ietf.org/rfc/rfc2616.txt">RFC2616</a> 就是当前的最新版本。</p>
<h3 id="http20">HTTP/2.0</h3>
<p><strong>特点</strong></p>
<h4 id="二进制分帧">二进制分帧</h4>
<p>在HTTP协议2.0中，应用层和传输层之间会多一个二进制分帧层。在二进制分帧层上，HTTP 2.0 会将所有传输的信息分割为更小的帧,并对它们采用二进制格式的编码 。之前HTTP1.x版本中的HTTP报文首部信息会被封装到Headers帧，而我们的HTTP报文主体则封装到Data帧里面。原先我们是以HTTP报文为单位传输的，现在HTTP报文被拆成了多个帧的形式，并且这些帧可以乱序发送，我们只需根据每个帧首部的流标识符就可以重新完成组装。这样极大提升了HTTP的性能。</p>
<h4 id="多路复用">多路复用</h4>
<p>HTTP/2.0支持多路复用，就是在一个 TCP 连接中可以存在多条流，也就是可以发送多个请求，服务端则可以通过帧中的标识知道该帧属于哪个流（即请求），通过重新排序还原请求。多路复用允许并发的发起多个请求，每个请求及该请求的响应不需要等待其他的请求或响应，避免了队头阻塞问题。这样某个请求任务耗时严重，不会影响到其它连接的正常执行,极大的提高传输性能。</p>
<h4 id="头部压缩">头部压缩</h4>
<p>每次HTTP请求都会有一个请求首部，这个首部放到一些重要信息，比如Cookie、User Agent之类的字段，这些字段每次请求都是一样的，但还必须要带上。这就造成了一些不必要的浪费。2.0中就优化这一点，引入首部压缩机制，客户端和服务端会维护同样一张首部信息表，每次请求只要发送索引号就可以了，不必带上请求首部上冗余的key-value，极大地减少了不必要的浪费。</p>
<h4 id="服务端推送">服务端推送</h4>
<p>在2.0之前的版本中，服务端是属于被动一方，只有客户端发送请求，服务端才能发送资源。2.0协议中，服务端可以主动地向客户端发送资源。例如：客户端请求一个html，里面所需要的js和css完全不需要客户端解析完html之后再去请求这些内容那么麻烦，服务端可以在客户端请求html的时候一起回传过来。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[http-网络模型]]></title>
        <id>https://leecss.com/post/http-wang-luo-mo-xing/</id>
        <link href="https://leecss.com/post/http-wang-luo-mo-xing/">
        </link>
        <updated>2021-07-05T14:41:22.000Z</updated>
        <content type="html"><![CDATA[<h1 id="http-五层网络模型">http-五层网络模型</h1>
<h2 id="1概述">1.概述</h2>
<h3 id="11协议">1.1协议</h3>
<p>协议，网络协议的简称，网络协议是通信计算机双方必须共同遵从的一组约定。如怎么样建立连接、怎么样互相识别等。只有遵守这个约定，计算机之间才能相互通信交流。</p>
<p>为了使数据在网络上从源到达目的，网络通信的参与方必须遵循相同的规则，这套规则称为协议（protocol），它最终体现为在网络上传输的数据包的格式。</p>
<p>协议往往分成几个层次进行定义，分层定义是为了使某一层协议的改变不影响其他层次的协议。</p>
<h3 id="12网络模型">1.2网络模型</h3>
<figure data-type="image" tabindex="1"><img src="https://leecss.com/post-images/1625500448131.jpg" alt="" loading="lazy"></figure>
<h4 id="121四层">1.2.1四层</h4>
<p>TCP/IP 协议族是Internet最基本的协议，按照是否具有TCP/IP 协议族的协议来划分的话，从下到上为：</p>
<ul>
<li>
<p><strong>链路层</strong></p>
<p>用来处理连接网络的硬件部分，包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在链路层的作用范围之内。</p>
</li>
<li>
<p><strong>网络层</strong></p>
<p>网络层规定了数据通过怎样的传输路线到达对方计算机传送给对方（IP协议等）。</p>
</li>
<li>
<p><strong>传输层</strong></p>
<p>传输层对接上层应用层，提供处于网络连接中两台计算机之间的数据传输所使用的协议。</p>
</li>
<li>
<p><strong>应用层</strong></p>
<p>应用层规定了向用户提供应用服务时通信的协议。</p>
</li>
</ul>
<h4 id="122七层">1.2.2七层</h4>
<p>国际标准化组织（ISO）为了规范协议层次的划分制定了开发系统互联（OSI，Open Systems Interconnection）模型，即ISO/OSI参考模型。此模型根据网络功能制定出7层网络协议结构，由低到高分别为物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。</p>
<h4 id="123五层">1.2.3五层</h4>
<p>五层网络模型分别为：物理层，数据链路层，网络层，传输层，应用层。</p>
<p>物理层：主要作用是定义物理设备如何传输数据。</p>
<p>数据链路层：在通信的实体间建立数据链路连接。</p>
<p>网络层：为数据在结点之间传输创建逻辑链路。</p>
<p>传输层：为应用层实体提供端到端的通信功能。</p>
<p>应用层：为应用软件提供了很多服务。</p>
<figure data-type="image" tabindex="2"><img src="https://leecss.com/post-images/1625500557587.jpg" alt="" loading="lazy"></figure>
<h3 id="13层与协议">1.3层与协议</h3>
<p>每一层都是为了完成一种功能。为了实现这些功能，就需要大家都遵守共同的规则。</p>
<p>大家都遵守的规则，就叫做&quot;协议&quot;（protocol）。</p>
<p>互联网的每一层，都定义了很多协议。这些协议集合起来总称为TCP/IP</p>
<h2 id="2五层网络模型详解">2.五层网络模型详解</h2>
<p>数据包格式：<br>
<img src="https://leecss.com/post-images/1625500599926.png" alt="" loading="lazy"></p>
<h3 id="21系统的角度">2.1系统的角度</h3>
<h4 id="211物理层">2.1.1物理层</h4>
<p>光缆、电缆、双绞线、无线电波等方式，<u>把电脑连接起来的物理手段</u>。</p>
<p>它主要规定了网络的一些电气特性，<u>作用是负责传送0和1的电信号。</u></p>
<h4 id="212数据链路层">2.1.2数据链路层</h4>
<p>在&quot;实体层&quot;的上方，<u>确定了0和1的分组方式。</u></p>
<p>有了数据包的定义、网卡的MAC地址、广播的发送方式，&quot;链接层&quot;就可以在多台计算机之间传送数据了。</p>
<p><strong>以太网协议</strong></p>
<p>以太网规定，一组电信号构成一个数据包，叫做&quot;帧&quot;（Frame）。每一帧分成两个部分：标头（Head）和数据（Data）。</p>
<p>&quot;标头&quot;包含数据包的一些说明项，比如发送者、接受者、数据类型等等；&quot;数据&quot;则是数据包的具体内容。</p>
<p>&quot;标头&quot;的长度，固定为18字节。&quot;数据&quot;的长度，最短为46字节，最长为1500字节。因此，整个&quot;帧&quot;最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。</p>
<p><strong>MAC地址</strong></p>
<p>以太网规定，连入网络的所有设备，都必须具有&quot;网卡&quot;接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。</p>
<p>每块网卡出厂的时候，都有一个AC地址，重复概率很小。长度是48个二进制位，通常用12个十六进制数表示。</p>
<pre><code class="language-sh"># MAC Address
00-B0-D0-86-BB-F7
</code></pre>
<p>前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。</p>
<p><strong>广播</strong></p>
<p>早期，以太网采用了一种很原始的方式来识别<strong>服务器</strong>网卡的地址，它不是把数据包准确送到接收方，而是向本网络内所有计算机发送，让每台计算机自己判断，是否为接收方。</p>
<p>同一子网络下所有计算机都会收到<strong>客户端</strong>发出的数据包。它们读取这个包的&quot;标头&quot;，找到接收方的MAC地址，然后与自身的MAC地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。这种发送方式就叫做&quot;广播&quot;（broadcasting）。</p>
<h4 id="213网络层">2.1.3网络层</h4>
<p>互联网是无数子网络共同组成的一个巨型网络，如果客户端与服务器不在一个子网络内，则无法通过广播的方式识别对方。</p>
<p>网络层引进一套新的地址，使得我们能够<u>区分不同的计算机是否属于同一个子网络</u>。这套地址就叫做&quot;网络地址&quot;，简称&quot;网址&quot;。</p>
<p>于是，&quot;网络层&quot;出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。</p>
<p>两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。</p>
<p>网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。</p>
<p><strong>IP协议</strong></p>
<p>规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。</p>
<p>IP协议的作用主要有两个，<u>一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。</u></p>
<p>目前，广泛采用的是IP协议第四版，简称IPv4。这个版本规定，网络地址由32个二进制位组成。</p>
<pre><code class="language-sh"># IP Address
172.16.254.1
10101100.00010000.11111110.00000001
</code></pre>
<p>习惯上，我们用分成四段的十进制数表示IP地址，从0.0.0.0一直到255.255.255.255。</p>
<p>互联网上的每一台计算机，都会分配到一个IP地址。这个地址分成两个部分，前一部分代表网络，后一部分代表主机。比如，IP地址172.16.254.1，这是一个32位的地址，假定它的网络部分是前24位（172.16.254），那么主机部分就是后8位（最后的那个1）。处于同一个子网络的电脑，它们IP地址的网络部分必定是相同的，也就是说172.16.254.2应该与172.16.254.1处在同一个子网络。</p>
<p>但是，问题在于单单从IP地址，我们无法判断网络部分。还是以172.16.254.1为例，它的网络部分，到底是前24位，还是前16位，甚至前28位，从IP地址上是看不出来的。</p>
<p>那么，怎样才能从IP地址，判断两台计算机是否属于同一个子网络呢？这就要用到另一个参数&quot;子网掩码&quot;（subnet mask）。</p>
<p><strong>子网掩码</strong></p>
<p>所谓&quot;子网掩码&quot;，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.254.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。</p>
<p>知道&quot;子网掩码&quot;，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。</p>
<p>比如，已知IP地址172.16.254.1和172.16.254.233的子网掩码都是255.255.255.0，请问它们是否在同一个子网络？两者与子网掩码分别进行AND运算，结果都是172.16.254.0，因此它们在同一个子网络。</p>
<p><strong>IP数据包</strong></p>
<p>根据IP协议发送的数据，就叫做IP数据包。不难想象，其中必定包括IP地址信息。</p>
<p>IP数据包直接放进以太网数据包的&quot;数据&quot;部分</p>
<p>具体来说，IP数据包也分为&quot;标头&quot;和&quot;数据&quot;两个部分。</p>
<p>&quot;标头&quot;部分主要包括版本、长度、IP地址等信息，&quot;数据&quot;部分则是IP数据包的具体内容。</p>
<p>IP数据包的&quot;标头&quot;部分的长度为20到60字节，整个数据包的总长度最大为65,535字节。因此，理论上，一个IP数据包的&quot;数据&quot;部分，最长为65,515字节。前面说过，以太网数据包的&quot;数据&quot;部分，最长只有1500字节。因此，如果IP数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送了。</p>
<h4 id="214传输层">2.1.4传输层</h4>
<p><u>建立&quot;端口到端口&quot;的通信。</u></p>
<p>有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。</p>
<p>接下来的问题是，同一台主机上有许多程序都需要用到网络，比如，你一边浏览网页，一边与朋友在线聊天。当一个数据包从互联网上发来的时候，你怎么知道，它是表示网页的内容，还是表示在线聊天的内容？</p>
<p>也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做&quot;端口&quot;（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。</p>
<p>&quot;端口&quot;是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。</p>
<p><strong>UDP协议</strong></p>
<p>现在，我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，它的格式几乎就是在数据前面，加上端口号。</p>
<p>UDP数据包，也是由&quot;标头&quot;和&quot;数据&quot;两部分组成。</p>
<p>标头&quot;部分主要定义了发出端口和接收端口，&quot;数据&quot;部分就是具体的内容。</p>
<p>整个UDP数据包放入IP数据包的&quot;数据&quot;部分</p>
<p>UDP数据包非常简单，&quot;标头&quot;部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包。</p>
<p><strong>TCP协议</strong></p>
<p>UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。</p>
<p>为了解决这个问题，提高网络可靠性，TCP协议就诞生了。这个协议非常复杂，但可以近似认为，它就是有确认机制的UDP协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。</p>
<p>因此，TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。</p>
<p>TCP数据包和UDP数据包一样，都是内嵌在IP数据包的&quot;数据&quot;部分。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。</p>
<h4 id="215应用层">2.1.5应用层</h4>
<p><u>规定应用程序的数据格式。</u></p>
<p>应用程序收到&quot;传输层&quot;的数据，接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。</p>
<p>举例来说，TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了&quot;应用层&quot;。</p>
<p>这是最高的一层，直接面对用户。它的数据就放在TCP数据包的&quot;数据&quot;部分。</p>
<h2 id="3tcpip通信传输流">3.TCP/IP通信传输流</h2>
<p>利用 TCP/IP 协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则往应用层往上走。</p>
<p>我们用 HTTP 举例来说明，首先作为发送端的客户端在应用层（HTTP 协议）发出一个想看某个 Web 页面的 HTTP 请求。</p>
<p>接着，为了传输方便，在传输层（TCP 协议）把从应用层处收到的数据（HTTP 请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。</p>
<p>在网络层（IP 协议），增加作为通信目的地的 MAC 地址后转发给链路层。这样一来，发往网络的通信请求就准备齐全了。</p>
<p>接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接收到由客户端发送过来的 HTTP请求。</p>
<figure data-type="image" tabindex="3"><img src="https://leecss.com/post-images/1625528569737.jpg" alt="" loading="lazy"></figure>
<p>发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。</p>
<p>这种把数据信息包装起来的做法称为封装（encapsulate）。</p>
<h2 id="推荐阅读">推荐阅读</h2>
<blockquote>
<p>阮一峰</p>
<p><a href="https://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html">互联网协议1</a></p>
<p><a href="https://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html">互联网协议2</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git命令总结]]></title>
        <id>https://leecss.com/post/git-ming-ling-zong-jie/</id>
        <link href="https://leecss.com/post/git-ming-ling-zong-jie/">
        </link>
        <updated>2021-07-04T08:37:45.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>命令加思维导图</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>命令加思维导图</p>
<!-- more -->
<h2 id="新建代码库">新建代码库</h2>
<pre><code class="language-bash"># 在当前目录新建一个Git代码库
$ git init

# 新建一个目录，将其初始化为Git代码库
$ git init [project-name]

# 下载一个项目和它的整个代码历史
$ git clone [url]
</code></pre>
<h2 id="配置">配置</h2>
<p>Git的设置文件为<code>.gitconfig</code>，它可以在用户主目录下，也可以在项目目录下。</p>
<pre><code class="language-bash"># 显示当前的Git配置
$ git config --list

# 编辑Git配置文件
$ git config -e [--global]

# 设置提交代码时的用户信息
$ git config [--global] user.name &quot;[name]&quot;
$ git config [--global] user.email &quot;[email address]&quot;
</code></pre>
<h2 id="增加删除文件">增加/删除文件</h2>
<pre><code class="language-bash"># 添加指定文件到暂存区
$ git add [file1] [file2] ...

# 添加指定目录到暂存区，包括子目录
$ git add [dir]

# 添加当前目录的所有文件到暂存区
$ git add .

# 删除工作区文件，并且将这次删除放入暂存区
$ git rm [file1] [file2] ...

# 停止追踪指定文件，但该文件会保留在工作区
$ git rm --cached [file]

# 改名文件，并且将这个改名放入暂存区
$ git mv [file-original] [file-renamed]
</code></pre>
<h2 id="代码提交">代码提交</h2>
<pre><code class="language-bash"># 提交暂存区到仓库区
$ git commit -m [message]

# 提交暂存区的指定文件到仓库区
$ git commit [file1] [file2] ... -m [message]

# 提交工作区自上次commit之后的变化，直接到仓库区
$ git commit -a

# 提交时显示所有diff信息
$ git commit -v

# 使用一次新的commit，替代上一次提交
# 如果代码没有任何新变化，则用来改写上一次commit的提交信息
$ git commit --amend -m [message]

# 重做上一次commit，并包括指定文件的新变化
$ git commit --amend &lt;file1&gt; &lt;file2&gt; ...
</code></pre>
<h2 id="分支">分支</h2>
<pre><code class="language-bash"># 列出所有本地分支
$ git branch

# 列出所有远程分支
$ git branch -r

# 列出所有本地分支和远程分支
$ git branch -a

# 新建一个分支，但依然停留在当前分支
$ git branch [branch-name]

# 新建一个分支，并切换到该分支
$ git checkout -b [branch]

# 新建一个分支，指向指定commit
$ git branch [branch] [commit]

# 新建一个分支，与指定的远程分支建立追踪关系
$ git branch --track [branch] [remote-branch]

# 切换到指定分支，并更新工作区
$ git checkout [branch-name]

# 建立追踪关系，在现有分支与指定的远程分支之间
$ git branch --set-upstream [branch] [remote-branch]

# 合并指定分支到当前分支
$ git merge [branch]

# 选择一个commit，合并进当前分支
$ git cherry-pick [commit]

# 删除分支
$ git branch -d [branch-name]

# 删除远程分支
$ git push origin --delete &lt;branch-name&gt;
$ git branch -dr &lt;remote/branch&gt;
</code></pre>
<h2 id="标签">标签</h2>
<pre><code class="language-bash"># 列出所有tag
$ git tag

# 新建一个tag在当前commit
$ git tag [tag]

# 新建一个tag在指定commit
$ git tag [tag] [commit]

# 查看tag信息
$ git show [tag]

# 提交指定tag
$ git push [remote] [tag]

# 提交所有tag
$ git push [remote] --tags

# 新建一个分支，指向某个tag
$ git checkout -b [branch] [tag]
</code></pre>
<h2 id="查看信息">查看信息</h2>
<pre><code class="language-bash"># 显示有变更的文件
$ git status

# 显示当前分支的版本历史
$ git log

# 显示commit历史，以及每次commit发生变更的文件
$ git log --stat

# 显示某个文件的版本历史，包括文件改名
$ git log --follow [file]
$ git whatchanged [file]

# 显示指定文件相关的每一次diff
$ git log -p [file]

# 显示指定文件是什么人在什么时间修改过
$ git blame [file]

# 显示暂存区和工作区的差异
$ git diff

# 显示暂存区和上一个commit的差异
$ git diff --cached [&lt;file&gt;]

# 显示工作区与当前分支最新commit之间的差异
$ git diff HEAD

# 显示两次提交之间的差异
$ git diff [first-branch]...[second-branch]

# 显示某次提交的元数据和内容变化
$ git show [commit]

# 显示某次提交发生变化的文件
$ git show --name-only [commit]

# 显示某次提交时，某个文件的内容
$ git show [commit]:[filename]

# 显示当前分支的最近几次提交
$ git reflog
</code></pre>
<h2 id="远程同步">远程同步</h2>
<pre><code class="language-bash"># 下载远程仓库的所有变动
$ git fetch [remote]

# 显示所有远程仓库
$ git remote -v

# 显示某个远程仓库的信息
$ git remote show [remote]

# 增加一个新的远程仓库，并命名
$ git remote add [shortname] [url]

# 取回远程仓库的变化，并与本地分支合并
$ git pull [remote] [branch]

# 上传本地指定分支到远程仓库
$ git push [remote] [branch]

# 强行推送当前分支到远程仓库，即使有冲突
$ git push [remote] --force

# 推送所有分支到远程仓库
$ git push [remote] --all
</code></pre>
<h2 id="撤销">撤销</h2>
<pre><code class="language-bash"># 恢复暂存区的指定文件到工作区
$ git checkout [file]

# 恢复某个commit的指定文件到工作区
$ git checkout [commit] [file]

# 恢复上一个commit的所有文件到工作区
$ git checkout .

# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变
$ git reset [file]

# 重置暂存区与工作区，与上一次commit保持一致
$ git reset --hard

# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变
$ git reset [commit]

# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致
$ git reset --hard [commit]

# 重置当前HEAD为指定commit，但保持暂存区和工作区不变
$ git reset --keep [commit]

# 新建一个commit，用来撤销指定commit
# 后者的所有变化都将被前者抵消，并且应用到当前分支
$ git revert [commit]
</code></pre>
<h2 id="其他">其他</h2>
<pre><code class="language-bash"># 生成一个可供发布的压缩包
# git archive
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://leecss.com/post-images/1625387910788.jpg" alt="" loading="lazy"></figure>
<h2 id="转载">转载</h2>
<blockquote>
<p>先抄一下阮老师的文章和腾讯的图</p>
<p>以后有时间再整理</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git-实用场景]]></title>
        <id>https://leecss.com/post/git-shi-yong-chang-jing/</id>
        <link href="https://leecss.com/post/git-shi-yong-chang-jing/">
        </link>
        <updated>2021-07-04T08:23:50.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>一些工作中会用到的知识点</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>一些工作中会用到的知识点</p>
<!-- more -->
<h2 id="正常操作流程">正常操作流程</h2>
<pre><code class="language-sh">git add .
git commit -m &quot;提交描述&quot;
git pull
git push
</code></pre>
<p>上述操作流程是经常会使用的操作，为什么pull之前要先提交commit？</p>
<p>分两步理解</p>
<p>第一步是<code>git add &amp; git commit</code>，这是你本地仓库的操作记录</p>
<p>第二步是<code>git pull &amp; git push</code>，这是本地仓库和远程仓库的交互与同步。</p>
<p>假如你本地没有修改文件，可以直接进行第二步，随时和远程仓库进行同步。</p>
<p>假如你本地有修改文件，需要先将本地代码保存起来，做一次提交，这样在和远程交互的时候，才能对比操作。</p>
<p>否则本地修改文件会被覆盖丢失。</p>
<h2 id="合并代码">合并代码</h2>
<p>当开发完成一个迭代后，需要发布上线，此时需要将dev分支的代码合并到master</p>
<pre><code class="language-sh">git switch master
git pull origin dev
git push
</code></pre>
<h2 id="暂存代码">暂存代码</h2>
<p>当你需要去合并分支的时候，假如你dev分支上有未完成的工作，此时是不能切换分支的。</p>
<p>但是因为工作还没有完成，你不想提交到远程，那么就可以将代码先暂存起来。</p>
<pre><code class="language-sh">git stash

git switch master
git pull origin dev
git push

git switch dev
git stash pop
</code></pre>
<h2 id="修复线上bug">修复线上bug</h2>
<p>此时已经发布上线了，但是发现线上有一个bug需要紧急处理，应该怎么做？</p>
<pre><code class="language-sh">// 从master分支检出bugfix分支
git switch master
git switch -c bugfix
// 修复bug,提交到仓库
git add .
git commit -m 'fix bug x'
// 切换到master,合并bugfix分支并删除
git switch master
git merge --no-ff -m &quot;merged bugfix x&quot; bugfix
git branch -d fixbug
</code></pre>
<p>假如你没有检出bug分支，直接在dev分支上开发的</p>
<pre><code class="language-sh">// 修复bug,提交到仓库
git add .
git commit -m 'fix bug x'
// 拉取远程更新,并推送
git pull --rebase
git push
// 此时发现另外一名同事已经提交了一些东西，但是这些没经过验证不可以发到线上
// 查看提交记录，记录下你刚刚提交的commitId，假设为c0
git log --oneline
// 切换到master
git cherry-pick [刚刚提交的commitID]
git cherry-pick c0
// 提交
git pull
git push
</code></pre>
<h2 id="版本回退">版本回退</h2>
<pre><code class="language-sh">// 查看提交记录
git log --oneline
// 以上次提交举例HEAD~，实际以具体commitID
git reset --hard [commitid]
git reset --hard HEAD~
// 强行推送到远程
git push -f
</code></pre>
<h2 id="切换工作区内容">切换工作区内容</h2>
<pre><code class="language-sh">git show-branch
</code></pre>
<pre><code class="language-sh">// 指定快照
git restore --source [commitID] .
// 工作区切换到最新提交
git restore --source HEAD .
</code></pre>
<h2 id="git命令行反应慢">git命令行反应慢</h2>
<p>1、删除本地无用的分支</p>
<p>2、使用git log时，不要加<code>--graph</code>参数</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git-clean]]></title>
        <id>https://leecss.com/post/git-clean/</id>
        <link href="https://leecss.com/post/git-clean/">
        </link>
        <updated>2021-07-04T03:21:45.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p><code>git clean</code>从你的工作区中删除所有没有 tracked，没有被管理过的文件。</p>
<p>作用是让使工作区回到一个干净的状态(一个指定的commit状态)</p>
<p>git clean 和 git reset --hard 结合使用。</p>
<p>clean 影响没有被 track 过的文件（清除未被 add 或被 commit 的本地修改）</p>
<p>reset 影响被 track 过的文件 （回退到上一个 commit）</p>
<p>说到这里，我不禁想起了restore。两者结合不就是restore吗？</p>
<h2 id="命令">命令</h2>
<p>查看可使用<code>git clean</code>命令清除的文件</p>
<pre><code class="language-sh">git clean -n
</code></pre>
<p>删除当前目录下所有没有 track 过的文件</p>
<p>不会删除 <code>.gitignore</code> 文件里面指定的文件夹和文件, 不管这些文件有没有被 track 过</p>
<pre><code class="language-sh">git clean -f
</code></pre>
<p>删除指定路径下的没有被 track 过的文件</p>
<pre><code class="language-sh">git clean -f &lt;path&gt;
</code></pre>
<p>删除当前目录下没有被 track 过的文件和文件夹</p>
<pre><code class="language-sh">git clean -df
</code></pre>
<p>删除当前目录下所有没有 track 过的文件</p>
<p>不管是否是 <code>.gitignore</code>文件里面指定的文件夹和文件</p>
<pre><code class="language-sh">git clean -xf
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git-show]]></title>
        <id>https://leecss.com/post/git-show/</id>
        <link href="https://leecss.com/post/git-show/">
        </link>
        <updated>2021-07-04T02:54:11.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p><code>git show</code>命令用于查看commit的内容</p>
<h2 id="命令">命令</h2>
<pre><code class="language-sh"># 输出某次提交的元数据和内容变化
$ git show [commit]
$ git show 12a86bc38 # By revision
$ git show v1.0.1 # By tag
$ git show feature132 # By branch name
$ git show 12a86bc38^ # Parent of a commit
$ git show 12a86bc38~2 # Grandparent of a commit
$ git show feature132@{yesterday} # Time relative
$ git show feature132@{2.hours.ago} # Time relative
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git-show-branch]]></title>
        <id>https://leecss.com/post/git-show-branch/</id>
        <link href="https://leecss.com/post/git-show-branch/">
        </link>
        <updated>2021-07-04T01:22:22.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>查看分支及其历史提交记录</p>
<h2 id="命令">命令</h2>
<p>查看本地分支</p>
<pre><code class="language-sh">git show-branch
</code></pre>
<p>查看远程分支</p>
<pre><code class="language-sh">git show-branch -r
</code></pre>
<p>查看所有分支</p>
<pre><code class="language-sh">git show-branch -a
</code></pre>
<h2 id="解析">解析</h2>
<p>1、输出分为上下两部分，使用若干个短划线<code>-</code>分隔。两个分支使用两个短划线<code>--</code>，三个分支使用三个短划线<code>---</code>，依次类推。</p>
<p>2、上半部分为层次缩进的分支列表，下半部分为commit列表。</p>
<p>3、上半部分的分支列表中，使用<code>*</code>标识当前分支，使用<code>!</code>标识其他分支（不同的分支！标识颜色不一样）。</p>
<p>分支前的标识符<code>*</code>或者<code>!</code>一直垂直贯通到下半部分，这一列完全相同的符号代表的commit都是属于这个分支的。</p>
<p>4、下半部分的commit列表中，前导的符号有<code>*</code>和<code>+</code>号。</p>
<p><code>*</code>表示当前分支上有此commit。</p>
<p><code>+</code>表示此颜色代表的分支上有此commit。</p>
<p>5、标识符的颜色只是用于容易区分列，一个分支一个颜色。</p>
<figure data-type="image" tabindex="1"><img src="https://leecss.com/post-images/1625361802965.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git-鼠标右键手动添加git-bash]]></title>
        <id>https://leecss.com/post/git-shu-biao-you-jian-shou-dong-tian-jia-git-bash/</id>
        <link href="https://leecss.com/post/git-shu-biao-you-jian-shou-dong-tian-jia-git-bash/">
        </link>
        <updated>2021-07-04T01:04:12.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>鼠标右键没有git bash的解决办法</p>
<h2 id="操作">操作</h2>
<p>1、打开注册表</p>
<blockquote>
<p><code>win+r</code>,输入<code>regedit</code></p>
</blockquote>
<p>2、找到shell目录</p>
<blockquote>
<p>路径为：计算机\HKEY_CLASSES_ROOT\Directory\Background\shell</p>
<p>如果Background目录下没有shell文件夹就新建shell文件夹。</p>
</blockquote>
<p>3、在shell目录上右键-新建-项，命名bash</p>
<p>4、点击新建的Bash 右侧出现默认，点击默认，设置值为Open in Bash</p>
<p>5、在bash目录上右键-新建-项，命名command</p>
<p>6、点击commond，右侧出现默认，点击默认，修改值为你的git-bash路径</p>
<blockquote>
<p>以我的举例</p>
<p>D:\software\git\Git\git-bash.exe</p>
</blockquote>
<p>7、保存关闭注册表，在任意目录鼠标右键测试</p>
]]></content>
    </entry>
</feed>