<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://leecss.com</id>
    <title>当下</title>
    <updated>2021-06-23T00:06:50.506Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://leecss.com"/>
    <link rel="self" href="https://leecss.com/atom.xml"/>
    <logo>https://leecss.com/images/avatar.png</logo>
    <icon>https://leecss.com/favicon.ico</icon>
    <rights>All rights reserved 2021, 当下</rights>
    <entry>
        <title type="html"><![CDATA[git-describe]]></title>
        <id>https://leecss.com/post/git-describe/</id>
        <link href="https://leecss.com/post/git-describe/">
        </link>
        <updated>2021-06-23T00:05:00.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>由于标签在代码库中起着“锚点”的作用，Git 还为此专门设计了一个命令用来<strong>描述</strong>离你最近的锚点（也就是标签），它就是 <code>git describe</code>！</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>由于标签在代码库中起着“锚点”的作用，Git 还为此专门设计了一个命令用来<strong>描述</strong>离你最近的锚点（也就是标签），它就是 <code>git describe</code>！</p>
<!-- more -->
<pre><code class="language-sh">git describe &lt;ref&gt;
git describe &lt;branch&gt;
</code></pre>
<p><code>&lt;ref&gt;</code> 可以是任何能被 Git 识别成提交记录的引用，如果你没有指定的话，Git 会以你目前所检出的位置（<code>HEAD</code>）。</p>
<p>它输出的结果是这样的：</p>
<pre><code class="language-sh">&lt;tag&gt;_&lt;numCommits&gt;_g&lt;hash&gt;
</code></pre>
<p><code>tag</code> 表示的是离 <code>ref</code> 最近的标签， <code>numCommits</code> 是表示这个 <code>ref</code> 与 <code>tag</code> 相差有多少个提交记录， <code>hash</code> 表示的是你所给定的 <code>ref</code> 所表示的提交记录哈希值的前几位。</p>
<p>当 <code>ref</code> 提交记录上有某个标签时，则只输出标签名称</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git-tag]]></title>
        <id>https://leecss.com/post/git-tag/</id>
        <link href="https://leecss.com/post/git-tag/">
        </link>
        <updated>2021-06-23T00:04:06.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>有没有什么可以<em>永远</em>指向某个提交记录的标识呢，比如软件发布新的大版本，或者是修正一些重要的 Bug 或是增加了某些新特性？</p>
<p>当然有了！Git 的 tag 就是干这个用的啊，它们可以（在某种程度上 —— 因为标签可以被删除后重新在另外一个位置创建同名的标签）永久地将某个特定的提交命名为里程碑，然后就可以像分支一样引用了。</p>
<p>更难得的是，它们并不会随着新的提交而移动。你也不能检出到某个标签上面进行修改提交，它就像是提交树上的一个锚点，标识了某个特定的位置。</p>
<h2 id="命令">命令</h2>
<h3 id="打标签">打标签</h3>
<p>建立一个标签，指向提交记录C1</p>
<pre><code class="language-sh">git tag v1 C1
</code></pre>
<p>如果你不指定提交记录，Git 会用 <code>HEAD</code> 所指向的位置。</p>
<pre><code class="language-sh">git tag v1
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git-cherry-pick]]></title>
        <id>https://leecss.com/post/git-cherry-pick/</id>
        <link href="https://leecss.com/post/git-cherry-pick/">
        </link>
        <updated>2021-06-22T00:13:27.000Z</updated>
        <summary type="html"><![CDATA[<p><code>git cherry-pick</code>命令”复制”一个提交节点并在当前分支做一次完全一样的新提交。</p>
]]></summary>
        <content type="html"><![CDATA[<p><code>git cherry-pick</code>命令”复制”一个提交节点并在当前分支做一次完全一样的新提交。</p>
<!-- more -->
<pre><code class="language-sh">git cherry-pick commitID
git cherry-pick c2 c4
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git-revert]]></title>
        <id>https://leecss.com/post/git-revert/</id>
        <link href="https://leecss.com/post/git-revert/">
        </link>
        <updated>2021-06-21T23:38:48.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="概述">概述</h2>
<p><code>git revert</code>命令用于撤销某个具体的commit。</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p><code>git revert</code>命令用于撤销某个具体的commit。</p>
<!-- more -->
<pre><code class="language-sh">git revert &lt;commitID&gt;
</code></pre>
<p>撤销上一个commit,之后推送到远程</p>
<pre><code class="language-sh">git revert HEAD
</code></pre>
<h2 id="revert和reset的区别">revert和reset的区别</h2>
<p>reset（重置）：将版本回退到某个commit</p>
<p>恢复（revert）:  回滚某个具体的commit,将它撤销</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git-reset]]></title>
        <id>https://leecss.com/post/git-reset/</id>
        <link href="https://leecss.com/post/git-reset/">
        </link>
        <updated>2021-06-21T23:37:30.000Z</updated>
        <content type="html"><![CDATA[<h2 id="撤销区域">撤销区域</h2>
<h3 id="暂存区">暂存区</h3>
<p>撤销已经添加到暂存区中的修改，即让暂存区与最近的提交保持一致，可以使用如下命令，如下三条命令等效</p>
<pre><code class="language-sh">git reset
git reset HEAD
git reset --mixed HEAD
</code></pre>
<p>撤销上一次向暂存区添加的某个指定文件，不影响工作区中的该文件</p>
<pre><code class="language-sh">git reset -- &lt;filename&gt;
git reset -- file1 file2
</code></pre>
<h3 id="暂存区和工作区">暂存区和工作区</h3>
<p>撤销所有暂存区和工作区中的所有变更,回复到上一次提交的状态</p>
<pre><code class="language-sh">git reset --hard
</code></pre>
<p>回退到指定的提交</p>
<pre><code class="language-sh">git reset --hard commitID
</code></pre>
<h2 id="参数">参数</h2>
<ul>
<li>soft: 不改变工作区和缓存区，只移动 HEAD 到指定 commit。</li>
<li>mixed: 只改变缓存区，不改变工作区。这是默认参数，通常用于撤销<code>git add</code>。</li>
<li>hard：改变工作区和暂存区到指定 commit。该参数等同于重置，可能会引起数据损失。<code>git reset --hard</code>等同于<code>git reset --hard HEAD</code>。</li>
<li><code>-p</code>表示键入交互模式，指定暂存区的哪些部分需要撤销。</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>工作区</th>
<th>缓存区</th>
<th>HEAD</th>
</tr>
</thead>
<tbody>
<tr>
<td>–soft</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>–mixed</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>–hard</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
</tbody>
</table>
<pre><code class="language-shell">// 将当期分支的指针倒退一个 commit，只改变仓库
git reset --soft HEAD~
// 将当期分支的指针倒退一个 commit，改变仓库，并且会改变暂存区
git reset HEAD~
// 将当期分支的指针倒退一个 commit，改变仓库，暂存区，工作区
git reset --hard HEAD~
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git-相对引用]]></title>
        <id>https://leecss.com/post/git-xiang-dui-yin-yong/</id>
        <link href="https://leecss.com/post/git-xiang-dui-yin-yong/">
        </link>
        <updated>2021-06-20T02:53:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>通过哈希值指定提交记录很不方便，所以 Git 引入了相对引用。</p>
<p>使用相对引用的话，你就可以从一个易于记忆的地方（比如bugFix 分支或 HEAD）开始计算。</p>
<h2 id="分类">分类</h2>
<h3 id="操作符~">操作符~</h3>
<p>HEAD 表示当前分支的最新提交</p>
<p>HEAD~ 表示当前分支的最新提交的前一个提交（即最新的第二个提交，也就是最新提交的父提交）</p>
<p>HEAD~~ 表示当前分支的最新提交的前前提交（即最新的第三个提交，也就是最新提交的祖父提交）</p>
<p>HEAD~~~ 表示当前分支的最新提交的前前前提交（即最新的第四个提交，也就是最新提交的曾祖父提交）</p>
<blockquote>
<p>HEAD~~~等效于HEAD~3</p>
<p>HEAD~~等效于HEAD~2</p>
<p>HEAD<sub>等效于HEAD</sub>1</p>
<p>HEAD等效于HEAD~0</p>
</blockquote>
<h3 id="操作符">操作符^</h3>
<h4 id="单个直系父提交">单个直系父提交</h4>
<p>把这个符号加在引用名称的后面，表示让 Git 寻找指定提交记录的父提交。</p>
<p>方式一</p>
<p><code>main^</code> 相当于“<code>main</code> 的父节点”。</p>
<p><code>main^^</code> 是 <code>main</code> 的第二个父节点</p>
<p>方式二</p>
<p>我们也可以多次使用 <code>HEAD^</code> 向上移动。</p>
<pre><code class="language-sh">git checkout HEAD^
git checkout HEAD^
</code></pre>
<h4 id="多个直系父提交">多个直系父提交</h4>
<p>假如当前提交不只一个父节点，有多个直系父提交呢？</p>
<p>如果一个提交有多个父提交，那么 <code>~</code> 只会找第一个父提交。</p>
<p>使用<code>HEAD^2</code>来找到第二个父提交</p>
<pre><code class="language-sh">
G   H   I   J
 \ /     \ /
  D   E   F
   \  |  / \
    \ | /   |
     \|/    |
      B     C
       \   /
        \ /
         A
 
A =      = A^0
B = A^   = A^1     = A~1
C = A^2
D = A^^  = A^1^1   = A~2
E = B^2  = A^^2
F = B^3  = A^^3
G = A^^^ = A^1^1^1 = A~3
H = D^2  = B^^2    = A^^^2  = A~2^2
I = F^   = B^3^    = A^^3^
J = F^2  = B^3^2   = A^^3^2
</code></pre>
<h2 id="混合链式调用">混合链式调用</h2>
<pre><code class="language-sh">git checkout HEAD~^2~2
</code></pre>
<p>选择直系父节点的 第二个父节点的 直系第二个父节点</p>
<h2 id="应用">应用</h2>
<h3 id="强制修改分支位置">强制修改分支位置</h3>
<p>使用相对引用最多的就是移动分支。可以直接使用 <code>-f</code> 选项让分支指向另一个提交。例如:</p>
<pre><code class="language-shell">git branch -f main HEAD~3
git branch -f dev c2
</code></pre>
<p>相对引用为我们提供了一种简洁的引用提交记录 的方式， 而 <code>-f</code> 则容许我们将分支强制移动到那个位置。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git-reference(指针)]]></title>
        <id>https://leecss.com/post/git-referencezhi-zhen/</id>
        <link href="https://leecss.com/post/git-referencezhi-zhen/">
        </link>
        <updated>2021-06-19T15:28:49.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>所谓指针（reference），只是一个链接，用来指向其他物体，方便引用。Git有三种指针，但是所有指针归根结底都是指向某个commit。</p>
<h2 id="分类">分类</h2>
<h3 id="head指针">HEAD指针</h3>
<p>头指针：指向目前所在的Branch，用来区分目前在哪个分支。</p>
<p>查看HEAD 指向</p>
<pre><code class="language-sh">cat .git/HEAD
</code></pre>
<p>结果：ref: refs/heads/master</p>
<p>可以看出HEAD指针指向的是refs/heads/master文件，即master分支</p>
<hr>
<p>如果 HEAD 指向的是一个引用,可以通过以下命令查看它的指向</p>
<pre><code class="language-sh">git symbolic-ref HEAD
</code></pre>
<h3 id="branch指针">Branch指针</h3>
<p>分支指针：指向某个commit。每次该分支有新的commit，指针就会变动，指向当前分支的最新提交。</p>
<p>当我们从master新建一个test分支时，git只会创建一个test分支指针，并且让test分支指针指向master分支对应的最新的提交。</p>
<p>查看master分支文件的内容</p>
<pre><code class="language-sh">cat .git/refs/heads/master
</code></pre>
<p>可以看到，这个文件的内容是一串哈希码，而这个哈希码正是master分支上最新的提交所对应的哈希码。</p>
<h2 id="分离头">分离头</h2>
<p>通常情况下，HEAD指针总是通过分支指针，间接的指向了当前分支的最新提交。</p>
<p>不通常的情况便是分离头（detached HEAD）：就是头指针和分支指针分开了，HEAD指针没有指向分支指针，而是直接指向了某个提交。</p>
<p>我们随便检出到某个提交，都可以进入分离头状态</p>
<pre><code>git checkout cbd3348
</code></pre>
<p><strong>分离头的应用</strong></p>
<p>由于刚才我们直接检出了’cbd3348’这个提交，所以，我们处于分离头状态，而且当前仓库中各个文件的内容也回到了’cbd3348’这个提交对应的状态。此时创建了两个新提交，这两个新提交与分叉点之前的提交组成了一条匿名分支，没有任何一个分支标签指向这个匿名分支。我们现在有两个选择，如下：</p>
<p>选择一：丢弃这个匿名分支</p>
<blockquote>
<p>直接检出到任何一个别的分支，就相当于放弃了这些提交</p>
</blockquote>
<p>选择二：保留这个匿名分支</p>
<blockquote>
<p>只需要将这些提交创建成一条新的分支就行了</p>
</blockquote>
<pre><code class="language-sh">git checkout -b newtest
</code></pre>
<pre><code class="language-sh">git branch newtest dca15df
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git-rebase]]></title>
        <id>https://leecss.com/post/git-rebase/</id>
        <link href="https://leecss.com/post/git-rebase/">
        </link>
        <updated>2021-06-17T03:43:53.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>将当前分支移植到指定分支或指定commit之上。</p>
<p>Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。</p>
<p>Rebase 的优势就是可以创造更线性的提交历史，这听上去有些难以理解。如果只允许使用 Rebase 的话，代码库的提交历史将会变得异常清晰。</p>
<pre><code class="language-sh">git rebase master
git rebase c2
</code></pre>
<p>将当前分支移植到master分支或c2提交记录之上。</p>
<h2 id="交互式">交互式</h2>
<h3 id="-iinteractive">-i，—interactive</h3>
<p><code>-i</code>参数会打开互动模式，让用户选择定制<code>rebase</code>的行为。</p>
<pre><code class="language-sh">git rebase -i HEAD~4
</code></pre>
<h3 id="功能">功能</h3>
<ul>
<li>调整提交记录的顺序（通过鼠标拖放来完成）</li>
<li>删除你不想要的提交（通过切换 <code>pick</code> 的状态来完成，关闭就意味着你不想要这个提交记录）</li>
<li>合并提交。</li>
</ul>
<h2 id="多次rebase">多次rebase</h2>
<p>当你想将多个分支合成一条线性的提交记录时，按照提交顺序切换相应的分支，然后rebase到相应顺序节点的分支</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git-merge]]></title>
        <id>https://leecss.com/post/git-merge/</id>
        <link href="https://leecss.com/post/git-merge/">
        </link>
        <updated>2021-06-17T03:36:56.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p><code>git merge</code>命令用于合并指定分支到当前分支</p>
<p>将develop分支合并到当前分支，当前分支会创建新的commit对象，它有两个父节点，分别指向当前分支和develop分支。</p>
<pre><code class="language-sh">git merge develop
</code></pre>
<h2 id="合并方式">合并方式</h2>
<h3 id="普通方式">普通方式</h3>
<p>假如此时在C1节点master分支上，创建了一个新的分支dev,然后在master分支创建新的提交C2,在dev分支上创建新的提交C3。</p>
<p><strong>如果合并分支之前，master分支和dev分支都有了属于自己分支的独有提交，此时只能使用普通方式进行合并。</strong></p>
<p>此时可以将master合并到dev,也可以将dev合并到master</p>
<p>以dev合并到master为例：</p>
<p>在maser分支执行<code>git merge dev</code>，会有新的变更进入到master，新变更进入后，base分支的内容会产生变化，因此master分支需要一个新的提交来对应变化后的状态，于是，master分支的指针会指向最新产生的合并提交。</p>
<p>而对于dev分支来说，并没有任何内容发生变动，所以dev分支的指针仍然保持原位。</p>
<h3 id="fast-forward快进">fast-forward（快进）</h3>
<p>假如此时在C1节点master分支上，创建了一个新的分支dev,然后在dev分支上创建新的提交C2。</p>
<p><strong>如果合并分支之前，master分支和dev分支中只有一个分支创建了属于自己分支的独有提交，此时可以使用fast-forward进行合并。</strong></p>
<p>由于基于maste分支创建dev分支以后，master分支中并没有产生任何新的提交，如果此时想要将dev分支合并到master分支，只需要将master分支的指针指向到dev分支的最新提交，即可让master分支包含dev分支中的所有新变更。即：</p>
<p><u>如果“指定分支”本身是当前分支的一个直接子节点，则会产生fast-forward合并，即合并不会产生新的节点，只是让当前分支指向“指定分支”的最新commit。</u></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git-commit]]></title>
        <id>https://leecss.com/post/git-commit/</id>
        <link href="https://leecss.com/post/git-commit/">
        </link>
        <updated>2021-06-17T03:29:39.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p><code>git commit</code>命令用于将暂存区中的变化提交到仓库区。</p>
<p><code>-m</code>参数用于指定 commit 信息，是必需的。如果省略<code>-m</code>参数，<code>git commit</code>会自动打开文本编辑器，要求输入。</p>
<pre><code class="language-sh">git commit -m &quot;message&quot;
</code></pre>
<h2 id="命令行参数">命令行参数</h2>
<h3 id="-a">-a</h3>
<p><code>-a</code>参数用于先将所有工作区的变动文件，提交到暂存区，再运行<code>git commit</code>。</p>
<pre><code class="language-sh">git commit -am &quot;message&quot;
</code></pre>
<blockquote>
<p>用了<code>-a</code>参数，是不是就不用执行<code>git add .</code>命令了？不是。</p>
<p><code>-m</code>参数用于提交暂存区的文件</p>
<p><code>-a</code>参数用于提交追踪过的文件</p>
<p>文件状态按已追踪和未追踪区分，新增的文件为未追踪，<code>git add</code>后的文件为已追踪</p>
<p>所以新增的文件还是要执行<code>git add .</code>命令</p>
</blockquote>
<h3 id="amend">—amend</h3>
<p><code>--amend</code>参数用于撤销上一次 commit，然后生成一个新的 commit。</p>
<pre><code class="language-sh">git commit --amend -m &quot;new commit message&quot;
</code></pre>
]]></content>
    </entry>
</feed>