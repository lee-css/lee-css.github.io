<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://leecss.com</id>
    <title>当下</title>
    <updated>2021-06-30T15:40:37.035Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://leecss.com"/>
    <link rel="self" href="https://leecss.com/atom.xml"/>
    <logo>https://leecss.com/images/avatar.png</logo>
    <icon>https://leecss.com/favicon.ico</icon>
    <rights>All rights reserved 2021, 当下</rights>
    <entry>
        <title type="html"><![CDATA[git-diff]]></title>
        <id>https://leecss.com/post/git-diff/</id>
        <link href="https://leecss.com/post/git-diff/">
        </link>
        <updated>2021-06-30T15:37:30.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p><code>git diff</code>命令用于查看文件之间的差异。</p>
<h2 id="命令">命令</h2>
<h3 id="工作区与暂存区">工作区与暂存区</h3>
<p>查看工作区与暂存区的差异</p>
<pre><code class="language-sh">git diff
</code></pre>
<p>查看工作区与暂存区某个文件的差异</p>
<pre><code class="language-sh">git diff [file]
git diff file.txt
// 或
git diff -- [file]
git diff -- ./[file]
</code></pre>
<p>查看工作区与暂存区多个文件的差异，以空格分隔</p>
<pre><code class="language-sh">git diff -- [file1] [file2]
</code></pre>
<p>查看工作区与暂存区目录下所有文件的差异</p>
<pre><code class="language-sh">git diff -- [dir]/
</code></pre>
<h3 id="工作区与commit快照">工作区与commit快照</h3>
<p>查看工作区与上一次commit之间的差异</p>
<pre><code class="language-sh">git diff HEAD
</code></pre>
<p>查看工作区与某个 commit 的差异</p>
<pre><code class="language-sh">git diff [commit]
</code></pre>
<hr>
<p>当我们修改工作区的内容后，我们没有暂存，也没有提交，所以此时暂存区和仓库的状态是相同的。</p>
<p>即此时<code>git diff</code> 与<code>git diff HEAD</code>返回的结果是完全相同的</p>
<hr>
<p>当我们执行<code>git add</code>命令后，此时<code>git diff</code>不会显示任何内容，因为此时工作区与暂存区没有差异。</p>
<p>但是如果执行<code>git diff HEAD</code>命令，仍然可以查看到工作区和提交之间的差异。</p>
<hr>
<p>假如此时再次修改工作区的内容，我们就能同时对比工作区和(暂存区/仓库)的差异</p>
<p>并且此时暂存区和仓库也是有差异的</p>
<h3 id="暂存区与仓库区">暂存区与仓库区</h3>
<p>查看暂存区与当前 commit 的差异</p>
<pre><code class="language-sh">git diff --cached
</code></pre>
<h3 id="对比两次提交">对比两次提交</h3>
<p>显示两次提交之间的差异</p>
<pre><code class="language-sh">git diff [first-commit] [second-commit]
</code></pre>
<p>我们也可以使用引用，更加方便的对比，比如：最新提交和上一次提交</p>
<pre><code class="language-sh">git diff HEAD HEAD~
</code></pre>
<h3 id="对比两个分支">对比两个分支</h3>
<p>即对比两个分支上最新提交之间的差异</p>
<pre><code class="language-sh">git diff [first-branch] [second-branch]
git diff master dev
// 等效于
git diff [first-branch]..[second-branch]
git diff maste..dev
</code></pre>
<p>查看自从topic分支建立以后，master分支发生的变化</p>
<pre><code class="language-sh">git diff topic...master
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git-reflog]]></title>
        <id>https://leecss.com/post/git-reflog/</id>
        <link href="https://leecss.com/post/git-reflog/">
        </link>
        <updated>2021-06-30T15:35:19.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>相当于版本控制的版本控制</p>
<p>git reflog 可以查看所有分支的所有操作记录</p>
<p>包括已经被删除的 commit 记录</p>
<h2 id="应用场景">应用场景</h2>
<p>分支误删除；</p>
<p>节点误回退</p>
<p>git rebase等等</p>
<p>我们都可以从git reflog中找到操作记录</p>
<p>这时，我们找到要恢复的commitID</p>
<p>执行以下命令即可</p>
<pre><code class="language-sh">git reset --hard [commitID]
</code></pre>
<p>假如说回退的节点之后，又添加了一些提交，可以配合使用cherry-pick</p>
<pre><code class="language-sh">git cherry-pick [commitID]
</code></pre>
<h2 id="与git-log的对比">与git log的对比</h2>
<h3 id="reflog">reflog</h3>
<p>reflog是一个本地结构，它记录了HEAD和分支引用在过去指向的位置，即HEAD指向的提交的有序列表。</p>
<p>reflog信息没法与其他任何人共享，每个人都是自己特有的reflog。</p>
<p>重要的一点是，它不是永久保存的，有一个可配置的过期时间，reflog中过期的信息会被自动删除。</p>
<h3 id="log">log</h3>
<p>git log显示当前HEAD及其祖先。</p>
<p>也就是说，它打印提交HEAD指向，然后它的父，其父，等等。</p>
<p>它通过递归查找每个提交的父进程遍历回购的祖先。</p>
<figure data-type="image" tabindex="1"><img src="https://leecss.com/post-images/1625067362274.gif" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://leecss.com/post-images/1625067370478.gif" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git-log]]></title>
        <id>https://leecss.com/post/git-log/</id>
        <link href="https://leecss.com/post/git-log/">
        </link>
        <updated>2021-06-29T23:17:47.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p><code>git log</code>命令按照提交时间从最晚到最早的顺序，列出所有 commit。</p>
<h2 id="命令">命令</h2>
<h3 id="当前分支全部历史">当前分支全部历史</h3>
<p>列出当前分支的版本历史</p>
<pre><code class="language-sh">git log
</code></pre>
<p><code>--oneline</code>参数让输出时，每个 commit 只占用一行。</p>
<pre><code class="language-sh">git log --oneline
</code></pre>
<h3 id="某文件版本历史">某文件版本历史</h3>
<p>列出某个文件的版本历史，包括文件改名</p>
<pre><code class="language-sh">git log --follow [file]
</code></pre>
<h3 id="分支变动历史">分支变动历史</h3>
<p>查看远程分支的变动情况。</p>
<pre><code class="language-sh">git log remote/branch
</code></pre>
<h3 id="搜索查找历史">搜索查找历史</h3>
<p>查找log，即搜索commit信息。</p>
<p><code>-i</code>参数表示搜索时忽略大小写。</p>
<pre><code>git log --author=Andy
git log -i --grep=&quot;Something in the message&quot;
</code></pre>
<h3 id="美化输出">美化输出</h3>
<ul>
<li>—graph commit之间将展示连线</li>
<li>—decorate 显示commit里面的分支</li>
<li>—pretty=oneline 只显示commit信息的标题</li>
<li>—abbrev-commit 只显示commit SHA1的前7位</li>
</ul>
<pre><code>git log --graph --decorate --pretty=oneline --abbrev-commit
</code></pre>
<h2 id="退出">退出</h2>
<p>按Q退出</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git-restore]]></title>
        <id>https://leecss.com/post/git-restore/</id>
        <link href="https://leecss.com/post/git-restore/">
        </link>
        <updated>2021-06-29T15:24:10.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>因为git checkout 命令职责较多、不够明确，所以git 2.23 版本新增了switch、restore命令</p>
<p>switch命令专门用来切换分支、创建并切换分支等</p>
<p>restore命令专门用来恢复(撤销)暂存区和工作区的文件</p>
<h2 id="命令">命令</h2>
<p>为了方便初步理解，先使用撤销</p>
<h3 id="撤销工作区文件的修改">撤销工作区文件的修改</h3>
<p>撤销工作区指定文件的修改 ，即从暂存区覆盖到工作区</p>
<p>--worktree为默认参数，可以省略</p>
<pre><code>git restore [--worktree] [file]
</code></pre>
<p>撤销工作区所有文件</p>
<pre><code class="language-sh">git restore .
</code></pre>
<h3 id="撤销暂存区文件的修改">撤销暂存区文件的修改</h3>
<p>撤销暂存区指定文件的修改，即从仓库覆盖到暂存区。但是被撤销的文件不会更改，会恢复到工作区。</p>
<pre><code class="language-sh">git restore --staged [file]
</code></pre>
<p>撤销暂存区所有文件</p>
<pre><code class="language-sh">git restore --staged .
</code></pre>
<h3 id="撤销工作区和暂存区文件的修改">撤销工作区和暂存区文件的修改</h3>
<p>撤销工作区和暂存区文件的修改，即从仓库到暂存区和工作区</p>
<pre><code class="language-sh">git restore --staged --worktree [file]
</code></pre>
<h3 id="切换工作区内容">切换工作区内容</h3>
<p>将工作区内容切换到某个快照</p>
<pre><code class="language-sh">git restore --source [commitID]
// 工作区切换到上次提交
git restore --source HEAD~
</code></pre>
<h2 id="参数详解">参数详解</h2>
<p>进一步理解，使用恢复</p>
<p>恢复一个文件，从哪里到哪里</p>
<p>--source 来源地，即从哪里</p>
<p>--staged 目的地，即到哪里(暂存区)</p>
<p>--worktree 目的地，即到哪里(工作区)</p>
<p>举例说明：假如把readme.md从上次提交同时恢复到暂存区和工作区</p>
<pre><code class="language-sh">git restore --source HEAD~ --staged --worktree readme.md
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://leecss.com/post-images/1624980286919.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git-switch]]></title>
        <id>https://leecss.com/post/git-switch/</id>
        <link href="https://leecss.com/post/git-switch/">
        </link>
        <updated>2021-06-28T14:43:21.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>因为git checkout 命令职责较多、不够明确，所以git 2.23 版本新增了switch、restore命令</p>
<p>switch命令专门用来切换分支、创建并切换分支等</p>
<h2 id="命令">命令</h2>
<h3 id="新建分支">新建分支</h3>
<p>新建并切换分支</p>
<pre><code class="language-sh">git switch -c [branch-name]
git switch -c new
</code></pre>
<p>从某个快照新建并切换分支</p>
<pre><code class="language-sh">git switch -c [branch-name] [commitID]
git switch -c new c2
</code></pre>
<p>从某个标签新建并切换分支</p>
<pre><code class="language-sh">git switch -c [branch-name] [tag-name]
git switch -c new v2.0
</code></pre>
<h3 id="切换分支">切换分支</h3>
<p>切换上次所在的分支</p>
<pre><code class="language-sh">git switch -
</code></pre>
<p>切换到<code>dev</code>分支</p>
<pre><code class="language-sh">git switch dev
</code></pre>
<h2 id="与checkout的对比">与checkout的对比</h2>
<h3 id="checkout">checkout</h3>
<p>checkout在分支方面的做用有两点：新建分支并切换到新建分支，切换分支</p>
<pre><code class="language-sh">git checkout -b new
git checkout dev
</code></pre>
<h3 id="switch">switch</h3>
<p>switch中相同作用的命令</p>
<pre><code class="language-sh">git switch -c new
git switch dev
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git-checkout]]></title>
        <id>https://leecss.com/post/git-checkout/</id>
        <link href="https://leecss.com/post/git-checkout/">
        </link>
        <updated>2021-06-28T13:45:44.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p><code>git checkout</code>命令有多种用途。大致分为新建分支；切换分支、快照、标签；撤销文件。</p>
<h2 id="分类">分类</h2>
<h3 id="新建分支">新建分支</h3>
<p><code>-b</code>用于生成一个新的分支。</p>
<pre><code class="language-sh">git checkout -b new
</code></pre>
<h3 id="切换分支">切换分支</h3>
<p>回到先前所在的分支</p>
<pre><code class="language-sh">git checkout
</code></pre>
<p>切换到<code>dev</code>分支</p>
<pre><code class="language-sh">git checkout dev
</code></pre>
<h2 id="切换到指定快照commit">切换到指定快照（commit）</h2>
<pre><code class="language-sh">git checkout &lt;commitID&gt;
</code></pre>
<h2 id="切换到某个tag">切换到某个tag</h2>
<pre><code class="language-sh">git checkout tags/1.1.4
</code></pre>
<p>当本地没有叫做1.1.4的分支时，可以省略<code>tags/</code>,直接使用标签名</p>
<pre><code>git checkout 1.1.4
</code></pre>
<h3 id="撤销文件修改">撤销文件修改</h3>
<h4 id="工作区">工作区</h4>
<p>将指定文件从暂存区复制到工作区，用来丢弃工作区对该文件的修改</p>
<pre><code class="language-sh">git checkout -- &lt;filename&gt;
</code></pre>
<h4 id="暂存区和工作区">暂存区和工作区</h4>
<p>指定从某个 commit 恢复指定文件，同时改变暂存区和工作区</p>
<pre><code class="language-sh">git checkout HEAD~ -- &lt;filename&gt;
</code></pre>
<p><code>-p</code>参数表示进入交互模式，只恢复部分变化。</p>
<pre><code class="language-sh">git checkout -p
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[祝宝贝生日快乐]]></title>
        <id>https://leecss.com/post/zhu-bao-bei-sheng-ri-kuai-le/</id>
        <link href="https://leecss.com/post/zhu-bao-bei-sheng-ri-kuai-le/">
        </link>
        <updated>2021-06-27T16:05:20.000Z</updated>
        <content type="html"><![CDATA[<p>happy birthday~<br>
😛😛😛</p>
<p>一岁一礼 一寸欢喜<br>
<img src="https://leecss.com/post-images/1624805818323.jpg" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git-原理]]></title>
        <id>https://leecss.com/post/git-yuan-li/</id>
        <link href="https://leecss.com/post/git-yuan-li/">
        </link>
        <updated>2021-06-27T05:58:41.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="git是如何存储信息的">git是如何存储信息的</h2>
<p>1、初始化仓库，新建文件，并添加到暂存区</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="git是如何存储信息的">git是如何存储信息的</h2>
<p>1、初始化仓库，新建文件，并添加到暂存区</p>
<!-- more -->
<pre><code class="language-sh">git init
echo '111' &gt; a.txt
echo '222' &gt; b.txt
git add *.txt
</code></pre>
<pre><code class="language-sh">// 查看一下当前的git仓库中的内容
tree .git

├─hooks    
├─info     
├─objects  
│  ├─4e    
│  ├─71    
│  ├─info  
│  └─pack  
└─refs     
    ├─heads
    └─tags 
    
ls -a .git/objects/4e
./  ../  f5d11d3b99f88fb9f70b694de01db16c56ed50

ls -a .git/objects/71
./  ../  70f7d93c37a8861f0e6816780b2881ad5f58d2

// 查看一下f5d11d3b99f88fb9f70b694de01db16c56ed50文件中的内容
cat .git/objects/4e/f5d11d3b99f88fb9f70b694de01db16c56ed50
x☺K□□OR0gP744TW□☻∟.♥☻
// 打印出来的是一些乱码，原因是因为git对储存的内容做了二进制压缩
</code></pre>
<p>2、cat-file</p>
<pre><code class="language-sh">git cat-file [-t] [-p]
</code></pre>
<p>-t 打印文件类型</p>
<p>-p 打印文件具体内容</p>
<pre><code class="language-sh">git cat-file -t 4ef5d1
blob
git cat-file -p 4ef5d1
'111'
</code></pre>
<p>3、git object</p>
<p>git 储存信息的最小单元，对象数据库包含四类对象。git对象创建完成后均不可变更。</p>
<ul>
<li>Blob：包含二进制数据，它们是文件内容。只要文件内容改变，就会在对象数据库中生成一个blob对象。注意，blob对象只保存文件内容，不含文件名和文件存储位置等信息。如果文件名改变，或者文件储存位置改变，不会生成新的blob对象。</li>
<li>Tree：blob对象的集合，以及它们的文件名和权限。一个tree对象描述一个时点上的一个目录。</li>
<li>Commit：描述一个时点上的项目状态，包含一条log信息，一个tree对象和指向父节点（parent commits）的指针。第一个commit对象没有父节点。
<ul>
<li>记录 root tree SHA1</li>
<li>记录 parent commit SHA1</li>
<li>记录作者、时间和 commit message</li>
</ul>
</li>
<li>tag</li>
</ul>
<p>4、sha1哈希算法</p>
<pre><code class="language-sh">111 -&gt; 4ef5d11d3b99f88fb9f70b694de01db16c56ed50
</code></pre>
<p>每个git对象都有一个哈希值，哈希值可以理解为我们的身份证号</p>
<p><code>4ef5d11d3b99f88fb9f70b694de01db16c56ed50</code>就是内容为111类型为blob的git对象的身份证号，我们可以通过4ef5d11d3b99f88fb9f70b694de01db16c56ed50找到这个git对象</p>
<p>5、git commit</p>
<pre><code class="language-sh">git commit -m 'init'
</code></pre>
<pre><code class="language-sh">tree .git

├─hooks
├─info
├─logs
│  └─refs
│      └─heads
├─objects
│  ├─39
│  ├─4e
│  ├─5f
│  ├─71
│  ├─info
│  └─pack
└─refs
    ├─heads
    └─tags
    
 ls -a .git/objects/39
./  ../  bd985025d281e7c1d1c9493c90156fb9e26ea0

ls -a .git/objects/5f
./  ../  3f16e16db5faec1bf71fab36cbad24fbddfd39
</code></pre>
<pre><code class="language-sh">git cat-file -t 5f3f16
tree

git cat-file -p 5f3f16
100644 blob 4ef5d11d3b99f88fb9f70b694de01db16c56ed50    a.txt
100644 blob 7170f7d93c37a8861f0e6816780b2881ad5f58d2    b.txt
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://leecss.com/post-images/1624773693534.png" alt="" loading="lazy"></figure>
<pre><code class="language-sh">git cat-file -t 39bd98
commit

git cat-file -p 39bd98
tree 5f3f16e16db5faec1bf71fab36cbad24fbddfd39
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://leecss.com/post-images/1624773720929.png" alt="" loading="lazy"></figure>
<p>6、HEAD指针和分支</p>
<pre><code class="language-sh">cat .git/HEAD
ref: refs/heads/master

cat .git/refs/heads/master
39bd985025d281e7c1d1c9493c90156fb9e26ea0
</code></pre>
<p>可以看出，HEAD指针指向分支指针，分支指针指向最新的commit</p>
<p>HEAD、分支、普通的Tag可以简单的理解成是一个指针，指向对应commit的SHA1值。</p>
<figure data-type="image" tabindex="3"><img src="https://leecss.com/post-images/1624773733859.png" alt="" loading="lazy"></figure>
<p>7、为什么要把文件的权限和文件名储存在Tree object里面而不是Blob object呢？</p>
<p>因为更改一个文件名就需要新建一个Blob object，假如文件很大的话，会很占空间，而Tree object体积相对很小</p>
<p>8、当你修改了其中一个文件，创建一个新的commit后</p>
<figure data-type="image" tabindex="4"><img src="https://leecss.com/post-images/1624774577309.png" alt="" loading="lazy"></figure>
<h2 id="git的三个分区">git的三个分区</h2>
<ul>
<li>工作目录 （ working directory ）：操作系统上的文件，所有代码开发编辑都在这上面完成。</li>
<li>索引（ index or staging area ）：可以理解为一个暂存区域，这里面的代码会在下一次commit被提交到Git仓库。</li>
<li>Git仓库（ git repository ）：由Git object记录着每一次提交的快照，以及链式结构记录的提交变更历史。</li>
</ul>
<figure data-type="image" tabindex="5"><img src="https://leecss.com/post-images/1624774695680.gif" alt="" loading="lazy"></figure>
<h2 id="转载">转载</h2>
<blockquote>
<p>李泽帆</p>
<p>https://www.lzane.com/tech/git-internal/</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git-init]]></title>
        <id>https://leecss.com/post/git-init/</id>
        <link href="https://leecss.com/post/git-init/">
        </link>
        <updated>2021-06-27T05:58:06.000Z</updated>
        <content type="html"><![CDATA[<h2 id="将当前目录转为git仓库">将当前目录转为git仓库</h2>
<p><code>git init</code>命令将当前目录转为git仓库。</p>
<p>它会在当前目录下生成一个.git子目录，在其中写入git的配置和项目的快照。</p>
<h2 id="在当前目录下创建一个新的目录">在当前目录下创建一个新的目录</h2>
<pre><code class="language-sh">git init &lt;repository-name&gt;
git init place
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git-安装]]></title>
        <id>https://leecss.com/post/git-an-zhuang/</id>
        <link href="https://leecss.com/post/git-an-zhuang/">
        </link>
        <updated>2021-06-27T05:57:14.000Z</updated>
        <content type="html"><![CDATA[<h2 id="windows">windows</h2>
<p>从官方网站上下载安装包，按照默认配置快速安装（一直下一步），访问git官网，即可下载git，git的官方网址如下：</p>
<p><a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></p>
<p>在windows中安装git的过程中，如果你没有修改默认的设置，当安装完成后，安装程序会自动为你安装两种客户端，一种是图形化的客户端，一种是命令行的客户端，图形化的客户端被称之为”Git GUI”，命令行的客户端被称之为”Git Bash”，在系统的”开始”菜单中可以找到”Git GUI”和”Git Bash”，同时，默认情况下，当你安装完成git后，你的右键菜单中会多出两个选项，”Git GUI Here”和”Git Bash Here”，通过这两项，你可以在任何目录中打开”Git GUI”和”Git Bash”，”Git GUI”和”Git Bash”都是客户端程序，我们可以通过这两种程序中的任意一种来操作git，从而达到版本控制的目的，这两种工具在不同的使用场景下各有优势，命令行的优势在于比较通用，而且当你需要编写一些版本控制的自动化脚本时，无可避免的需要使用git命令，使用图形化的好处就是比较直观，所以，我们有可能会交替的使用这两种工具，但是主要以命令行的使用模式为主，因为只要理解了相关概念和git命令后，再去使用任何一种图形化工具，都是非常简单的。</p>
<p>除了gitk（默认安装的图形化客户端就包含了gitk），比较出名的git图形化工具还有SourceTree、TortoiseGit、GitHubDesktop、GitKraken、GitUp等，当你熟悉了git命令以后，再去操作这些图形化工具都会变得游刃有余。</p>
<p><strong>打开gitk图形化操作界面</strong></p>
<pre><code class="language-sh">gitk
</code></pre>
<h2 id="初始化配置">初始化配置</h2>
<p>如果想要使用git进行版本管理，我们首先要做的就是，设置自己的”用户名”和”用户邮箱”，这些信息是必须的，特别是在多人协作时，这些信息也是非常必要的，所以，在完成安装操作以后，我们首先要做的就是设置自己的”用户名”和”用户邮箱”，这些信息只需要设置一次，就可以一直正常的使用git，除非你有需要修改这些信息。</p>
<h3 id="设置用户名和邮箱">设置用户名和邮箱</h3>
<pre><code class="language-sh">git config --global user.name &quot;lee&quot;
git config --global user.email &quot;lee@emial.com&quot;
</code></pre>
<h3 id="查看自己的用户名和邮箱设置">查看自己的用户名和邮箱设置</h3>
<pre><code class="language-sh">git config --global --list
</code></pre>
<h3 id="参数">参数</h3>
<pre><code class="language-sh">git config --system：使对应配置针对系统内所有的用户有效
git config --global：使对应配置针对当前系统用户的所有仓库生效
git config --local：使对应配置只针对当前仓库有效
local选项设置的优先级最高。
</code></pre>
]]></content>
    </entry>
</feed>