<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://leecss.com</id>
    <title>当下</title>
    <updated>2021-07-04T09:17:42.254Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://leecss.com"/>
    <link rel="self" href="https://leecss.com/atom.xml"/>
    <logo>https://leecss.com/images/avatar.png</logo>
    <icon>https://leecss.com/favicon.ico</icon>
    <rights>All rights reserved 2021, 当下</rights>
    <entry>
        <title type="html"><![CDATA[git命令总结]]></title>
        <id>https://leecss.com/post/git-ming-ling-zong-jie/</id>
        <link href="https://leecss.com/post/git-ming-ling-zong-jie/">
        </link>
        <updated>2021-07-04T08:37:45.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>命令加思维导图</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>命令加思维导图</p>
<!-- more -->
<h2 id="新建代码库">新建代码库</h2>
<pre><code class="language-bash"># 在当前目录新建一个Git代码库
$ git init

# 新建一个目录，将其初始化为Git代码库
$ git init [project-name]

# 下载一个项目和它的整个代码历史
$ git clone [url]
</code></pre>
<h2 id="配置">配置</h2>
<p>Git的设置文件为<code>.gitconfig</code>，它可以在用户主目录下，也可以在项目目录下。</p>
<pre><code class="language-bash"># 显示当前的Git配置
$ git config --list

# 编辑Git配置文件
$ git config -e [--global]

# 设置提交代码时的用户信息
$ git config [--global] user.name &quot;[name]&quot;
$ git config [--global] user.email &quot;[email address]&quot;
</code></pre>
<h2 id="增加删除文件">增加/删除文件</h2>
<pre><code class="language-bash"># 添加指定文件到暂存区
$ git add [file1] [file2] ...

# 添加指定目录到暂存区，包括子目录
$ git add [dir]

# 添加当前目录的所有文件到暂存区
$ git add .

# 删除工作区文件，并且将这次删除放入暂存区
$ git rm [file1] [file2] ...

# 停止追踪指定文件，但该文件会保留在工作区
$ git rm --cached [file]

# 改名文件，并且将这个改名放入暂存区
$ git mv [file-original] [file-renamed]
</code></pre>
<h2 id="代码提交">代码提交</h2>
<pre><code class="language-bash"># 提交暂存区到仓库区
$ git commit -m [message]

# 提交暂存区的指定文件到仓库区
$ git commit [file1] [file2] ... -m [message]

# 提交工作区自上次commit之后的变化，直接到仓库区
$ git commit -a

# 提交时显示所有diff信息
$ git commit -v

# 使用一次新的commit，替代上一次提交
# 如果代码没有任何新变化，则用来改写上一次commit的提交信息
$ git commit --amend -m [message]

# 重做上一次commit，并包括指定文件的新变化
$ git commit --amend &lt;file1&gt; &lt;file2&gt; ...
</code></pre>
<h2 id="分支">分支</h2>
<pre><code class="language-bash"># 列出所有本地分支
$ git branch

# 列出所有远程分支
$ git branch -r

# 列出所有本地分支和远程分支
$ git branch -a

# 新建一个分支，但依然停留在当前分支
$ git branch [branch-name]

# 新建一个分支，并切换到该分支
$ git checkout -b [branch]

# 新建一个分支，指向指定commit
$ git branch [branch] [commit]

# 新建一个分支，与指定的远程分支建立追踪关系
$ git branch --track [branch] [remote-branch]

# 切换到指定分支，并更新工作区
$ git checkout [branch-name]

# 建立追踪关系，在现有分支与指定的远程分支之间
$ git branch --set-upstream [branch] [remote-branch]

# 合并指定分支到当前分支
$ git merge [branch]

# 选择一个commit，合并进当前分支
$ git cherry-pick [commit]

# 删除分支
$ git branch -d [branch-name]

# 删除远程分支
$ git push origin --delete &lt;branch-name&gt;
$ git branch -dr &lt;remote/branch&gt;
</code></pre>
<h2 id="标签">标签</h2>
<pre><code class="language-bash"># 列出所有tag
$ git tag

# 新建一个tag在当前commit
$ git tag [tag]

# 新建一个tag在指定commit
$ git tag [tag] [commit]

# 查看tag信息
$ git show [tag]

# 提交指定tag
$ git push [remote] [tag]

# 提交所有tag
$ git push [remote] --tags

# 新建一个分支，指向某个tag
$ git checkout -b [branch] [tag]
</code></pre>
<h2 id="查看信息">查看信息</h2>
<pre><code class="language-bash"># 显示有变更的文件
$ git status

# 显示当前分支的版本历史
$ git log

# 显示commit历史，以及每次commit发生变更的文件
$ git log --stat

# 显示某个文件的版本历史，包括文件改名
$ git log --follow [file]
$ git whatchanged [file]

# 显示指定文件相关的每一次diff
$ git log -p [file]

# 显示指定文件是什么人在什么时间修改过
$ git blame [file]

# 显示暂存区和工作区的差异
$ git diff

# 显示暂存区和上一个commit的差异
$ git diff --cached [&lt;file&gt;]

# 显示工作区与当前分支最新commit之间的差异
$ git diff HEAD

# 显示两次提交之间的差异
$ git diff [first-branch]...[second-branch]

# 显示某次提交的元数据和内容变化
$ git show [commit]

# 显示某次提交发生变化的文件
$ git show --name-only [commit]

# 显示某次提交时，某个文件的内容
$ git show [commit]:[filename]

# 显示当前分支的最近几次提交
$ git reflog
</code></pre>
<h2 id="远程同步">远程同步</h2>
<pre><code class="language-bash"># 下载远程仓库的所有变动
$ git fetch [remote]

# 显示所有远程仓库
$ git remote -v

# 显示某个远程仓库的信息
$ git remote show [remote]

# 增加一个新的远程仓库，并命名
$ git remote add [shortname] [url]

# 取回远程仓库的变化，并与本地分支合并
$ git pull [remote] [branch]

# 上传本地指定分支到远程仓库
$ git push [remote] [branch]

# 强行推送当前分支到远程仓库，即使有冲突
$ git push [remote] --force

# 推送所有分支到远程仓库
$ git push [remote] --all
</code></pre>
<h2 id="撤销">撤销</h2>
<pre><code class="language-bash"># 恢复暂存区的指定文件到工作区
$ git checkout [file]

# 恢复某个commit的指定文件到工作区
$ git checkout [commit] [file]

# 恢复上一个commit的所有文件到工作区
$ git checkout .

# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变
$ git reset [file]

# 重置暂存区与工作区，与上一次commit保持一致
$ git reset --hard

# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变
$ git reset [commit]

# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致
$ git reset --hard [commit]

# 重置当前HEAD为指定commit，但保持暂存区和工作区不变
$ git reset --keep [commit]

# 新建一个commit，用来撤销指定commit
# 后者的所有变化都将被前者抵消，并且应用到当前分支
$ git revert [commit]
</code></pre>
<h2 id="其他">其他</h2>
<pre><code class="language-bash"># 生成一个可供发布的压缩包
# git archive
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://leecss.com/post-images/1625387910788.jpg" alt="" loading="lazy"></figure>
<h2 id="转载">转载</h2>
<blockquote>
<p>先抄一下阮老师的文章和腾讯的图</p>
<p>以后有时间再整理</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git-实用场景]]></title>
        <id>https://leecss.com/post/git-shi-yong-chang-jing/</id>
        <link href="https://leecss.com/post/git-shi-yong-chang-jing/">
        </link>
        <updated>2021-07-04T08:23:50.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>一些工作中会用到的知识点</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>一些工作中会用到的知识点</p>
<!-- more -->
<h2 id="正常操作流程">正常操作流程</h2>
<pre><code class="language-sh">git add .
git commit -m &quot;提交描述&quot;
git pull
git push
</code></pre>
<p>上述操作流程是经常会使用的操作，为什么pull之前要先提交commit？</p>
<p>分两步理解</p>
<p>第一步是<code>git add &amp; git commit</code>，这是你本地仓库的操作记录</p>
<p>第二步是<code>git pull &amp; git push</code>，这是本地仓库和远程仓库的交互与同步。</p>
<p>假如你本地没有修改文件，可以直接进行第二步，随时和远程仓库进行同步。</p>
<p>假如你本地有修改文件，需要先将本地代码保存起来，做一次提交，这样在和远程交互的时候，才能对比操作。</p>
<p>否则本地修改文件会被覆盖丢失。</p>
<h2 id="合并代码">合并代码</h2>
<p>当开发完成一个迭代后，需要发布上线，此时需要将dev分支的代码合并到master</p>
<pre><code class="language-sh">git switch master
git pull origin dev
git push
</code></pre>
<h2 id="暂存代码">暂存代码</h2>
<p>当你需要去合并分支的时候，假如你dev分支上有未完成的工作，此时是不能切换分支的。</p>
<p>但是因为工作还没有完成，你不想提交到远程，那么就可以将代码先暂存起来。</p>
<pre><code class="language-sh">git stash

git switch master
git pull origin dev
git push

git switch dev
git stash pop
</code></pre>
<h2 id="修复线上bug">修复线上bug</h2>
<p>此时已经发布上线了，但是发现线上有一个bug需要紧急处理，应该怎么做？</p>
<pre><code class="language-sh">// 从master分支检出bugfix分支
git switch master
git switch -c bugfix
// 修复bug,提交到仓库
git add .
git commit -m 'fix bug x'
// 切换到master,合并bugfix分支并删除
git switch master
git merge --no-ff -m &quot;merged bugfix x&quot; bugfix
git branch -d fixbug
</code></pre>
<p>假如你没有检出bug分支，直接在dev分支上开发的</p>
<pre><code class="language-sh">// 修复bug,提交到仓库
git add .
git commit -m 'fix bug x'
// 拉取远程更新,并推送
git pull --rebase
git push
// 此时发现另外一名同事已经提交了一些东西，但是这些没经过验证不可以发到线上
// 查看提交记录，记录下你刚刚提交的commitId，假设为c0
git log --oneline
// 切换到master
git cherry-pick [刚刚提交的commitID]
git cherry-pick c0
// 提交
git pull
git push
</code></pre>
<h2 id="版本回退">版本回退</h2>
<pre><code class="language-sh">// 查看提交记录
git log --oneline
// 以上次提交举例HEAD~，实际以具体commitID
git reset --hard [commitid]
git reset --hard HEAD~
// 强行推送到远程
git push -f
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git-clean]]></title>
        <id>https://leecss.com/post/git-clean/</id>
        <link href="https://leecss.com/post/git-clean/">
        </link>
        <updated>2021-07-04T03:21:45.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p><code>git clean</code>从你的工作区中删除所有没有 tracked，没有被管理过的文件。</p>
<p>作用是让使工作区回到一个干净的状态(一个指定的commit状态)</p>
<p>git clean 和 git reset --hard 结合使用。</p>
<p>clean 影响没有被 track 过的文件（清除未被 add 或被 commit 的本地修改）</p>
<p>reset 影响被 track 过的文件 （回退到上一个 commit）</p>
<p>说到这里，我不禁想起了restore。两者结合不就是restore吗？</p>
<h2 id="命令">命令</h2>
<p>查看可使用<code>git clean</code>命令清除的文件</p>
<pre><code class="language-sh">git clean -n
</code></pre>
<p>删除当前目录下所有没有 track 过的文件</p>
<p>不会删除 <code>.gitignore</code> 文件里面指定的文件夹和文件, 不管这些文件有没有被 track 过</p>
<pre><code class="language-sh">git clean -f
</code></pre>
<p>删除指定路径下的没有被 track 过的文件</p>
<pre><code class="language-sh">git clean -f &lt;path&gt;
</code></pre>
<p>删除当前目录下没有被 track 过的文件和文件夹</p>
<pre><code class="language-sh">git clean -df
</code></pre>
<p>删除当前目录下所有没有 track 过的文件</p>
<p>不管是否是 <code>.gitignore</code>文件里面指定的文件夹和文件</p>
<pre><code class="language-sh">git clean -xf
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git-show]]></title>
        <id>https://leecss.com/post/git-show/</id>
        <link href="https://leecss.com/post/git-show/">
        </link>
        <updated>2021-07-04T02:54:11.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p><code>git show</code>命令用于查看commit的内容</p>
<h2 id="命令">命令</h2>
<pre><code class="language-sh"># 输出某次提交的元数据和内容变化
$ git show [commit]
$ git show 12a86bc38 # By revision
$ git show v1.0.1 # By tag
$ git show feature132 # By branch name
$ git show 12a86bc38^ # Parent of a commit
$ git show 12a86bc38~2 # Grandparent of a commit
$ git show feature132@{yesterday} # Time relative
$ git show feature132@{2.hours.ago} # Time relative
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git-show-branch]]></title>
        <id>https://leecss.com/post/git-show-branch/</id>
        <link href="https://leecss.com/post/git-show-branch/">
        </link>
        <updated>2021-07-04T01:22:22.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>查看分支及其历史提交记录</p>
<h2 id="命令">命令</h2>
<p>查看本地分支</p>
<pre><code class="language-sh">git show-branch
</code></pre>
<p>查看远程分支</p>
<pre><code class="language-sh">git show-branch -r
</code></pre>
<p>查看所有分支</p>
<pre><code class="language-sh">git show-branch -a
</code></pre>
<h2 id="解析">解析</h2>
<p>1、输出分为上下两部分，使用若干个短划线<code>-</code>分隔。两个分支使用两个短划线<code>--</code>，三个分支使用三个短划线<code>---</code>，依次类推。</p>
<p>2、上半部分为层次缩进的分支列表，下半部分为commit列表。</p>
<p>3、上半部分的分支列表中，使用<code>*</code>标识当前分支，使用<code>!</code>标识其他分支（不同的分支！标识颜色不一样）。</p>
<p>分支前的标识符<code>*</code>或者<code>!</code>一直垂直贯通到下半部分，这一列完全相同的符号代表的commit都是属于这个分支的。</p>
<p>4、下半部分的commit列表中，前导的符号有<code>*</code>和<code>+</code>号。</p>
<p><code>*</code>表示当前分支上有此commit。</p>
<p><code>+</code>表示此颜色代表的分支上有此commit。</p>
<p>5、标识符的颜色只是用于容易区分列，一个分支一个颜色。</p>
<figure data-type="image" tabindex="1"><img src="https://leecss.com/post-images/1625361802965.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git-鼠标右键手动添加git-bash]]></title>
        <id>https://leecss.com/post/git-shu-biao-you-jian-shou-dong-tian-jia-git-bash/</id>
        <link href="https://leecss.com/post/git-shu-biao-you-jian-shou-dong-tian-jia-git-bash/">
        </link>
        <updated>2021-07-04T01:04:12.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>鼠标右键没有git bash的解决办法</p>
<h2 id="操作">操作</h2>
<p>1、打开注册表</p>
<blockquote>
<p><code>win+r</code>,输入<code>regedit</code></p>
</blockquote>
<p>2、找到shell目录</p>
<blockquote>
<p>路径为：计算机\HKEY_CLASSES_ROOT\Directory\Background\shell</p>
<p>如果Background目录下没有shell文件夹就新建shell文件夹。</p>
</blockquote>
<p>3、在shell目录上右键-新建-项，命名bash</p>
<p>4、点击新建的Bash 右侧出现默认，点击默认，设置值为Open in Bash</p>
<p>5、在bash目录上右键-新建-项，命名command</p>
<p>6、点击commond，右侧出现默认，点击默认，修改值为你的git-bash路径</p>
<blockquote>
<p>以我的举例</p>
<p>D:\software\git\Git\git-bash.exe</p>
</blockquote>
<p>7、保存关闭注册表，在任意目录鼠标右键测试</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git-blame]]></title>
        <id>https://leecss.com/post/git-blame/</id>
        <link href="https://leecss.com/post/git-blame/">
        </link>
        <updated>2021-07-03T13:07:04.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>从blame这个词就能大致知道这个命令的作用了</p>
<p><code>git blame</code> 命令可以查看每行代码的提交详情，包括提交人、时间等信息</p>
<p>当你发现某一行写的有问题时，你就可以查看是谁最后改的这里</p>
<h2 id="命令">命令</h2>
<p>显示指定文件的历史修改记录</p>
<pre><code class="language-sh">git blame &lt;filename&gt;
</code></pre>
<h3 id="查看具体的行或范围">查看具体的行或范围</h3>
<p><code>-L</code>看某一行或某个范围行</p>
<pre><code class="language-sh">git blame &lt;filename&gt; -L &lt;start&gt;[,&lt;end&gt;]
</code></pre>
<p>查看第 10 行</p>
<pre><code>git blame &lt;filename&gt; -L 10,10
</code></pre>
<p>查看第 10 行及以后</p>
<pre><code class="language-sh">git blame &lt;filename&gt; -L 10
</code></pre>
<p>查看第 10 到 20 行</p>
<pre><code class="language-sh">git blame &lt;filename&gt; -L 10,20
</code></pre>
<p>查看 10 行以后 5 行的数据</p>
<pre><code class="language-sh">git blame &lt;filename&gt; -L 10,+5
</code></pre>
<p>查看 10 行以前 5 行的数据</p>
<pre><code class="language-sh">git blame &lt;filename&gt; -L 10,-5
</code></pre>
<h3 id="查看某个函数">查看某个函数</h3>
<p>通过函数名来查看一个区域块的代码，只能识别文件最外层的方法名和类名</p>
<pre><code class="language-sh">git blame &lt;filename&gt; -L:&lt;func_name&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git-bisect]]></title>
        <id>https://leecss.com/post/git-bisect/</id>
        <link href="https://leecss.com/post/git-bisect/">
        </link>
        <updated>2021-07-03T11:15:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>用来查找哪一次代码提交引入了错误。</p>
<p>它的原理很简单，就是将代码提交的历史，按照两分法不断缩小定位。所谓&quot;两分法&quot;，就是将代码历史一分为二，确定问题出在前半部分，还是后半部分，不断执行这个过程，直到范围缩小到某一次代码提交。</p>
<figure data-type="image" tabindex="1"><img src="https://leecss.com/post-images/1625311032096.png" alt="" loading="lazy"></figure>
<h2 id="命令">命令</h2>
<h3 id="启动查错">启动查错</h3>
<p>&quot;终点&quot;是最近的提交，&quot;起点&quot;是更久以前的提交。它们之间的这段历史，就是差错的范围。</p>
<p>我们可以将起点置为第一次，也可以置为我们知道的具体某个commit</p>
<p>现在，我们选择全部的代码历史。起点是第一次提交<code>4d83cf</code>，终点是最近一次的<code>HEAD</code>。</p>
<pre><code class="language-sh">git bisect start [终点] [起点]
git bisect start HEAD 4d83cf
</code></pre>
<p>执行上面的命令以后，代码库就会切换到这段范围正当中的那一次提交</p>
<p>假如这个库一共有101次提交。那么就会切换到第51次提交。</p>
<h3 id="标识正确">标识正确</h3>
<p>现在刷新浏览器，发现功能正常。使用<code>git bisect good</code>命令，标识本次提交（第51次）没有问题。</p>
<pre><code class="language-sh">git bisect good
</code></pre>
<p>既然第51次提交没有问题，就意味着错误是在代码历史的后半段引入的。执行上面的命令，Git 就自动切换到后半段的中点（第76次提交）。</p>
<h3 id="标志错误">标志错误</h3>
<p>现在刷新浏览器,发现功能不正常。使用<code>git bisect bad</code>命令，标识本次提交（第76）有问题。</p>
<pre><code class="language-sh">git bisect bad
</code></pre>
<p>执行上面的命令以后，Git 就自动切换到第51次到第76次的中点（第63次提交）。</p>
<p>接下来，不断重复这个过程，直到成功找到出问题的那一次提交为止。这时，Git 会给出如下的提示。</p>
<pre><code class="language-sh">b47892 is the first bad commit
</code></pre>
<p>既然找到那个有问题的提交，就可以<a href="https://github.com/bradleyboy/bisectercise/commit/b47892adec22ee3b0330aff37cbc5e695dfb99d6">检查代码</a>，确定具体是什么错误。</p>
<h3 id="退出查错">退出查错</h3>
<p>然后，使用<code>git bisect reset</code>命令，退出查错，回到最近一次的代码提交。</p>
<pre><code class="language-sh">git bisect reset
</code></pre>
<p>现在就可以开始修复错误了。</p>
<h2 id="转载">转载</h2>
<blockquote>
<p>阮一峰</p>
<p><a href="http://www.ruanyifeng.com/blog/2018/12/git-bisect.html">http://www.ruanyifeng.com/blog/2018/12/git-bisect.html</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git-gitignore]]></title>
        <id>https://leecss.com/post/git-gitignore/</id>
        <link href="https://leecss.com/post/git-gitignore/">
        </link>
        <updated>2021-07-03T10:02:29.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>一些工作区中的文件不需要提交到远程，所以需要让git忽略他们，不对其进行检测，方法就是创建.gitignore文件</p>
<h2 id="忽略规则">忽略规则</h2>
<h3 id="语法">语法</h3>
<p>以斜杠<code>/</code>开头表示目录；<br>
以星号<code>*</code>通配多个字符；<br>
以问号<code>?</code>通配单个字符<br>
以方括号<code>[]</code>包含单个字符的匹配列表；<br>
以叹号<code>!</code>表示不忽略(跟踪)匹配到的文件或目录；</p>
<p>此外，git 对于 .ignore 配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效；</p>
<h3 id="示例">示例</h3>
<p><strong>忽略</strong></p>
<pre><code class="language-sh"># 忽略根目录下的public下的所有目录及文件
/public/*

# 忽略所有目录名为public下的所有目录及文件
public/*

# 忽略具体的文件
/public/index.html

# 忽略所有的.zip文件
*.zip

# 忽略 a.zip b.zip
[ab].zip
</code></pre>
<p><strong>保留</strong></p>
<pre><code class="language-sh"># 不过滤该文件夹
!src/
</code></pre>
<h2 id="问题">问题</h2>
<h3 id="忽略规则不生效">忽略规则不生效</h3>
<p>原因是当前文件已经被加入到git仓库中</p>
<pre><code class="language-sh">git rm -r --cached .
git add .
git commit -m 'update .gitignore'
</code></pre>
<h2 id="网站">网站</h2>
<p><a href="https://github.com/github/gitignore">https://github.com/github/gitignore</a></p>
<p><a href="https://www.toptal.com/developers/gitignore">gitignore.io</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git-配置ssh-key]]></title>
        <id>https://leecss.com/post/git-pei-zhi-ssh-key/</id>
        <link href="https://leecss.com/post/git-pei-zhi-ssh-key/">
        </link>
        <updated>2021-07-03T07:54:40.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>ssh可以基于密码进行认证，也可以基于密钥去认证用户，基于密钥认证时可以实现免密码登录的效果。</p>
<p>SSH公钥默认存储在账户的主目录下的<code>~/.ssh</code>目录</p>
<p><code>ssh-keygen</code>生成私钥id_rsa以及对应的公钥</p>
<p><code>-t</code>选项表示指定密钥的类型(The type of the key to generate)</p>
<p>​	即指定算法，版本2的ssh协议可以指定的密钥类型有 “dsa”, “ecdsa”, “ed25519”, “rsa”</p>
<p><code>-C</code> 选项表示用于识别这个密钥的注释 (comment to identify the key )</p>
<p><code>-f</code>选项表示直接指定密钥生成位置以及密钥的名称，默认id_rsa（私钥id_rsa，公钥id_rsa.pub）</p>
<h2 id="单个">单个</h2>
<p>1、生成密钥对</p>
<pre><code class="language-sh">ssh-keygen -t rsa -C &quot;your-email@email.com&quot;
</code></pre>
<p>2、查看公钥并复制</p>
<pre><code class="language-sh">cat ~/.ssh/id_rsa.pub
</code></pre>
<p>3、登录账户并添加ssh key</p>
<h2 id="多个">多个</h2>
<p>1、生成密钥对</p>
<p>GitHub</p>
<pre><code class="language-sh">ssh-keygen -t rsa -f ~/.ssh/id_rsa.github -C 'email'
</code></pre>
<p>company</p>
<pre><code class="language-sh">ssh-keygen -t rsa -f ~/.ssh/id_rsa.company -C &quot;email&quot;
</code></pre>
<p>此时，<code>~/.ssh</code>目录下应该有4个文件：<code>id_rsa.company</code>文件和<code>id_rsa.company.pub</code>文件，还有<code>id_rsa.github</code>文件和<code>id_rsa.github.pub</code>文件。</p>
<p>2、查看公钥并添加到github和gitlab</p>
<pre><code>cat ~/.ssh/id_rsa.pub
</code></pre>
<p>3、新增并配置config文件</p>
<pre><code class="language-sh">touch ~/.ssh/config
</code></pre>
<p>参数说明：</p>
<p><code>Host</code>：定义<strong>Host</strong>的名字,（建议与HostName一致）</p>
<p><code>HostName</code>：这个是真实的域名地址，要登录主机的主机名。</p>
<p><code>Port</code>：端口号（如果不是默认22端口，则需要指定端口号）</p>
<p><code>User</code>：配置登录名，例如：GitHub的username。</p>
<p><code>IdentityFile</code>：指定私钥文件的路径，也就是<code>id_rsa</code>文件的绝对路径。</p>
<p><code>PreferredAuthentications</code>：配置登录时用什么权限认证，可设为<code>publickey,password publickey,keyboard-interactive等</code>。</p>
<p>内容格式如下：</p>
<pre><code class="language-sh">Host 域名或者IP
User test
IdentityFile ~/.ssh/id_rsa.company
PreferredAuthentications publickey
</code></pre>
<p>举例：</p>
<pre><code class="language-sh">// github
Host github.com
HostName github.com
User lee
IdentityFile /Users/lee/.ssh/id_rsa.github
PreferredAuthentications publickey

// company
Host company
HostName 192.168.1.222
User lee
IdentityFile ~/.ssh/id_rsa.company
PreferredAuthentications publickey
</code></pre>
<pre><code class="language-sh">git clone git@company:lee/test.git
</code></pre>
]]></content>
    </entry>
</feed>