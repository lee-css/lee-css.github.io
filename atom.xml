<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://leecss.com</id>
    <title>当下</title>
    <updated>2021-07-20T00:29:12.564Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://leecss.com"/>
    <link rel="self" href="https://leecss.com/atom.xml"/>
    <logo>https://leecss.com/images/avatar.png</logo>
    <icon>https://leecss.com/favicon.ico</icon>
    <rights>All rights reserved 2021, 当下</rights>
    <entry>
        <title type="html"><![CDATA[http-通用首部字段Cache-Control]]></title>
        <id>https://leecss.com/post/http-tong-yong-shou-bu-zi-duan-cache-control/</id>
        <link href="https://leecss.com/post/http-tong-yong-shou-bu-zi-duan-cache-control/">
        </link>
        <updated>2021-07-19T15:35:46.000Z</updated>
        <content type="html"><![CDATA[<h1 id="http-通用首部字段cache-control">http-通用首部字段Cache-Control</h1>
<h2 id="概述">概述</h2>
<p>通过指定首部字段 Cache-Control 的指令，就能操作缓存的工作机制。</p>
<h2 id="书写格式">书写格式</h2>
<p>指令的参数是可选的，多个指令之间通过“,”分隔。首部字段 CacheControl 的指令可用于请求及响应时。</p>
<pre><code>Cache-Control: private, max-age=0, no-cache
</code></pre>
<h2 id="分类">分类</h2>
<h3 id="缓存请求指令">缓存请求指令</h3>
<table>
<thead>
<tr>
<th>指令</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>no-cache</td>
<td>无</td>
<td>不使用缓存，缓存服务器必须把客户端请求转发给源服务器，在与源服务器进行新鲜度再验证之前，不能提供给客户端使用。</td>
</tr>
<tr>
<td>no-store</td>
<td>无</td>
<td>真正的不使用缓存，任何地方都不缓存请求或响应的任何内容。</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>max-age=60</td>
<td>必需</td>
<td>资源可缓存最大时间(相对时间：秒)，即过期时间、保质期。</td>
</tr>
<tr>
<td>max-stale=60</td>
<td>可省略</td>
<td>缓存资源，只要仍处于 max-stale指定的时间(秒)内，即使过期也照常接收。缓存总时长为max-age和max-stale叠加。</td>
</tr>
<tr>
<td>min-fresh=60</td>
<td>必需</td>
<td>期望在指定时间内(未来60秒内)的响应保持新鲜</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>no-transform</td>
<td>无</td>
<td>代理不可更改媒体类型</td>
</tr>
<tr>
<td>only-if-cached</td>
<td>无</td>
<td>只从缓存获取资源，若有则返回，若无则504</td>
</tr>
</tbody>
</table>
<h3 id="缓存响应指令">缓存响应指令</h3>
<table>
<thead>
<tr>
<th>指令</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>no-cache</td>
<td>无</td>
<td>缓存前必须先确认其有效性</td>
</tr>
<tr>
<td>no-store</td>
<td>无</td>
<td>不缓存请求或响应的任何内容</td>
</tr>
<tr>
<td>public</td>
<td>无</td>
<td>客户端、代理服务器都可利用缓存</td>
</tr>
<tr>
<td>private</td>
<td>无</td>
<td>仅发起请求的客户端可利用缓存</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>max-age=60</td>
<td>必需</td>
<td>针对源服务器，资源可缓存最大时间</td>
</tr>
<tr>
<td>s-maxage=60</td>
<td>必需</td>
<td>针对代理缓存服务器，资源可缓存最大时间</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>must-revalidate</td>
<td>无</td>
<td>可缓存但必须再向源服务器进行确认</td>
</tr>
<tr>
<td>proxy-revalidate</td>
<td>无</td>
<td>代理缓存服务器对缓存的响应有效性再进行确认</td>
</tr>
<tr>
<td>no-transform</td>
<td>无</td>
<td>代理不可更改媒体类型</td>
</tr>
</tbody>
</table>
<h2 id="详解">详解</h2>
<h3 id="no-cache">no-cache</h3>
<p>使用 no-cache 指令的目的是为了防止从缓存中返回过期的资源。</p>
<p><strong>客户端</strong>发送的请求中如果包含 no-cache 指令，则表示客户端将不会接收缓存过的响应。于是，“中间”的缓存服务器必须把客户端请求转发给源服务器。</p>
<p>如果<strong>服务器</strong>返回的响应中包含 no-cache 指令，那么缓存服务器不能对资源进行缓存。源服务器以后也将不再对缓存服务器请求中提出的资源有效性进行确认，且禁止其对响应资源进行缓存操作。</p>
<pre><code>Cache-Control: no-cache
</code></pre>
<p>如果可以使用缓存，则304；不可以使用，则200。</p>
<h3 id="max-age">max-age</h3>
<p>当<strong>客户端</strong>发送的请求中包含 max-age 指令时，如果判定缓存资源的缓存时间数值比指定时间的数值更小，那么客户端就接收缓存的资源。<br>
另外，<u>当指定 max-age 值为 0，那么缓存服务器通常需要将请求转发给源服务器</u>。</p>
<p>当<strong>服务器</strong>返回的响应中包含 max-age 指令时，缓存服务器将不对资源的有效性再作确认，而 max-age 数值代表资源保存为缓存的最长时间。</p>
<pre><code>Cache-Control: max-age=604800（单位：秒）
</code></pre>
<h3 id="min-fresh">min-fresh</h3>
<p>min-fresh 指令要求缓存服务器返回至少还未过指定时间的缓存资源。</p>
<p>比如，当指定 min-fresh 为 60 秒后，过了 60 秒的资源都无法作为响应返回了。</p>
<pre><code>Cache-Control: min-fresh=60（单位：秒）
</code></pre>
<h3 id="max-stale">max-stale</h3>
<p>使用 max-stale 可指示缓存资源，即使过期也照常接收。</p>
<p>如果指令中指定了具体数值，那么即使过期，只要仍处于 max-stale指定的时间内，仍旧会被客户端接收。</p>
<p><u>如果指令未指定参数值，那么无论经过多久，客户端都会接收响应；</u></p>
<pre><code>Cache-Control: max-stale=3600（单位：秒）
</code></pre>
<h3 id="only-if-cached">only-if-cached</h3>
<p>使用 only-if-cached 指令表示客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回。换言之，该指令要求缓存服务器不重新加载响应，也不会再次确认资源有效性。若发生请求缓存服务器的本地缓存无响应，则返回状态码 504 Gateway Timeout。</p>
<pre><code>Cache-Control: only-if-cached
</code></pre>
<h3 id="must-revalidate">must-revalidate</h3>
<p>使用 must-revalidate 指令，代理会向源服务器再次验证即将返回的响应缓存目前是否仍然有效。</p>
<p>若代理无法连通源服务器再次获取有效资源的话，缓存必须给客户端一条 504（Gateway Timeout）状态码。</p>
<p>另外，使用 must-revalidate 指令会忽略请求的 max-stale 指令（即使已经在首部使用了 max-stale，也不会再有效果）。</p>
<pre><code>Cache-Control: must-revalidate
</code></pre>
<h3 id="proxy-revalidate">proxy-revalidate</h3>
<p>proxy-revalidate 指令要求所有的缓存服务器在接收到客户端带有该指令的请求返回响应之前，必须再次验证缓存的有效性。</p>
<pre><code>Cache-Control: proxy-revalidate
</code></pre>
<h3 id="no-transform">no-transform</h3>
<p>有时为了提高性能，缓存或代理会有压缩图片等类似操作</p>
<p>使用 no-transform 指令规定无论是在请求还是响应中，缓存都不能改变实体主体的媒体类型。<br>
这样做可防止缓存或代理压缩图片等类似操作</p>
<h2 id="浏览器缓存机制">浏览器缓存机制</h2>
<p>以下总结自<a href="https://blog.csdn.net/kkdelta/article/details/100576096">网络</a>，以后确认具体过程。</p>
<p>1、当前缓存是否过期？2、服务器中的文件是否可用？</p>
<p><strong>第一步：判断当前缓存是否过期</strong></p>
<p>浏览器请求server.js文件，</p>
<p>假如文件还在缓存有效期内，则直接使用缓存，不会重新发起请求。</p>
<p>假如文件缓存过期，则重新发起请求。</p>
<p><strong>第二步：判断服务器中的文件是否可用</strong></p>
<p>服务器判断请求的server.js文件是否在缓存有效期内，若有效，则返回响应头304，浏览器直接使用过期缓存；</p>
<p>若文件已过期，服务器判断文件是否有改动，无改动，则返回响应头304，浏览器直接使用过期缓存；</p>
<p>若文件有改动，则返回200，并返回新文件。</p>
<h2 id="cache-control使用图解">cache-control使用图解</h2>
<figure data-type="image" tabindex="1"><img src="https://leecss.com/post-images/1626740943823.webp" alt="" loading="lazy"></figure>
<h2 id="目前仍有的疑问">目前仍有的疑问</h2>
<p>1、缓存总时长为max-age和max-stale叠加，取值为相加值，还是最大值？</p>
<p>2、must-revalidate和proxy-revalidate区别？</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[http-通用首部字段]]></title>
        <id>https://leecss.com/post/http-tong-yong-shou-bu-zi-duan/</id>
        <link href="https://leecss.com/post/http-tong-yong-shou-bu-zi-duan/">
        </link>
        <updated>2021-07-18T23:08:49.000Z</updated>
        <content type="html"><![CDATA[<h1 id="http-通用首部字段">http-通用首部字段</h1>
<h2 id="概述">概述</h2>
<p>通用首部字段是指，请求报文和响应报文双方都会使用的首部。</p>
<h2 id="列表">列表</h2>
<table>
<thead>
<tr>
<th>通用首部</th>
<th>作用（请求报文和响应报文都可能使用）</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cache-Control</td>
<td>控制缓存的行为</td>
</tr>
<tr>
<td>Connection</td>
<td>决定当前的事务完成后，是否会关闭网络连接</td>
</tr>
<tr>
<td>Date</td>
<td>创建报文时间</td>
</tr>
<tr>
<td>Pragma</td>
<td>只用于请求报文，客户端要求中间服务器不返回缓存的资源</td>
</tr>
<tr>
<td>Via</td>
<td>代理服务器相关信息，每经过一个代理服务器就会添加相关信息，用逗号分割</td>
</tr>
<tr>
<td>Transfer-Encoding</td>
<td>传输编码方式：<code>chunked</code>分块传输</td>
</tr>
<tr>
<td>Upgrade</td>
<td>要求客户端使用的升级协议，需配合<code>Connection: Upgrade</code>一起使用：<code>websocket</code></td>
</tr>
<tr>
<td>Warning</td>
<td>缓存相关问题的警告</td>
</tr>
</tbody>
</table>
<h3 id="cache-control">Cache-Control</h3>
<p>可缓存性</p>
<p><code>public</code>（客户端、代理服务器都可利用缓存）</p>
<p><code>private</code>（发起请求的浏览器才可以缓存,代理服务器不可用缓存）</p>
<p><code>no-cache</code>（本地可以用使用缓存，但需要服务器验证后才能使用）、</p>
<p>到期</p>
<p><code>max-age=200</code>（服务器缓存到期时间， 秒）</p>
<p><code>s-maxage=200</code> (代理服务器缓存的到期时间)</p>
<p>其他</p>
<p><code>no-store</code>（不做任何缓存）</p>
<h3 id="connection">Connection</h3>
<p>决定当前的事务完成后，是否会关闭网络连接。Http协议1.1之后默认都是keep-alive（持久连接），1.0则是close（非持久连接）。</p>
<pre><code>Connection: keep-alive
Connection: close
</code></pre>
<h3 id="date">Date</h3>
<p>标明HTTP报文的创建日期和时间。</p>
<pre><code>Date: Wed, 21 Oct 2015 07:28:00 GMT
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[http-首部字段]]></title>
        <id>https://leecss.com/post/http-shou-bu-zi-duan/</id>
        <link href="https://leecss.com/post/http-shou-bu-zi-duan/">
        </link>
        <updated>2021-07-18T04:59:53.000Z</updated>
        <content type="html"><![CDATA[<h2 id="http-首部字段结构">HTTP 首部字段结构</h2>
<p>HTTP 首部字段是由首部字段名和字段值构成的，中间用冒号“:” 分<br>
隔。</p>
<pre><code>首部字段名: 字段值
</code></pre>
<p>例如，在 HTTP 首部中以 Content-Type 这个字段来表示报文主体的 对<br>
象类型。</p>
<pre><code>Content-Type: text/html
</code></pre>
<p>就以上述示例来看，首部字段名为 Content-Type，字符串 text/html 是<br>
字段值。<br>
另外，字段值对应单个 HTTP 首部字段可以有多个值，如下所示。</p>
<pre><code>Keep-Alive: timeout=15, max=100
</code></pre>
<h2 id="4-种-http-首部字段类型">4 种 HTTP 首部字段类型</h2>
<p>HTTP 首部字段根据实际用途被分为以下 4 种类型。</p>
<h3 id="1-通用首部字段general-header-fields">1、通用首部字段（General Header Fields）</h3>
<p>请求报文和响应报文两方都会使用的首部。</p>
<h3 id="2-请求首部字段request-header-fields">2、请求首部字段（Request Header Fields）</h3>
<p>从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。</p>
<h3 id="3-响应首部字段response-header-fields">3、响应首部字段（Response Header Fields）</h3>
<p>从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。</p>
<h3 id="4-实体首部字段entity-header-fields">4、实体首部字段（Entity Header Fields）</h3>
<p>针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。</p>
<h2 id="http11-首部字段一览">HTTP/1.1 首部字段一览</h2>
<h3 id="通用首部字段">通用首部字段</h3>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cache-Control</td>
<td>控制缓存的行为</td>
</tr>
<tr>
<td>Connection</td>
<td>逐跳首部、连接的管理</td>
</tr>
<tr>
<td>Date</td>
<td>创建报文的日期时间</td>
</tr>
<tr>
<td>Pragma</td>
<td>报文指令</td>
</tr>
<tr>
<td>Trailer</td>
<td>报文末端的首部一览</td>
</tr>
<tr>
<td>Transfer-Encoding</td>
<td>指定报文主体的传输编码方式</td>
</tr>
<tr>
<td>Upgrade</td>
<td>升级为其他协议</td>
</tr>
<tr>
<td>Via</td>
<td>代理服务器的相关信息</td>
</tr>
<tr>
<td>Warning</td>
<td>错误通知</td>
</tr>
</tbody>
</table>
<h3 id="请求首部字段">请求首部字段</h3>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept</td>
<td>用户代理可处理的媒体类型</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>优先的字符集</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>优先的内容编码</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>优先的语言（自然语言）</td>
</tr>
<tr>
<td>Authorization Web</td>
<td>认证信息</td>
</tr>
<tr>
<td>Expect</td>
<td>期待服务器的特定行为</td>
</tr>
<tr>
<td>From</td>
<td>用户的电子邮箱地址</td>
</tr>
<tr>
<td>Host</td>
<td>请求资源所在服务器</td>
</tr>
<tr>
<td>If-Match</td>
<td>比较实体标记（ETag）</td>
</tr>
<tr>
<td>If-Modified-Since</td>
<td>比较资源的更新时间</td>
</tr>
<tr>
<td>If-None-Match</td>
<td>比较实体标记（与 If-Match 相反）</td>
</tr>
<tr>
<td>If-Range</td>
<td>资源未更新时发送实体 Byte 的范围请求</td>
</tr>
<tr>
<td>If-Unmodified-Since</td>
<td>比较资源的更新时间（与If-Modified-Since相反）</td>
</tr>
<tr>
<td>Max-Forwards</td>
<td>最大传输逐跳数</td>
</tr>
<tr>
<td>Proxy-Authorization</td>
<td>代理服务器要求客户端的认证信息</td>
</tr>
<tr>
<td>Range</td>
<td>实体的字节范围请求</td>
</tr>
<tr>
<td>Referer</td>
<td>对请求中 URI 的原始获取方</td>
</tr>
<tr>
<td>TE</td>
<td>传输编码的优先级</td>
</tr>
<tr>
<td>User-Agent HTTP</td>
<td>客户端程序的信息</td>
</tr>
</tbody>
</table>
<h3 id="响应首部字段">响应首部字段</h3>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept-Ranges</td>
<td>是否接受字节范围请求</td>
</tr>
<tr>
<td>Age</td>
<td>推算资源创建经过时间</td>
</tr>
<tr>
<td>ETag</td>
<td>资源的匹配信息</td>
</tr>
<tr>
<td>Location</td>
<td>令客户端重定向至指定URI</td>
</tr>
<tr>
<td>Proxy-Authenticate</td>
<td>代理服务器对客户端的认证信息</td>
</tr>
<tr>
<td>Retry-After</td>
<td>对再次发起请求的时机要求</td>
</tr>
<tr>
<td>Server HTTP</td>
<td>服务器的安装信息</td>
</tr>
<tr>
<td>Vary</td>
<td>代理服务器缓存的管理信息</td>
</tr>
<tr>
<td>WWW-Authenticate</td>
<td>服务器对客户端的认证信息</td>
</tr>
</tbody>
</table>
<h3 id="实体首部字段">实体首部字段</h3>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Allow</td>
<td>资源可支持的HTTP方法</td>
</tr>
<tr>
<td>Content-Encoding</td>
<td>实体主体适用的编码方式</td>
</tr>
<tr>
<td>Content-Language</td>
<td>实体主体的自然语言</td>
</tr>
<tr>
<td>Content-Length</td>
<td>实体主体的大小（单位：字节）</td>
</tr>
<tr>
<td>Content-Location</td>
<td>替代对应资源的URI</td>
</tr>
<tr>
<td>Content-MD5</td>
<td>实体主体的报文摘要</td>
</tr>
<tr>
<td>Content-Range</td>
<td>实体主体的位置范围</td>
</tr>
<tr>
<td>Content-Type</td>
<td>实体主体的媒体类型</td>
</tr>
<tr>
<td>Expires</td>
<td>实体主体过期的日期时间</td>
</tr>
<tr>
<td>Last-Modified</td>
<td>资源的最后修改日期时间</td>
</tr>
</tbody>
</table>
<h2 id="非-http11-首部字段">非 HTTP/1.1 首部字段</h2>
<p>在 HTTP 协议通信交互中使用到的首部字段，不限于 RFC2616 中定义的 47 种首部字段。还有 Cookie、Set-Cookie 和 Content-Disposition等在其他 RFC 中定义的首部字段，它们的使用频率也很高。</p>
<p>这些非正式的首部字段统一归纳在 RFC4229 HTTP Header Field Registrations 中。</p>
<h2 id="end-to-end-首部和-hop-by-hop-首部">End-to-end 首部和 Hop-by-hop 首部</h2>
<p>HTTP 首部字段将定义成缓存代理和非缓存代理的行为，分成 2 种类<br>
型。</p>
<h3 id="端到端首部end-to-end-header">端到端首部（End-to-end Header）</h3>
<p>分在此类别中的首部会转发给请求 / 响应对应的最终接收目标，且必须保存在由缓存生成的响应中，另外规定它必须被转发。</p>
<h3 id="逐跳首部hop-by-hop-header">逐跳首部（Hop-by-hop Header）</h3>
<p>分在此类别中的首部只对单次转发有效，会因通过缓存或代理而不再转发。HTTP/1.1 和之后版本中，如果要使用 hop-by-hop 首部，需提供 Connection 首部字段。</p>
<p>下面列举了 HTTP/1.1 中的逐跳首部字段。除这 8 个首部字段之外，其他所有字段都属于端到端首部。</p>
<ul>
<li>Connection</li>
<li>Keep-Alive</li>
<li>Proxy-Authenticate</li>
<li>Proxy-Authorization</li>
<li>Trailer</li>
<li>TE</li>
<li>Transfer-Encoding</li>
<li>Upgrade</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[electron-增量更新]]></title>
        <id>https://leecss.com/post/electron-zeng-liang-geng-xin/</id>
        <link href="https://leecss.com/post/electron-zeng-liang-geng-xin/">
        </link>
        <updated>2021-07-16T11:49:28.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>先介绍一下技术构成，项目是完整的vue项目，在现有项目上完成electron打包及更新。</p>
<p>打包使用的vue-cli-plugin-electron-builder插件，增量更新为具体的代码实现，并没有用到electron-updater。</p>
<h2 id="思路">思路</h2>
<p>1、比较本地和远程的版本</p>
<p>本地的版本可以放在一个app.txt文件中，或者通过变量获取。</p>
<p>远程的版本通过服务端文件（yml或者json）获取</p>
<p>比较版本，若相同则不更新，返回。</p>
<p>若不同，则提示更新，或直接进入更新流程</p>
<p>2、更新流程：通过线上增量包文件地址，进行下载</p>
<p>3、将zip压缩包解压缩</p>
<p>4、重新加载</p>
<h2 id="详解">详解</h2>
<h3 id="一-vue-cli-plugin-electron-builder">一、vue-cli-plugin-electron-builder</h3>
<p>安装vue-cli-plugin-electron-builder</p>
<pre><code>vue add electron-builder@2.0.0-rc.6
</code></pre>
<p>版本选择9.0.0</p>
<h2 id="二-新建vueconfigjs">二、新建vue.config.js</h2>
<p>1、重点是：<strong>&quot;asar&quot;: false,</strong></p>
<p>这句话的意思是，打包的时候<code>resources</code>下就不产生<code>app.asar</code>，而是一个app文件夹，而这个文件夹呢是可以直接进行替换的，里面的内容就是我们的前端整个项目的打包，就是渲染进程。所以，我们每次只需要替换前端的打包就可以了，而不需要每次都安装替换整个app</p>
<p>2、将app图标放到public文件夹下</p>
<pre><code class="language-js">module.exports = {
  pluginOptions: {
    electronBuilder: {
      builderOptions: {
        //productName: &quot;ebopo&quot;, // 项目名,这也是生成的exe文件的前缀名
        copyright: 'Copyright © Ambow',  // 应用程序版权行
        publish: [{
          &quot;provider&quot;: &quot;generic&quot;,
          &quot;channel&quot;: &quot;latest&quot;,
          &quot;url&quot;: &quot;http://ambow-ebopo.oss-cn-beijing.aliyuncs.com/common/electron/&quot;,
        }],
        &quot;win&quot;: {//win相关配置
          &quot;icon&quot;: &quot;./public/app.ico&quot;,//图标，当前图标在根目录下，注意这里有两个坑
          &quot;target&quot;: [
              {
                  &quot;target&quot;: &quot;nsis&quot;,//利用nsis制作安装程序
                  &quot;arch&quot;: [
                      &quot;x64&quot;,//64位
                      &quot;ia32&quot;//32位
                  ]
              }
          ]
        },
        &quot;asar&quot;: false,
        &quot;nsis&quot;: {
          &quot;oneClick&quot;: false, // 是否一键安装
          &quot;allowElevation&quot;: true, // 允许请求提升。 如果为false，则用户必须使用提升的权限重新启动安装程序。          
          &quot;allowToChangeInstallationDirectory&quot;: true, // 允许修改安装目录
          &quot;installerIcon&quot;: &quot;./public/app.ico&quot;,// 安装图标
          &quot;uninstallerIcon&quot;: &quot;./public/app.ico&quot;,//卸载图标
          &quot;installerHeaderIcon&quot;: &quot;./public/app.ico&quot;, // 安装时头部图标
          &quot;createDesktopShortcut&quot;: true, // 创建桌面图标
          &quot;createStartMenuShortcut&quot;: true,// 创建开始菜单图标
          &quot;shortcutName&quot;: &quot;ebopo&quot;, // 图标名称
        },
      }
    }
  }
}
</code></pre>
<h2 id="三-配置信息">三、配置信息</h2>
<p>background.js</p>
<pre><code class="language-js">
let win

function createWindow() {
  win = new BrowserWindow({
    width: 800,
    height: 600,     
    icon: `${__static}/app.ico`, // app内左上角图标
    webPreferences: {
      webSecurity: false, //取消跨域限制
      nodeIntegration:true, //开启node
    }
  })
}
</code></pre>
<p>package.json</p>
<pre><code class="language-js">// 打包exe前缀名称,及项目内左上角显示名称
&quot;name&quot;: &quot;ebopo&quot;,
// 版本号
&quot;version&quot;: &quot;1.0.0&quot;,
&quot;author&quot;: &quot;leecss&quot;,
&quot;description&quot;: &quot;electronApp&quot;,
</code></pre>
<h2 id="四-新增electron目录及设置菜单">四、新增electron目录及设置菜单</h2>
<p>在src文件夹下新建electron目录，在目录中新建menu.js</p>
<pre><code class="language-js">import { BrowserWindow, Menu, app} from 'electron'

let template = [{
  label: '查看',
  submenu: [{
    label: '重载',
    accelerator: 'CmdOrCtrl+R',
    click: (item, focusedWindow) =&gt; {
      if (focusedWindow) {
        // 重载之后, 刷新并关闭所有之前打开的次要窗体
        if (focusedWindow.id === 1) {
          BrowserWindow.getAllWindows().forEach(win =&gt; {
            if (win.id &gt; 1) win.close()
          })
        }
        focusedWindow.reload()
      }
    }
  }, {
    label: '切换全屏',
    accelerator: (() =&gt; {
      if (process.platform === 'darwin') {
        return 'Ctrl+Command+F'
      } else {
        return 'F11'
      }
    })(),
    click: (item, focusedWindow) =&gt; {
      if (focusedWindow) {
        focusedWindow.setFullScreen(!focusedWindow.isFullScreen())
      }
    }
  }]
}, {
  label: '窗口',
  role: 'window',
  submenu: [{
    label: '最小化',
    accelerator: 'CmdOrCtrl+M',
    role: 'minimize'
  }, {
    label: '关闭',
    accelerator: 'CmdOrCtrl+W',
    role: 'close'
  }]
}, {
  label: '帮助',
  role: 'help',
  submenu: [     
    {
      label: `版本` + app.getVersion(),
      enabled: false      
    },
    {
      label: '切换开发者工具',
      accelerator: (() =&gt; {
        if (process.platform === 'darwin') {
          return 'Alt+Command+I'
        } else {
          return 'Ctrl+Shift+I'
        }
      })(),
      click: (item, focusedWindow) =&gt; {
        if (focusedWindow) {
          focusedWindow.toggleDevTools()
        }
      }
    }
  ]
}]

var list = Menu.buildFromTemplate(template)
Menu.setApplicationMenu(list)
</code></pre>
<p>修改background.js ，在主进程中引入菜单</p>
<pre><code class="language-js">async function createWindow() {
+	require('./electron/menu.js')
}
</code></pre>
<h2 id="五-添加调试及日志文件输出">五、添加调试及日志文件输出</h2>
<pre><code>npm i  electron-log
</code></pre>
<p>在electron目录下新建log.js</p>
<pre><code class="language-js">import log from 'electron-log'

log.transports.file.level = 'silly'
log.transports.console.level = false // 禁用console输出

export default log
</code></pre>
<p>在background.js 中使用</p>
<pre><code class="language-js">import log from './electron/log'

log.warn('hello')
</code></pre>
<p>日志文件查看：文件main.log存储位置</p>
<pre><code>C:\Users\{用户}\AppData\Roaming\{appName}\logs
</code></pre>
<h2 id="六-更新流程比较版本">六、更新流程：比较版本</h2>
<p>安装并引入axios</p>
<pre><code>npm i axios
</code></pre>
<p>background.js</p>
<pre><code>import axios from 'axios'
</code></pre>
<p>比较版本，若相同则返回，不相同则更新</p>
<pre><code>async function createWindow() {
  require('./electron/menu.js')
  // Create the browser window.
  win = new BrowserWindow({
    width: 800,
    height: 600,
    icon: `${__static}/app.ico`, // app内左上角图标
    webPreferences: {      
      webSecurity: false, //取消跨域限制
      nodeIntegration:true, //开启node
    }
  })

  if (process.env.WEBPACK_DEV_SERVER_URL) {
    // Load the url of the dev server if in development mode
    await win.loadURL(process.env.WEBPACK_DEV_SERVER_URL)
    if (!process.env.IS_TEST) win.webContents.openDevTools()
  } else {
    createProtocol('app')
    // Load the index.html when not in development
    win.loadURL('app://./index.html')
    
    
    
    log.warn('hello')
    // 判断是否热更新，版本对比
    const updateUrl = 'http://ambow-ebopo.oss-cn-beijing.aliyuncs.com/common/electron'
    const currentVersion = app.getVersion()
    log.warn('currentVersion',currentVersion)    
    axios({
      url: updateUrl + '/latest.yml',
      method: 'GET'
    }).then(res =&gt; {      
      const remoteVersion = JSON.stringify(res.data).split('\\n')[0].split(' ')[1]
      log.warn('remoteVersion',remoteVersion)      
      if (currentVersion === remoteVersion) {
        log.warn('版本相同，无需更新')
        return;
      }
      // 热更新
      const updateZipUrl = updateUrl + '/app.zip'
      increment(updateZipUrl)      
    })
    
    
    
  }
}
</code></pre>
<h2 id="七-更新流程下载远程更新包appzip">七、更新流程：下载远程更新包app.zip</h2>
<p>在electron目录中新建downloadFile.js</p>
<p>下载文件需要两个参数：下载路径，保存路径</p>
<p>下载文件返回一个参数：保存路径</p>
<p>安装fs-extra</p>
<pre><code>npm i fs-extra
</code></pre>
<pre><code class="language-js">const request = require('request')
const fs = require('fs')
const fse = require('fs-extra')
const path = require('path')
import log from './log'

function download(url, targetPath, cb = () =&gt; { }) {
  let status
  const req = request({
    method: 'GET',
    uri: encodeURI(url)
  })
  try {
    const stream = fs.createWriteStream(targetPath)
    let len = 0
    let cur = 0
    req.pipe(stream)
    req.on('response', (data) =&gt; {
      len = parseInt(data.headers['content-length'])
    })
    req.on('data', (chunk) =&gt; {
      cur += chunk.length
      const progress = (100 * cur / len).toFixed(2)
      status = 'progressing'
      cb(status, progress)
    })
    req.on('end', function () {
      if (req.response.statusCode === 200) {
        if (len === cur) {
          console.log(targetPath + ' Download complete ')
          status = 'completed'
          cb(status, 100)
        } else {
          stream.end()
          removeFile(targetPath)
          status = 'error'
          cb(status, '网络波动，下载文件不全')
        }
      } else {
        stream.end()
        removeFile(targetPath)
        status = 'error'
        cb(status, req.response.statusMessage)
      }
    })
    req.on('error', (e) =&gt; {
      stream.end()
      removeFile(targetPath)
      if (len !== cur) {
        status = 'error'
        cb(status, '网络波动，下载失败')
      } else {
        status = 'error'
        cb(status, e)
      }
    })
  } catch (error) {
    console.log(error)
  }
}

function removeFile(targetPath) {
  try {
    fse.removeSync(targetPath)
  } catch (error) {
    console.log(error)
  }
}

export default async function downloadFile({ url, targetPath, folder = './' }, cb = () =&gt; { }) {  
  log.warn('download-url',url)
  log.warn('download-saveurl',targetPath)
  if (!targetPath || !url) {
    throw new Error('targetPath or url is nofind')
  }
  try {
    await fse.ensureDirSync(path.join(targetPath, folder))
  } catch (error) {
    throw new Error(error)
  }
  return new Promise((resolve, reject) =&gt; {
    const name = url.split('/').pop()
    const filePath = path.join(targetPath, folder, name)
    download(url, filePath, (status, result) =&gt; {
      if (status === 'completed') {
        resolve(filePath)
      }
      if (status === 'error') {
        reject(result)
      }
      if (status === 'progressing') {
        cb &amp;&amp; cb(result)
      }
    })
  })
}
</code></pre>
<h2 id="八-更新流程将下载的appzip解压缩并删除">八、更新流程：将下载的app.zip解压缩并删除</h2>
<p>在electron目录中新建increment.js</p>
<p>解压缩需要一个参数：加压压缩包的路径</p>
<p>在文件下载完成后执行</p>
<p>安装adm-zip</p>
<pre><code>npm i adm-zip
</code></pre>
<pre><code class="language-js">import downloadFile from './downloadFile'
import { app } from 'electron'
const fse = require('fs-extra')
const AdmZip = require('adm-zip')
import log from './log'

export default async (updateZipUrl) =&gt; {  
  const resourcesPath = process.resourcesPath
  downloadFile({ url: updateZipUrl, targetPath: resourcesPath }).then(async (filePath) =&gt; {
    log.warn('unzip-filePath',filePath)
    const zip = new AdmZip(filePath)
    zip.extractAllToAsync(resourcesPath, true, (err) =&gt; {
      if (err) {
        console.error(err)
        return
      }      
      fse.removeSync(filePath)      
      setTimeout(() =&gt; {
        log.warn('relaunch')
        app.relaunch()
        app.exit(0)                
      }, 2000);
    })
  }).catch(err =&gt; {
    console.log(err)
  })
}
</code></pre>
<p>在background.js引入并调用</p>
<pre><code class="language-js">import increment from './electron/increment'
</code></pre>
<pre><code class="language-js">// 热更新
const updateZipUrl = updateUrl + '/app.zip'
increment(updateZipUrl)
</code></pre>
<h2 id="九-更新流程将更新重启替换为重新加载">九、更新流程：将更新重启替换为重新加载</h2>
<p>在electron目录下新建global.js</p>
<pre><code class="language-js">global.sharedObject = {
  win: ''
}

export default global
</code></pre>
<p>在background.js引入并调用</p>
<pre><code>import global from './electron/global'
</code></pre>
<pre><code class="language-js">async function createWindow() {
  require('./electron/menu.js')
  // Create the browser window.
  win = new BrowserWindow({
    width: 800,
    height: 600,
    icon: `${__static}/app.ico`, // app内左上角图标
    webPreferences: {      
      webSecurity: false, //取消跨域限制
      nodeIntegration:true, //开启node
    }
  })

  if (process.env.WEBPACK_DEV_SERVER_URL) {
    // Load the url of the dev server if in development mode
    await win.loadURL(process.env.WEBPACK_DEV_SERVER_URL)
    if (!process.env.IS_TEST) win.webContents.openDevTools()
  } else {
    createProtocol('app')
    // Load the index.html when not in development
    win.loadURL('app://./index.html')

    log.warn('hello')
    // 判断是否热更新，版本对比
    const updateUrl = 'http://ambow-ebopo.oss-cn-beijing.aliyuncs.com/common/electron'
    const currentVersion = app.getVersion()
    log.warn('currentVersion',currentVersion)    
    axios({
      url: updateUrl + '/latest.yml',
      method: 'GET'
    }).then(res =&gt; {      
      const remoteVersion = JSON.stringify(res.data).split('\\n')[0].split(' ')[1]
      log.warn('remoteVersion',remoteVersion)      
      if (currentVersion === remoteVersion) {
        log.warn('版本相同，无需更新')
        return;
      }
      // 热更新
      const updateZipUrl = updateUrl + '/app.zip'
      increment(updateZipUrl)      
    })

  }



  global.sharedObject.win = win
  win.on('closed', () =&gt; {
    win = null
    global.sharedObject.win = null
  })


  
}
</code></pre>
<p>在increment.js中引入并调用</p>
<pre><code class="language-js">import downloadFile from './downloadFile'
import global from './global'
const fse = require('fs-extra')
const AdmZip = require('adm-zip')
import log from './log'

export default async (updateZipUrl) =&gt; {  
  const resourcesPath = process.resourcesPath
  downloadFile({ url: updateZipUrl, targetPath: resourcesPath }).then(async (filePath) =&gt; {
    log.warn('unzip-filePath',filePath)
    const zip = new AdmZip(filePath)
    zip.extractAllToAsync(resourcesPath, true, (err) =&gt; {
      if (err) {
        console.error(err)
        return
      }      
      fse.removeSync(filePath)      
      setTimeout(() =&gt; {        
        log.warn('relaunch')
        global.sharedObject.win.webContents.reloadIgnoringCache()          
      }, 2000);
    })
  }).catch(err =&gt; {
    console.log(err)
  })
}
</code></pre>
<p>setTimeout是为了演示效果，最后去掉。</p>
<h2 id="十-遇到的问题">十、遇到的问题</h2>
<p>更新时报错，如下：</p>
<pre><code>Error: EPERM: operation not permitted
</code></pre>
<p>原因是没有管理员权限，且安装时选择的为所有用户安装。</p>
<p>方案一：运行时选择：以管理员身份运行</p>
<p>方案二：下载时，仅为当前用户安装</p>
<p>解决方案：</p>
<p>在设置上，不给用户选择为所有用户安装的机会，默认一键安装，设置如下</p>
<pre><code class="language-json">&quot;nsis&quot;: {
    &quot;oneClick&quot;: true, // 是否一键安装          
    &quot;installerIcon&quot;: &quot;./public/app.ico&quot;,// 安装图标
    &quot;uninstallerIcon&quot;: &quot;./public/app.ico&quot;,//卸载图标
    &quot;installerHeaderIcon&quot;: &quot;./public/app.ico&quot;, // 安装时头部图标
    &quot;createDesktopShortcut&quot;: true, // 创建桌面图标
    &quot;createStartMenuShortcut&quot;: true,// 创建开始菜单图标
    &quot;shortcutName&quot;: &quot;ebopo&quot;, // 图标名称
},
</code></pre>
<h2 id="十一-在ts项目中使用">十一、在ts项目中使用</h2>
<p>electron-log的使用要用ts文件，并且用any声明，其他相似问题同理。</p>
<p>log.ts</p>
<pre><code class="language-typescript">const log:any = require('electron-log');

log.transports.file.level = 'silly'
log.transports.console.level = false // 禁用console输出

export default log
</code></pre>
<h2 id="github地址">GitHub地址</h2>
<p><a href="https://github.com/lee-css/vue-cli-electron-update-part">vue-cli-electron-update-part</a></p>
<h2 id="参考">参考</h2>
<p><a href="https://xuxin123.com/electron/increment-update1/">https://xuxin123.com/electron/increment-update1/</a></p>
<h2 id="文档">文档</h2>
<p><a href="https://nklayman.github.io/vue-cli-plugin-electron-builder/">https://nklayman.github.io/vue-cli-plugin-electron-builder/</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[http-XMLHttpRequest Level2]]></title>
        <id>https://leecss.com/post/http-xmlhttprequest-level2/</id>
        <link href="https://leecss.com/post/http-xmlhttprequest-level2/">
        </link>
        <updated>2021-07-15T22:49:03.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p><a href="https://en.wikipedia.org/wiki/XMLHttpRequest">XMLHttpRequest</a>是一个浏览器接口，使得Javascript可以进行HTTP(S)通信。</p>
<p>最早，微软在IE 5引进了这个接口。因为它太有用，其他浏览器也模仿部署了，ajax操作因此得以诞生。</p>
<p>但是，这个接口一直没有标准化，每家浏览器的实现或多或少有点不同。HTML 5的概念形成后，W3C开始考虑标准化这个接口。2008年2月，就提出了<a href="https://dev.w3.org/2006/webapi/XMLHttpRequest-2/">XMLHttpRequest Level 2</a> 草案。</p>
<h2 id="一-老版本的xmlhttprequest对象"><strong>一、老版本的XMLHttpRequest对象</strong></h2>
<p>在介绍新版本之前，我们先回顾一下老版本的用法。</p>
<p>首先，新建一个XMLHttpRequest的实例。</p>
<blockquote>
<p>var xhr = new XMLHttpRequest();</p>
</blockquote>
<p>然后，向远程主机发出一个HTTP请求。</p>
<blockquote>
<p>xhr.open('GET', 'example.php');</p>
<p>xhr.send();</p>
</blockquote>
<p>接着，就等待远程主机做出回应。这时需要监控XMLHttpRequest对象的状态变化，指定回调函数。</p>
<blockquote>
<p>xhr.onreadystatechange = function(){</p>
<p>if ( xhr.readyState == 4 &amp;&amp; xhr.status == 200 ) {</p>
<p>alert( xhr.responseText );</p>
<p>} else {</p>
<p>alert( xhr.statusText );</p>
<p>}</p>
<p>};</p>
</blockquote>
<p>上面的代码包含了老版本XMLHttpRequest对象的主要属性：</p>
<blockquote>
<p>* xhr.readyState：XMLHttpRequest对象的状态，等于4表示数据已经接收完毕。</p>
<p>* xhr.status：服务器返回的状态码，等于200表示一切正常。</p>
<p>* xhr.responseText：服务器返回的文本数据</p>
<p>* xhr.responseXML：服务器返回的XML格式的数据</p>
<p>* xhr.statusText：服务器返回的状态文本。</p>
</blockquote>
<h2 id="二-老版本的缺点"><strong>二、老版本的缺点</strong></h2>
<p>老版本的XMLHttpRequest对象有以下几个缺点：</p>
<blockquote>
<p>* 只支持文本数据的传送，无法用来读取和上传二进制文件。</p>
<p>* 传送和接收数据时，没有进度信息，只能提示有没有完成。</p>
<p>* 受到<a href="https://www.w3.org/Security/wiki/Same_Origin_Policy">&quot;同域限制&quot;</a>（Same Origin Policy），只能向同一域名的服务器请求数据。</p>
</blockquote>
<h2 id="三-新版本的功能"><strong>三、新版本的功能</strong></h2>
<p>新版本的XMLHttpRequest对象，针对老版本的缺点，做出了大幅改进。</p>
<blockquote>
<p>* 可以设置HTTP请求的时限。</p>
<p>* 可以使用FormData对象管理表单数据。</p>
<p>* 可以上传文件。</p>
<p>* 可以请求不同域名下的数据（跨域请求）。</p>
<p>* 可以获取服务器端的二进制数据。</p>
<p>* 可以获得数据传输的进度信息。</p>
</blockquote>
<p>下面，我就一一介绍这些新功能。</p>
<h2 id="四-http请求的时限"><strong>四、HTTP请求的时限</strong></h2>
<p>有时，ajax操作很耗时，而且无法预知要花多少时间。如果网速很慢，用户可能要等很久。</p>
<p>新版本的XMLHttpRequest对象，增加了timeout属性，可以设置HTTP请求的时限。</p>
<blockquote>
<p>xhr.timeout = 3000;</p>
</blockquote>
<p>上面的语句，将最长等待时间设为3000毫秒。过了这个时限，就自动停止HTTP请求。与之配套的还有一个timeout事件，用来指定回调函数。</p>
<blockquote>
<p>xhr.ontimeout = function(event){</p>
<p>alert('请求超时！');</p>
<p>}</p>
</blockquote>
<p>目前，Opera、Firefox和IE 10支持该属性，IE 8和IE 9的这个属性属于XDomainRequest对象，而Chrome和Safari还不支持。</p>
<h2 id="五-formdata对象"><strong>五、FormData对象</strong></h2>
<p>ajax操作往往用来传递表单数据。为了方便表单处理，HTML 5新增了一个FormData对象，可以模拟表单。</p>
<p>首先，新建一个FormData对象。</p>
<blockquote>
<p>var formData = new FormData();</p>
</blockquote>
<p>然后，为它添加表单项。</p>
<blockquote>
<p>formData.append('username', '张三');</p>
<p>formData.append('id', 123456);</p>
</blockquote>
<p>最后，直接传送这个FormData对象。这与提交网页表单的效果，完全一样。</p>
<blockquote>
<p>xhr.send(formData);</p>
</blockquote>
<p>FormData对象也可以用来获取网页表单的值。</p>
<blockquote>
<p>var form = document.getElementById('myform');</p>
<p>var formData = new FormData(form);</p>
<p>formData.append('secret', '123456'); // 添加一个表单项</p>
<p>xhr.open('POST', form.action);</p>
<p>xhr.send(formData);</p>
</blockquote>
<h2 id="六-上传文件"><strong>六、上传文件</strong></h2>
<p>新版XMLHttpRequest对象，不仅可以发送文本信息，还可以上传文件。</p>
<p>假定files是一个&quot;选择文件&quot;的表单元素（input[type=&quot;file&quot;]），我们将它装入FormData对象。</p>
<blockquote>
<p>var formData = new FormData();</p>
<p>for (var i = 0; i &lt; files.length;i++) {</p>
<p>formData.append('files[]', files[i]);</p>
<p>}</p>
</blockquote>
<p>然后，发送这个FormData对象。</p>
<blockquote>
<p>xhr.send(formData);</p>
</blockquote>
<h2 id="七-跨域资源共享cors"><strong>七、跨域资源共享（CORS）</strong></h2>
<p>新版本的XMLHttpRequest对象，可以向不同域名的服务器发出HTTP请求。这叫做<a href="https://en.wikipedia.org/wiki/Cross-Origin_Resource_Sharing">&quot;跨域资源共享&quot;</a>（Cross-origin resource sharing，简称CORS）。</p>
<p>使用&quot;跨域资源共享&quot;的前提，是浏览器必须支持这个功能，而且服务器端必须同意这种&quot;跨域&quot;。如果能够满足上面的条件，则代码的写法与不跨域的请求完全一样。</p>
<blockquote>
<p>xhr.open('GET', 'http://other.server/and/path/to/script');</p>
</blockquote>
<p>目前，除了IE 8和IE 9，主流浏览器都支持CORS，IE 10也将支持这个功能。服务器端的设置，请参考<a href="https://developer.mozilla.org/en-US/docs/Server-Side_Access_Control">《Server-Side Access Control》</a>。</p>
<h2 id="八-接收二进制数据方法a改写mimetype"><strong>八、接收二进制数据（方法A：改写MIMEType）</strong></h2>
<p>老版本的XMLHttpRequest对象，只能从服务器取回文本数据（否则它的名字就不用XML起首了），新版则可以取回二进制数据。</p>
<p>这里又分成两种做法。较老的做法是改写数据的MIMEType，将服务器返回的二进制数据伪装成文本数据，并且告诉浏览器这是用户自定义的字符集。</p>
<blockquote>
<p>xhr.overrideMimeType(&quot;text/plain; charset=x-user-defined&quot;);</p>
</blockquote>
<p>然后，用responseText属性接收服务器返回的二进制数据。</p>
<blockquote>
<p>var binStr = xhr.responseText;</p>
</blockquote>
<p>由于这时，浏览器把它当做文本数据，所以还必须再一个个字节地还原成二进制数据。</p>
<blockquote>
<p>for (var i = 0, len = binStr.length; i &lt; len; ++i) {</p>
<p>var c = binStr.charCodeAt(i);</p>
<p>var byte = c &amp; 0xff;</p>
<p>}</p>
</blockquote>
<p>最后一行的位运算&quot;c &amp; 0xff&quot;，表示在每个字符的两个字节之中，只保留后一个字节，将前一个字节扔掉。原因是浏览器解读字符的时候，会把字符自动<a href="https://web.archive.org/web/20080821092906/http://mgran.blogspot.com/2006/08/downloading-binary-streams-with.html">解读</a>成Unicode的0xF700-0xF7ff区段。</p>
<h2 id="八-接收二进制数据方法bresponsetype属性"><strong>八、接收二进制数据（方法B：responseType属性）</strong></h2>
<p>从服务器取回二进制数据，较新的方法是使用新增的responseType属性。如果服务器返回文本数据，这个属性的值是&quot;TEXT&quot;，这是默认值。较新的浏览器还支持其他值，也就是说，可以接收其他格式的数据。</p>
<p>你可以把responseType设为blob，表示服务器传回的是二进制对象。</p>
<blockquote>
<p>var xhr = new XMLHttpRequest();</p>
<p>xhr.open('GET', '/path/to/image.png');</p>
<p>xhr.responseType = 'blob';</p>
</blockquote>
<p>接收数据的时候，用浏览器自带的Blob对象即可。</p>
<blockquote>
<p>var blob = new Blob([xhr.response], {type: 'image/png'});</p>
</blockquote>
<p>注意，是读取xhr.response，而不是xhr.responseText。</p>
<p>你还可以将responseType设为arraybuffer，把二进制数据装在一个数组里。</p>
<blockquote>
<p>var xhr = new XMLHttpRequest();</p>
<p>xhr.open('GET', '/path/to/image.png');</p>
<p>xhr.responseType = &quot;arraybuffer&quot;;</p>
</blockquote>
<p>接收数据的时候，需要遍历这个数组。</p>
<blockquote>
<p>var arrayBuffer = xhr.response;</p>
<p>if (arrayBuffer) {</p>
<p>var byteArray = new Uint8Array(arrayBuffer);</p>
<p>for (var i = 0; i &lt; byteArray.byteLength; i++) {</p>
<p>// do something</p>
<p>}<br>
　　}</p>
</blockquote>
<p>更详细的讨论，请看<a href="https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest/Sending_and_Receiving_Binary_Data">Sending and Receiving Binary Data</a>。</p>
<h2 id="九-进度信息"><strong>九、进度信息</strong></h2>
<p>新版本的XMLHttpRequest对象，传送数据的时候，有一个progress事件，用来返回进度信息。</p>
<p>它分成上传和下载两种情况。下载的progress事件属于XMLHttpRequest对象，上传的progress事件属于XMLHttpRequest.upload对象。</p>
<p>我们先定义progress事件的回调函数。</p>
<blockquote>
<p>xhr.onprogress = updateProgress;</p>
<p>xhr.upload.onprogress = updateProgress;</p>
</blockquote>
<p>然后，在回调函数里面，使用这个事件的一些属性。</p>
<blockquote>
<p>function updateProgress(event) {</p>
<p>if (event.lengthComputable) {</p>
<p>var percentComplete = event.loaded / event.total;</p>
<p>}</p>
<p>}</p>
</blockquote>
<p>上面的代码中，event.total是需要传输的总字节，event.loaded是已经传输的字节。如果event.lengthComputable不为真，则event.total等于0。</p>
<p>与progress事件相关的，还有其他五个事件，可以分别指定回调函数：</p>
<blockquote>
<p>* load事件：传输成功完成。</p>
<p>* abort事件：传输被用户取消。</p>
<p>* error事件：传输中出现错误。</p>
<p>* loadstart事件：传输开始。</p>
<p>* loadEnd事件：传输结束，但是不知道成功还是失败。</p>
</blockquote>
<h2 id="十-阅读材料"><strong>十、阅读材料</strong></h2>
<p>1. <a href="https://dev.opera.com/articles/view/xhr2/">Introduction to XMLHttpRequest Level 2</a>： 新功能的综合介绍。</p>
<p>2. <a href="https://www.html5rocks.com/en/tutorials/file/xhr2/">New Tricks in XMLHttpRequest 2</a>：一些用法的介绍。</p>
<p>3. <a href="https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest/Using_XMLHttpRequest">Using XMLHttpRequest</a>：一些高级用法，主要针对Firefox浏览器。</p>
<p>4. <a href="https://developer.mozilla.org/en-US/docs/HTTP_access_control">HTTP Access Control</a>：CORS综述。</p>
<p>5. <a href="https://dev.opera.com/articles/view/dom-access-control-using-cross-origin-resource-sharing/">DOM access control using cross-origin resource sharing</a>：CORS的9种HTTP头信息</p>
<p>6. <a href="https://developer.mozilla.org/en-US/docs/Server-Side_Access_Control">Server-Side Access Control</a>：服务器端CORS设置。</p>
<p>7. <a href="http://enable-cors.org/">Enable CORS</a>：服务端CORS设置。</p>
<h2 id="转载">转载</h2>
<blockquote>
<p>阮一峰</p>
<p><a href="http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html">http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html</a></p>
</blockquote>
<h2 id="推荐阅读">推荐阅读</h2>
<p><a href="https://www.html5rocks.com/zh/tutorials/file/xhr2/">https://www.html5rocks.com/zh/tutorials/file/xhr2/</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[http-XMLHttpRequest]]></title>
        <id>https://leecss.com/post/http-xmlhttprequest/</id>
        <link href="https://leecss.com/post/http-xmlhttprequest/">
        </link>
        <updated>2021-07-15T14:49:23.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>XMLHttpRequest详解</p>
<h2 id="ajax和xmlhttprequest"><code>Ajax</code>和<code>XMLHttpRequest</code></h2>
<p>我们通常将<code>Ajax</code>等同于<code>XMLHttpRequest</code>，但细究起来它们两个是属于不同维度的2个概念。</p>
<blockquote>
<p>以下是我认为对<code>Ajax</code>较为准确的解释：（摘自<a href="https://link.segmentfault.com/?url=http%3A%2F%2Fwww.tutorialspoint.com%2Fajax%2Fwhat_is_ajax.htm">what is Ajax</a>）<br>
AJAX stands for Asynchronous JavaScript and XML. AJAX is a new technique for creating better, faster, and more interactive web applications with the help of XML, HTML, CSS, and Java Script.</p>
<p>AJAX is based on the following open standards:</p>
<ul>
<li>Browser-based presentation using HTML and Cascading Style Sheets (CSS).</li>
<li>Data is stored in XML format and fetched from the server.</li>
<li>Behind-the-scenes data fetches using XMLHttpRequest objects in the browser.</li>
<li>JavaScript to make everything happen.</li>
</ul>
</blockquote>
<p>从上面的解释中可以知道：<code>ajax</code>是一种技术方案，但并不是一种<strong>新技术</strong>。它依赖的是现有的<code>CSS</code>/<code>HTML</code>/<code>Javascript</code>，而其中最核心的依赖是浏览器提供的<code>XMLHttpRequest</code>对象，是这个对象使得浏览器可以发出<code>HTTP</code>请求与接收<code>HTTP</code>响应。</p>
<p>所以我用一句话来总结两者的关系：我们使用<code>XMLHttpRequest</code>对象来发送一个<code>Ajax</code>请求。</p>
<h2 id="xmlhttprequest的发展历程"><code>XMLHttpRequest</code>的发展历程</h2>
<p><code>XMLHttpRequest</code>一开始只是微软浏览器提供的一个接口，后来各大浏览器纷纷效仿也提供了这个接口，再后来W3C对它进行了标准化，提出了<a href="https://link.segmentfault.com/?url=https%3A%2F%2Fwww.w3.org%2FTR%2FXMLHttpRequest%2F"><code>XMLHttpRequest</code>标准</a>。<code>XMLHttpRequest</code>标准又分为<code>Level 1</code>和<code>Level 2</code>。<br>
<code>XMLHttpRequest Level 1</code>主要存在以下缺点：</p>
<ul>
<li>受同源策略的限制，不能发送跨域请求；</li>
<li>不能发送二进制文件（如图片、视频、音频等），只能发送纯文本数据；</li>
<li>在发送和获取数据的过程中，无法实时获取进度信息，只能判断是否完成；</li>
</ul>
<p>那么<code>Level 2</code>对<code>Level 1</code> 进行了改进，<code>XMLHttpRequest Level 2</code>中新增了以下功能：</p>
<ul>
<li>可以发送跨域请求，在服务端允许的情况下；</li>
<li>支持发送和接收二进制数据；</li>
<li>新增formData对象，支持发送表单数据；</li>
<li>发送和获取数据时，可以获取进度信息；</li>
<li>可以设置请求的超时时间；</li>
</ul>
<h2 id="xmlhttprequest兼容性"><code>XMLHttpRequest</code>兼容性</h2>
<p>关于<code>xhr</code>的浏览器兼容性，大家可以直接查看“Can I use”这个网站提供的结果<a href="https://link.segmentfault.com/?url=http%3A%2F%2Fcaniuse.com%2F%23search%3DXMLHttpRequest">XMLHttpRequest兼容性</a>，下面提供一个截图。</p>
<figure data-type="image" tabindex="1"><img src="https://leecss.com/post-images/1626360606163.png" alt="" loading="lazy"></figure>
<p>从图中可以看到：</p>
<ul>
<li>IE8/IE9、Opera Mini 完全不支持<code>xhr</code>对象</li>
<li>IE10/IE11部分支持，不支持 <code>xhr.responseType</code>为<code>json</code></li>
<li>部分浏览器不支持设置请求超时，即无法使用<code>xhr.timeout</code></li>
<li>部分浏览器不支持<code>xhr.responseType</code>为<code>blob</code></li>
</ul>
<h2 id="细说xmlhttprequest如何使用">细说<code>XMLHttpRequest</code>如何使用</h2>
<p>先来看一段使用<code>XMLHttpRequest</code>发送<code>Ajax</code>请求的简单示例代码。</p>
<pre><code class="language-js">function sendAjax() {
  //构造表单数据
  var formData = new FormData();
  formData.append('username', 'johndoe');
  formData.append('id', 123456);
  //创建xhr对象 
  var xhr = new XMLHttpRequest();
  //设置xhr请求的超时时间
  xhr.timeout = 3000;
  //设置响应返回的数据格式
  xhr.responseType = &quot;text&quot;;
  //创建一个 post 请求，采用异步
  xhr.open('POST', '/server', true);
  //注册相关事件回调处理函数
  xhr.onload = function(e) { 
    if(this.status == 200||this.status == 304){
        alert(this.responseText);
    }
  };
  xhr.ontimeout = function(e) { ... };
  xhr.onerror = function(e) { ... };
  xhr.upload.onprogress = function(e) { ... };
  
  //发送数据
  xhr.send(formData);
}
</code></pre>
<p>上面是一个使用<code>xhr</code>发送表单数据的示例，整个流程可以参考注释。</p>
<p>接下来我将站在使用者的角度，以问题的形式介绍<code>xhr</code>的基本使用。<br>
我对每一个问题涉及到的知识点都会进行比较细致地介绍，有些知识点可能是你平时忽略关注的。</p>
<h3 id="如何设置request-header">如何设置request header</h3>
<p>在发送<code>Ajax</code>请求（实质是一个<a href="https://link.segmentfault.com/?url=http%3A%2F%2Fwww.tutorialspoint.com%2Fhttp%2Fhttp_header_fields.htm">HTTP</a>请求）时，我们可能需要设置一些请求头部信息，比如<code>content-type</code>、<code>connection</code>、<code>cookie</code>、<code>accept-xxx</code>等。<code>xhr</code>提供了<code>setRequestHeader</code>来允许我们修改请求 header。</p>
<blockquote>
<pre><code>void setRequestHeader(DOMString header, DOMString value);
</code></pre>
</blockquote>
<p><strong>注意点</strong>：</p>
<ul>
<li>方法的第一个参数 header 大小写不敏感，即可以写成<code>content-type</code>，也可以写成<code>Content-Type</code>，甚至写成<code>content-Type</code>;</li>
<li><code>Content-Type</code>的默认值与具体发送的数据类型有关，请参考本文【可以发送什么类型的数据】一节；</li>
<li><code>setRequestHeader</code>必须在<code>open()</code>方法之后，<code>send()</code>方法之前调用，否则会抛错；</li>
<li><code>setRequestHeader</code>可以调用多次，最终的值不会采用覆盖<code>override</code>的方式，而是采用追加<code>append</code>的方式。下面是一个示例代码：</li>
</ul>
<pre><code class="language-js">var client = new XMLHttpRequest();
client.open('GET', 'demo.cgi');
client.setRequestHeader('X-Test', 'one');
client.setRequestHeader('X-Test', 'two');
// 最终request header中&quot;X-Test&quot;为: one, two
client.send();
</code></pre>
<h3 id="如何获取response-header">如何获取response header</h3>
<p><code>xhr</code>提供了2个用来获取响应头部的方法：<code>getAllResponseHeaders</code>和<code>getResponseHeader</code>。前者是获取 response 中的所有header 字段，后者只是获取某个指定 header 字段的值。另外，<code>getResponseHeader(header)</code>的<code>header</code>参数不区分大小写。</p>
<blockquote>
<pre><code>DOMString getAllResponseHeaders();`
`DOMString getResponseHeader(DOMString header);
</code></pre>
</blockquote>
<p><em>这2个方法看起来简单，但却处处是坑儿。</em></p>
<p>你是否遇到过下面的坑儿?——反正我是遇到了。。。</p>
<ol>
<li>使用<code>getAllResponseHeaders()</code>看到的所有<code>response header</code>与实际在控制台 <code>Network</code> 中看到的 <code>response header</code> 不一样</li>
<li>使用<code>getResponseHeader()</code>获取某个 <code>header</code> 的值时，浏览器抛错<code>Refused to get unsafe header &quot;XXX&quot;</code></li>
</ol>
<p>经过一番寻找最终在 <a href="https://link.segmentfault.com/?url=http%3A%2F%2Fstackoverflow.com%2Fquestions%2F7462968%2Frestrictions-of-xmlhttprequests-getresponseheader">Stack Overflow找到了答案</a>。</p>
<ul>
<li>原因1：<a href="https://link.segmentfault.com/?url=https%3A%2F%2Fwww.w3.org%2FTR%2FXMLHttpRequest%2F">W3C的 xhr 标准中做了限制</a>，规定客户端无法获取 response 中的 <code>Set-Cookie</code>、<code>Set-Cookie2</code>这2个字段，无论是同域还是跨域请求；</li>
<li>原因2：<a href="https://link.segmentfault.com/?url=https%3A%2F%2Fwww.w3.org%2FTR%2Fcors%2F%23access-control-allow-credentials-response-header">W3C 的 cors 标准对于跨域请求也做了限制</a>，规定对于跨域请求，客户端允许获取的response header字段只限于“<code>simple response header</code>”和“<code>Access-Control-Expose-Headers</code>” （两个名词的解释见下方）。</li>
</ul>
<blockquote>
<p>&quot;<code>simple response header</code>&quot;包括的 header 字段有：<code>Cache-Control</code>,<code>Content-Language</code>,<code>Content-Type</code>,<code>Expires</code>,<code>Last-Modified</code>,<code>Pragma</code>;<br>
&quot;<code>Access-Control-Expose-Headers</code>&quot;：首先得注意是&quot;<code>Access-Control-Expose-Headers</code>&quot;进行<strong>跨域请求</strong>时响应头部中的一个字段，对于同域请求，响应头部是没有这个字段的。这个字段中列举的 header 字段就是服务器允许暴露给客户端访问的字段。</p>
</blockquote>
<p>所以<code>getAllResponseHeaders()</code>只能拿到*<strong>限制以外*</strong>（即被视为<code>safe</code>）的header字段，而不是全部字段；而调用<code>getResponseHeader(header)</code>方法时，<code>header</code>参数必须是***限制以外***的header字段，否则调用就会报<code>Refused to get unsafe header</code>的错误。</p>
<h3 id="如何指定xhrresponse的数据类型">如何指定<code>xhr.response</code>的数据类型</h3>
<p>有些时候我们希望<code>xhr.response</code>返回的就是我们想要的数据类型。比如：响应返回的数据是纯JSON字符串，但我们期望最终通过<code>xhr.response</code>拿到的直接就是一个 js 对象，我们该怎么实现呢？<br>
有2种方法可以实现，一个是<code>level 1</code>就提供的<code>overrideMimeType()</code>方法，另一个是<code>level 2</code>才提供的<code>xhr.responseType</code>属性。</p>
<h4 id="xhroverridemimetype"><code>xhr.overrideMimeType()</code></h4>
<p><code>overrideMimeType</code>是<code>xhr level 1</code>就有的方法，所以浏览器兼容性良好。这个方法的作用就是用来重写<code>response</code>的<code>content-type</code>，这样做有什么意义呢？比如：server 端给客户端返回了一份<code>document</code>或者是 <code>xml</code>文档，我们希望最终通过<code>xhr.response</code>拿到的就是一个<code>DOM</code>对象，那么就可以用<code>xhr.overrideMimeType('text/xml; charset = utf-8')</code>来实现。</p>
<p>再举一个使用场景，我们都知道<code>xhr level 1</code>不支持直接传输blob二进制数据，那如果真要传输 blob 该怎么办呢？当时就是利用<code>overrideMimeType</code>方法来解决这个问题的。</p>
<p>下面是一个获取图片文件的代码示例：</p>
<pre><code class="language-js">var xhr = new XMLHttpRequest();
//向 server 端获取一张图片
xhr.open('GET', '/path/to/image.png', true);

// 这行是关键！
//将响应数据按照纯文本格式来解析，字符集替换为用户自己定义的字符集
xhr.overrideMimeType('text/plain; charset=x-user-defined');

xhr.onreadystatechange = function(e) {
  if (this.readyState == 4 &amp;&amp; this.status == 200) {
    //通过 responseText 来获取图片文件对应的二进制字符串
    var binStr = this.responseText;
    //然后自己再想方法将逐个字节还原为二进制数据
    for (var i = 0, len = binStr.length; i &lt; len; ++i) {
      var c = binStr.charCodeAt(i);
      //String.fromCharCode(c &amp; 0xff);
      var byte = c &amp; 0xff; 
    }
  }
};

xhr.send();
</code></pre>
<p>代码示例中<code>xhr</code>请求的是一张图片，通过将 <code>response</code> 的 <code>content-type</code> 改为'text/plain; charset=x-user-defined'，使得 <code>xhr</code> 以纯文本格式来解析接收到的blob 数据，最终用户通过<code>this.responseText</code>拿到的就是图片文件对应的二进制字符串，最后再将其转换为 blob 数据。</p>
<h4 id="xhrresponsetype"><code>xhr.responseType</code></h4>
<p><code>responseType</code>是<code>xhr level 2</code>新增的属性，用来指定<code>xhr.response</code>的数据类型，目前还存在些兼容性问题，可以参考本文的【<code>XMLHttpRequest</code>的兼容性】这一小节。那么<code>responseType</code>可以设置为哪些格式呢，我简单做了一个表，如下：</p>
<table>
<thead>
<tr>
<th>值</th>
<th><code>xhr.response</code> 数据类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&quot;&quot;</code></td>
<td><code>String</code>字符串</td>
<td>默认值(在不设置<code>responseType</code>时)</td>
</tr>
<tr>
<td><code>&quot;text&quot;</code></td>
<td><code>String</code>字符串</td>
<td></td>
</tr>
<tr>
<td><code>&quot;document&quot;</code></td>
<td><code>Document</code>对象</td>
<td>希望返回 <code>XML</code> 格式数据时使用</td>
</tr>
<tr>
<td><code>&quot;json&quot;</code></td>
<td><code>javascript</code> 对象</td>
<td>存在兼容性问题，IE10/IE11不支持</td>
</tr>
<tr>
<td><code>&quot;blob&quot;</code></td>
<td><code>Blob</code>对象</td>
<td></td>
</tr>
<tr>
<td><code>&quot;arrayBuffer&quot;</code></td>
<td><code>ArrayBuffer</code>对象</td>
<td></td>
</tr>
</tbody>
</table>
<p>下面是同样是获取一张图片的代码示例，相比<code>xhr.overrideMimeType</code>,用<code>xhr.response</code>来实现简单得多。</p>
<pre><code class="language-js">var xhr = new XMLHttpRequest();
xhr.open('GET', '/path/to/image.png', true);
//可以将`xhr.responseType`设置为`&quot;blob&quot;`也可以设置为`&quot; arrayBuffer&quot;`
//xhr.responseType = 'arrayBuffer';
xhr.responseType = 'blob';

xhr.onload = function(e) {
  if (this.status == 200) {
    var blob = this.response;
    ...
  }
};

xhr.send();
</code></pre>
<h4 id="小结">小结</h4>
<p>虽然在<code>xhr level 2</code>中，2者是共同存在的。但其实不难发现，<code>xhr.responseType</code>就是用来取代<code>xhr.overrideMimeType()</code>的，<code>xhr.responseType</code>功能强大的多，<code>xhr.overrideMimeType()</code>能做到的<code>xhr.responseType</code>都能做到。所以我们现在完全可以摒弃使用<code>xhr.overrideMimeType()</code>了。</p>
<h3 id="如何获取response数据">如何获取response数据</h3>
<pre><code>xhr`提供了3个属性来获取请求返回的数据，分别是：`xhr.response`、`xhr.responseText`、`xhr.responseXML
</code></pre>
<ul>
<li><code>xhr.response</code>
<ul>
<li>默认值：空字符串<code>&quot;&quot;</code></li>
<li>当请求完成时，此属性才有正确的值</li>
<li>请求未完成时，此属性的值可能是<code>&quot;&quot;</code>或者 <code>null</code>，具体与 <code>xhr.responseType</code>有关：当<code>responseType</code>为<code>&quot;&quot;</code>或<code>&quot;text&quot;</code>时，值为<code>&quot;&quot;</code>；<code>responseType</code>为其他值时，值为 <code>null</code></li>
</ul>
</li>
<li><code>xhr.responseText</code>
<ul>
<li>默认值为空字符串<code>&quot;&quot;</code></li>
<li>只有当 <code>responseType</code> 为<code>&quot;text&quot;</code>、<code>&quot;&quot;</code>时，<code>xhr</code>对象上才有此属性，此时才能调用<code>xhr.responseText</code>，否则抛错</li>
<li>只有当请求成功时，才能拿到正确值。以下2种情况下值都为空字符串<code>&quot;&quot;</code>：请求未完成、请求失败</li>
</ul>
</li>
<li><code>xhr.responseXML</code>
<ul>
<li>默认值为 <code>null</code></li>
<li>只有当 <code>responseType</code> 为<code>&quot;text&quot;</code>、<code>&quot;&quot;</code>、<code>&quot;document&quot;</code>时，<code>xhr</code>对象上才有此属性，此时才能调用<code>xhr.responseXML</code>，否则抛错</li>
<li>只有当请求成功且返回数据被正确解析时，才能拿到正确值。以下3种情况下值都为<code>null</code>：请求未完成、请求失败、请求成功但返回数据无法被正确解析时</li>
</ul>
</li>
</ul>
<h3 id="如何追踪ajax请求的当前状态">如何追踪<code>ajax</code>请求的当前状态</h3>
<p>在发一个<code>ajax</code>请求后，如果想追踪请求当前处于哪种状态，该怎么做呢？</p>
<p>用<code>xhr.readyState</code>这个属性即可追踪到。这个属性是只读属性，总共有5种可能值，分别对应<code>xhr</code>不同的不同阶段。每次<code>xhr.readyState</code>的值发生变化时，都会触发<code>xhr.onreadystatechange</code>事件，我们可以在这个事件中进行相关状态判断。</p>
<pre><code class="language-js">  xhr.onreadystatechange = function () {
    switch(xhr.readyState){
      case 1://OPENED
        //do something
            break;
      case 2://HEADERS_RECEIVED
        //do something
        break;
      case 3://LOADING
        //do something
        break;
      case 4://DONE
        //do something
        break;
    }
</code></pre>
<table>
<thead>
<tr>
<th>值</th>
<th>状态</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0</code></td>
<td><code>UNSENT</code> (初始状态，未打开)</td>
<td>此时<code>xhr</code>对象被成功构造，<code>open()</code>方法还未被调用</td>
</tr>
<tr>
<td><code>1</code></td>
<td><code>OPENED</code> (已打开，未发送)</td>
<td><code>open()</code>方法已被成功调用，<code>send()</code>方法还未被调用。注意：只有<code>xhr</code>处于<code>OPENED</code>状态，才能调用<code>xhr.setRequestHeader()</code>和<code>xhr.send()</code>,否则会报错</td>
</tr>
<tr>
<td><code>2</code></td>
<td><code>HEADERS_RECEIVED</code> (已获取响应头)</td>
<td><code>send()</code>方法已经被调用, 响应头和响应状态已经返回</td>
</tr>
<tr>
<td><code>3</code></td>
<td><code>LOADING</code> (正在下载响应体)</td>
<td>响应体(<code>response entity body</code>)正在下载中，此状态下通过<code>xhr.response</code>可能已经有了响应数据</td>
</tr>
<tr>
<td><code>4</code></td>
<td><code>DONE</code> (整个数据传输过程结束)</td>
<td>整个数据传输过程结束，不管本次请求是成功还是失败</td>
</tr>
</tbody>
</table>
<h3 id="如何设置请求的超时时间">如何设置请求的超时时间</h3>
<p>如果请求过了很久还没有成功，为了不会白白占用的网络资源，我们一般会主动终止请求。<code>XMLHttpRequest</code>提供了<code>timeout</code>属性来允许设置请求的超时时间。</p>
<blockquote>
<pre><code>xhr.timeout
</code></pre>
</blockquote>
<p>单位：milliseconds 毫秒<br>
默认值：<code>0</code>，即不设置超时</p>
<p>很多同学都知道：从*<strong>请求开始*</strong> 算起，若超过 <code>timeout</code> 时间请求还没有结束（包括成功/失败），则会触发ontimeout事件，主动结束该请求。</p>
<p>【那么到底什么时候才算是*<strong>请求开始*</strong> ？】<br>
——<code>xhr.onloadstart</code>事件触发的时候，也就是你调用<code>xhr.send()</code>方法的时候。<br>
因为<code>xhr.open()</code>只是创建了一个连接，但并没有真正开始数据的传输，而<code>xhr.send()</code>才是真正开始了数据的传输过程。只有调用了<code>xhr.send()</code>，才会触发<code>xhr.onloadstart</code> 。</p>
<p>【那么什么时候才算是*<strong>请求结束*</strong> ？】<br>
—— <code>xhr.loadend</code>事件触发的时候。</p>
<p>另外，还有2个需要注意的坑儿：</p>
<ol>
<li>可以在 <code>send()</code>之后再设置此<code>xhr.timeout</code>，但计时起始点仍为调用<code>xhr.send()</code>方法的时刻。</li>
<li>当<code>xhr</code>为一个<code>sync</code>同步请求时，<code>xhr.timeout</code>必须置为<code>0</code>，否则会抛错。原因可以参考本文的【如何发一个同步请求】一节。</li>
</ol>
<h3 id="如何发一个同步请求">如何发一个同步请求</h3>
<p><code>xhr</code>默认发的是异步请求，但也支持发同步请求（当然实际开发中应该尽量避免使用）。到底是异步还是同步请求，由<code>xhr.open（）</code>传入的<code>async</code>参数决定。</p>
<blockquote>
<pre><code>open(method, url [, async = true [, username = null [, password = null]]])
</code></pre>
</blockquote>
<ul>
<li><code>method</code>: 请求的方式，如<code>GET/POST/HEADER</code>等，这个参数不区分大小写</li>
<li><code>url</code>: 请求的地址，可以是相对地址如<code>example.php</code>，这个<strong>相对</strong>是相对于当前网页的<code>url</code>路径；也可以是绝对地址如<code>http://www.example.com/example.php</code></li>
<li><code>async</code>: 默认值为<code>true</code>，即为异步请求，若<code>async=false</code>，则为同步请求</li>
</ul>
<p>在我认真研读W3C 的 xhr 标准前，我总以为同步请求和异步请求只是阻塞和非阻塞的区别，其他什么事件触发、参数设置应该是一样的，事实证明我错了。</p>
<p>W3C 的 xhr标准中关于<code>open()</code>方法有这样一段说明：</p>
<blockquote>
<p>Throws an &quot;InvalidAccessError&quot; exception if async is false, the JavaScript global environment is a document environment, and either the timeout attribute is not zero, the withCredentials attribute is true, or the responseType attribute is not the empty string.</p>
</blockquote>
<p>从上面一段说明可以知道，当<code>xhr</code>为同步请求时，有如下限制：</p>
<ul>
<li><code>xhr.timeout</code>必须为<code>0</code></li>
<li><code>xhr.withCredentials</code>必须为 <code>false</code></li>
<li><code>xhr.responseType</code>必须为<code>&quot;&quot;</code>（注意置为<code>&quot;text&quot;</code>也不允许）</li>
</ul>
<p>若上面任何一个限制不满足，都会抛错，而对于异步请求，则没有这些参数设置上的限制。</p>
<p>之前说过页面中应该尽量避免使用<code>sync</code>同步请求，为什么呢？<br>
因为我们无法设置请求超时时间（<code>xhr.timeout</code>为<code>0</code>，即不限时）。在不限制超时的情况下，有可能同步请求一直处于<code>pending</code>状态，服务端迟迟不返回响应，这样整个页面就会一直阻塞，无法响应用户的其他交互。</p>
<p>另外，标准中并没有提及同步请求时事件触发的限制，但实际开发中我确实遇到过部分应该触发的事件并没有触发的现象。如在 chrome中，当<code>xhr</code>为同步请求时，在<code>xhr.readyState</code>由<code>2</code>变成<code>3</code>时，并不会触发 <code>onreadystatechange</code>事件，<code>xhr.upload.onprogress</code>和 <code>xhr.onprogress</code>事件也不会触发。</p>
<h3 id="如何获取上传-下载的进度">如何获取上传、下载的进度</h3>
<p>在上传或者下载比较大的文件时，实时显示当前的上传、下载进度是很普遍的产品需求。<br>
我们可以通过<code>onprogress</code>事件来实时显示进度，默认情况下这个事件每50ms触发一次。需要注意的是，上传过程和下载过程触发的是不同对象的<code>onprogress</code>事件：</p>
<ul>
<li>上传触发的是<code>xhr.upload</code>对象的 <code>onprogress</code>事件</li>
<li>下载触发的是<code>xhr</code>对象的<code>onprogress</code>事件</li>
</ul>
<pre><code class="language-js">xhr.onprogress = updateProgress;
xhr.upload.onprogress = updateProgress;
function updateProgress(event) {
    if (event.lengthComputable) {
      var completedPercent = event.loaded / event.total;
    }
 }
</code></pre>
<h3 id="可以发送什么类型的数据">可以发送什么类型的数据</h3>
<blockquote>
<p>void send(data);</p>
</blockquote>
<p><code>xhr.send(data)</code>的参数data可以是以下几种类型：</p>
<ul>
<li><code>ArrayBuffer</code></li>
<li><code>Blob</code></li>
<li><code>Document</code></li>
<li><code>DOMString</code></li>
<li><code>FormData</code></li>
<li><code>null</code></li>
</ul>
<p>如果是 GET/HEAD请求，<code>send()</code>方法一般不传参或传 <code>null</code>。不过即使你真传入了参数，参数也最终被忽略，<code>xhr.send(data)</code>中的data会被置为 <code>null</code>.</p>
<p><code>xhr.send(data)</code>中data参数的数据类型会影响请求头部<code>content-type</code>的默认值：</p>
<ul>
<li>如果<code>data</code>是 <code>Document</code> 类型，同时也是<code>HTML Document</code>类型，则<code>content-type</code>默认值为<code>text/html;charset=UTF-8</code>;否则为<code>application/xml;charset=UTF-8</code>；</li>
<li>如果<code>data</code>是 <code>DOMString</code> 类型，<code>content-type</code>默认值为<code>text/plain;charset=UTF-8</code>；</li>
<li>如果<code>data</code>是 <code>FormData</code> 类型，<code>content-type</code>默认值为<code>multipart/form-data; boundary=[xxx]</code></li>
<li>如果<code>data</code>是其他类型，则不会设置<code>content-type</code>的默认值</li>
</ul>
<p>当然这些只是<code>content-type</code>的默认值，但如果用<code>xhr.setRequestHeader()</code>手动设置了中<code>content-type</code>的值，以上默认值就会被覆盖。</p>
<p>另外需要注意的是，若在断网状态下调用<code>xhr.send(data)</code>方法，则会抛错：<code>Uncaught NetworkError: Failed to execute 'send' on 'XMLHttpRequest'</code>。一旦程序抛出错误，如果不 catch 就无法继续执行后面的代码，所以调用 <code>xhr.send(data)</code>方法时，应该用 <code>try-catch</code>捕捉错误。</p>
<pre><code class="language-js">try{
    xhr.send(data)
  }catch(e) {
    //doSomething...
  };
</code></pre>
<h3 id="xhrwithcredentials与-cors-什么关系"><code>xhr.withCredentials</code>与 <code>CORS</code> 什么关系</h3>
<blockquote>
<p>我们都知道，在发同域请求时，浏览器会将<code>cookie</code>自动加在<code>request header</code>中。但大家是否遇到过这样的场景：在发送跨域请求时，<code>cookie</code>并没有自动加在<code>request header</code>中。</p>
</blockquote>
<p>造成这个问题的原因是：在<code>CORS</code>标准中做了规定，默认情况下，浏览器在发送跨域请求时，不能发送任何认证信息（<code>credentials</code>）如&quot;<code>cookies</code>&quot;和&quot;<code>HTTP authentication schemes</code>&quot;。除非<code>xhr.withCredentials</code>为<code>true</code>（<code>xhr</code>对象有一个属性叫<code>withCredentials</code>，默认值为<code>false</code>）。</p>
<p>所以根本原因是<code>cookies</code>也是一种认证信息，在跨域请求中，<code>client</code>端必须手动设置<code>xhr.withCredentials=true</code>，且<code>server</code>端也必须允许<code>request</code>能携带认证信息（即<code>response header</code>中包含<code>Access-Control-Allow-Credentials:true</code>），这样浏览器才会自动将<code>cookie</code>加在<code>request header</code>中。</p>
<p>另外，要特别注意一点，一旦跨域<code>request</code>能够携带认证信息，<code>server</code>端一定不能将<code>Access-Control-Allow-Origin</code>设置为<code>*</code>，而必须设置为请求页面的域名。</p>
<h2 id="xhr相关事件"><code>xhr</code>相关事件</h2>
<h3 id="事件分类">事件分类</h3>
<p><code>xhr</code>相关事件有很多，有时记起来还挺容易混乱。但当我了解了具体代码实现后，就容易理清楚了。下面是<code>XMLHttpRequest</code>的部分实现代码：</p>
<pre><code class="language-js">interface XMLHttpRequestEventTarget : EventTarget {
  // event handlers
  attribute EventHandler onloadstart;
  attribute EventHandler onprogress;
  attribute EventHandler onabort;
  attribute EventHandler onerror;
  attribute EventHandler onload;
  attribute EventHandler ontimeout;
  attribute EventHandler onloadend;
};

interface XMLHttpRequestUpload : XMLHttpRequestEventTarget {

};

interface XMLHttpRequest : XMLHttpRequestEventTarget {
  // event handler
  attribute EventHandler onreadystatechange;
  readonly attribute XMLHttpRequestUpload upload;
};
</code></pre>
<p>从代码中我们可以看出：</p>
<ol>
<li><code>XMLHttpRequestEventTarget</code>接口定义了7个事件：
<ul>
<li><code>onloadstart</code></li>
<li><code>onprogress</code></li>
<li><code>onabort</code></li>
<li><code>ontimeout</code></li>
<li><code>onerror</code></li>
<li><code>onload</code></li>
<li><code>onloadend</code></li>
</ul>
</li>
<li>每一个<code>XMLHttpRequest</code>里面都有一个<code>upload</code>属性，而<code>upload</code>是一个<code>XMLHttpRequestUpload</code>对象</li>
<li><code>XMLHttpRequest</code>和<code>XMLHttpRequestUpload</code>都继承了同一个<code>XMLHttpRequestEventTarget</code>接口，所以<code>xhr</code>和<code>xhr.upload</code>都有第一条列举的7个事件</li>
<li><code>onreadystatechange</code>是<code>XMLHttpRequest</code>独有的事件</li>
</ol>
<p>所以这么一看就很清晰了：<br>
<code>xhr</code>一共有8个相关事件：7个<code>XMLHttpRequestEventTarget</code>事件+1个独有的<code>onreadystatechange</code>事件；而<code>xhr.upload</code>只有7个<code>XMLHttpRequestEventTarget</code>事件。</p>
<h3 id="事件触发条件">事件触发条件</h3>
<p>下面是我自己整理的一张<code>xhr</code>相关事件触发条件表，其中最需要注意的是 <code>onerror</code> 事件的触发条件。</p>
<table>
<thead>
<tr>
<th>事件</th>
<th>触发条件</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>onreadystatechange</code></td>
<td>每当<code>xhr.readyState</code>改变时触发；但<code>xhr.readyState</code>由非<code>0</code>值变为<code>0</code>时不触发。</td>
</tr>
<tr>
<td><code>onloadstart</code></td>
<td>调用<code>xhr.send()</code>方法后立即触发，若<code>xhr.send()</code>未被调用则不会触发此事件。</td>
</tr>
<tr>
<td><code>onprogress</code></td>
<td><code>xhr.upload.onprogress</code>在上传阶段(即<code>xhr.send()</code>之后，<code>xhr.readystate=2</code>之前)触发，每50ms触发一次；<code>xhr.onprogress</code>在下载阶段（即<code>xhr.readystate=3</code>时）触发，每50ms触发一次。</td>
</tr>
<tr>
<td><code>onload</code></td>
<td>当请求成功完成时触发，此时<code>xhr.readystate=4</code></td>
</tr>
<tr>
<td><code>onloadend</code></td>
<td>当请求结束（包括请求成功和请求失败）时触发</td>
</tr>
<tr>
<td><code>onabort</code></td>
<td>当调用<code>xhr.abort()</code>后触发</td>
</tr>
<tr>
<td><code>ontimeout</code></td>
<td><code>xhr.timeout</code>不等于0，由请求开始即<code>onloadstart</code>开始算起，当到达<code>xhr.timeout</code>所设置时间请求还未结束即<code>onloadend</code>，则触发此事件。</td>
</tr>
<tr>
<td><code>onerror</code></td>
<td>在请求过程中，若发生<code>Network error</code>则会触发此事件（若发生<code>Network error</code>时，上传还没有结束，则会先触发<code>xhr.upload.onerror</code>，再触发<code>xhr.onerror</code>；若发生<code>Network error</code>时，上传已经结束，则只会触发<code>xhr.onerror</code>）。<strong>注意</strong>，只有发生了网络层级别的异常才会触发此事件，对于应用层级别的异常，如响应返回的<code>xhr.statusCode</code>是<code>4xx</code>时，并不属于<code>Network error</code>，所以不会触发<code>onerror</code>事件，而是会触发<code>onload</code>事件。</td>
</tr>
</tbody>
</table>
<h3 id="事件触发顺序">事件触发顺序</h3>
<p>当请求一切正常时，相关的事件触发顺序如下：</p>
<ol>
<li>触发<code>xhr.onreadystatechange</code>(之后每次<code>readyState</code>变化时，都会触发一次)</li>
<li>触发<code>xhr.onloadstart</code><br>
//上传阶段开始：</li>
<li>触发<code>xhr.upload.onloadstart</code></li>
<li>触发<code>xhr.upload.onprogress</code></li>
<li>触发<code>xhr.upload.onload</code></li>
<li>触发<code>xhr.upload.onloadend</code><br>
//上传结束，下载阶段开始：</li>
<li>触发<code>xhr.onprogress</code></li>
<li>触发<code>xhr.onload</code></li>
<li>触发<code>xhr.onloadend</code></li>
</ol>
<h4 id="发生aborttimeouterror异常的处理">发生<code>abort</code>/<code>timeout</code>/<code>error</code>异常的处理</h4>
<p>在请求的过程中，有可能发生 <code>abort</code>/<code>timeout</code>/<code>error</code>这3种异常。那么一旦发生这些异常，<code>xhr</code>后续会进行哪些处理呢？后续处理如下：</p>
<ol>
<li>一旦发生<code>abort</code>或<code>timeout</code>或<code>error</code>异常，先立即中止当前请求</li>
<li>将 <code>readystate</code> 置为<code>4</code>，并触发 <code>xhr.onreadystatechange</code>事件</li>
<li>如果上传阶段还没有结束，则依次触发以下事件：
<ul>
<li><code>xhr.upload.onprogress</code></li>
<li><code>xhr.upload.[onabort或ontimeout或onerror]</code></li>
<li><code>xhr.upload.onloadend</code></li>
</ul>
</li>
<li>触发 <code>xhr.onprogress</code>事件</li>
<li>触发 <code>xhr.[onabort或ontimeout或onerror]</code>事件</li>
<li>触发<code>xhr.onloadend</code> 事件</li>
</ol>
<h4 id="在哪个xhr事件中注册成功回调">在哪个<code>xhr</code>事件中注册成功回调？</h4>
<p>从上面介绍的事件中，可以知道若<code>xhr</code>请求成功，就会触发<code>xhr.onreadystatechange</code>和<code>xhr.onload</code>两个事件。 那么我们到底要将成功回调注册在哪个事件中呢？我倾向于 <code>xhr.onload</code>事件，因为<code>xhr.onreadystatechange</code>是每次<code>xhr.readyState</code>变化时都会触发，而不是<code>xhr.readyState=4</code>时才触发。</p>
<pre><code class="language-js">xhr.onload = function () {
    //如果请求成功
    if(xhr.status == 200){
      //do successCallback
    }
  }
</code></pre>
<p>上面的示例代码是很常见的写法：先判断<code>http</code>状态码是否是<code>200</code>，如果是，则认为请求是成功的，接着执行成功回调。这样的判断是有坑儿的，比如当返回的<code>http</code>状态码不是<code>200</code>，而是<code>201</code>时，请求虽然也是成功的，但并没有执行成功回调逻辑。所以更靠谱的判断方法应该是：当<code>http</code>状态码为<code>2xx</code>或<code>304</code>时才认为成功。</p>
<pre><code class="language-js">  xhr.onload = function () {
    //如果请求成功
    if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304){
      //do successCallback
    }
  }
</code></pre>
<h2 id="参考资料">参考资料</h2>
<p><a href="https://www.w3.org/TR/XMLHttpRequest/">w3</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest">MDN</a></p>
<h2 id="转载">转载</h2>
<blockquote>
<h3 id="ruoyiqing">ruoyiqing</h3>
<p><a href="https://segmentfault.com/a/1190000004322487">https://segmentfault.com/a/1190000004322487</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[github-连接错误Connection reset by 13.229.188.59 port 22 ssh]]></title>
        <id>https://leecss.com/post/github-lian-jie-cuo-wu-connection-reset-by-1322918859-port-22-ssh/</id>
        <link href="https://leecss.com/post/github-lian-jie-cuo-wu-connection-reset-by-1322918859-port-22-ssh/">
        </link>
        <updated>2021-07-15T00:41:06.000Z</updated>
        <content type="html"><![CDATA[<h1 id="github-连接错误connection-reset-by-1322918859-port-22-ssh">github-连接错误Connection reset by 13.229.188.59 port 22 ssh</h1>
<h2 id="概述">概述</h2>
<p>当你想连接GitHub提交时，发现无法提交，报错如下：</p>
<pre><code>Connection reset by 13.229.188.59 port 22 ssh
</code></pre>
<h2 id="解决">解决</h2>
<p>在Windows防火墙中设置22端口</p>
<p>1、控制面板-系统和安全-Windows Defender防火墙-高级设置</p>
<p>2、选择<strong>入站规则</strong>-<strong>新建规则</strong></p>
<p>3、选择<strong>端口</strong></p>
<p>4、特定本地端口：输入<strong>22</strong></p>
<p>5、选择<strong>允许连接</strong></p>
<p>6、输入<strong>名称</strong>和<strong>描述</strong>，自定义，也可如下</p>
<p>名称：22in</p>
<p>描述：Connection reset by 13.229.188.59 port 22 ssh</p>
<h2 id="其他方法">其他方法</h2>
<p>更改防火墙禁掉的22端口，ssh本来使用的22，可以在https端口使用ssh</p>
<p>1、要测试通过 HTTPS 端口的 SSH 是否可行，请运行以下 SSH 命令：</p>
<pre><code class="language-shell">$ ssh -T -p 443 git@ssh.github.com
&gt; Hi username! You've successfully authenticated, but GitHub does not
&gt; provide shell access.
</code></pre>
<p>如果这样有效，万事大吉！</p>
<p>2、如果您能在端口 443 上通过 SSH 连接到 <code>git@ssh.github.com</code>，则可以覆盖您的 SSH 设置以强制与 GitHub 的任何连接均通过该服务器和端口运行。</p>
<p>要在您的 ssh 配置中设置此项，编辑位于 <code>~/.ssh/config</code> 的文件，添加以下部分：</p>
<pre><code>Host github.com
  Hostname ssh.github.com
  Port 443
  User git
</code></pre>
<p>您可以通过再次连接到 GitHub 测试此项是否有效：</p>
<pre><code class="language-shell">$ ssh -T git@github.com
&gt; Hi username! You've successfully authenticated, but GitHub does not
&gt; provide shell access.
</code></pre>
<h2 id="问题">问题</h2>
<p>当时解决了，但是第二天又不行了。怀疑是网络的问题，然后用我手机流量开热点，提交成功了。</p>
<h2 id="文档">文档</h2>
<p><a href="https://docs.github.com/cn/github/authenticating-to-github/troubleshooting-ssh/using-ssh-over-the-https-port">https://docs.github.com/cn/github/authenticating-to-github/troubleshooting-ssh/using-ssh-over-the-https-port</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[http-跨域CORS]]></title>
        <id>https://leecss.com/post/http-kua-yu-cors/</id>
        <link href="https://leecss.com/post/http-kua-yu-cors/">
        </link>
        <updated>2021-07-14T15:15:19.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>CORS是一个W3C标准，全称是&quot;跨域资源共享&quot;（Cross-origin resource sharing）。</p>
<p>它允许浏览器向跨源服务器，发出<a href="https://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html"><code>XMLHttpRequest</code></a>请求，从而克服了AJAX只能<a href="https://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html">同源</a>使用的限制。</p>
<h2 id="一-简介">一、简介</h2>
<p>CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。</p>
<p>整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p>
<p>因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p>
<h2 id="二-两种请求">二、两种请求</h2>
<p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p>
<p>只要同时满足以下两大条件，就属于简单请求。</p>
<blockquote>
<p>（1) 请求方法是以下三种方法之一：</p>
<ul>
<li>HEAD</li>
<li>GET</li>
<li>POST</li>
</ul>
<p>（2）HTTP的头信息不超出以下几种字段：</p>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
<li>Content-Type：只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></li>
</ul>
</blockquote>
<p>这是为了兼容表单（form），因为历史上表单一直可以发出跨域请求。AJAX 的跨域设计就是，只要表单可以发，AJAX 就可以直接发。</p>
<p>凡是不同时满足上面两个条件，就属于非简单请求。</p>
<p>浏览器对这两种请求的处理，是不一样的。</p>
<h2 id="三-简单请求">三、简单请求</h2>
<h3 id="31-基本流程">3.1 基本流程</h3>
<p>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个<code>Origin</code>字段。</p>
<p>下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个<code>Origin</code>字段。</p>
<blockquote>
<pre><code class="language-http">GET /cors HTTP/1.1
Origin: http://api.bob.com
Host: api.alice.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
</code></pre>
</blockquote>
<p>上面的头信息中，<code>Origin</code>字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p>
<p>如果<code>Origin</code>指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含<code>Access-Control-Allow-Origin</code>字段（详见下文），就知道出错了，从而抛出一个错误，被<code>XMLHttpRequest</code>的<code>onerror</code>回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。</p>
<p>如果<code>Origin</code>指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p>
<blockquote>
<pre><code class="language-http">Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Credentials: true
Access-Control-Expose-Headers: FooBar
Content-Type: text/html; charset=utf-8
</code></pre>
</blockquote>
<p>上面的头信息之中，有三个与CORS请求相关的字段，都以<code>Access-Control-</code>开头。</p>
<p><strong>（1）Access-Control-Allow-Origin</strong></p>
<p>该字段是必须的。它的值要么是请求时<code>Origin</code>字段的值，要么是一个<code>*</code>，表示接受任意域名的请求。</p>
<p><strong>（2）Access-Control-Allow-Credentials</strong></p>
<p>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为<code>true</code>，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为<code>true</code>，如果服务器不要浏览器发送Cookie，删除该字段即可。</p>
<p><strong>（3）Access-Control-Expose-Headers</strong></p>
<p>该字段可选。CORS请求时，<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到6个基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定。上面的例子指定，<code>getResponseHeader('FooBar')</code>可以返回<code>FooBar</code>字段的值。</p>
<h3 id="32-withcredentials-属性">3.2 withCredentials 属性</h3>
<p>上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定<code>Access-Control-Allow-Credentials</code>字段。</p>
<blockquote>
<pre><code class="language-http">Access-Control-Allow-Credentials: true
</code></pre>
</blockquote>
<p>另一方面，开发者必须在AJAX请求中打开<code>withCredentials</code>属性。</p>
<blockquote>
<pre><code class="language-javascript">var xhr = new XMLHttpRequest();
xhr.withCredentials = true;
</code></pre>
</blockquote>
<p>否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。</p>
<p>但是，如果省略<code>withCredentials</code>设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭<code>withCredentials</code>。</p>
<blockquote>
<pre><code class="language-javascript">xhr.withCredentials = false;
</code></pre>
</blockquote>
<p>需要注意的是，如果要发送Cookie，<code>Access-Control-Allow-Origin</code>就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的<code>document.cookie</code>也无法读取服务器域名下的Cookie。</p>
<h2 id="四-非简单请求">四、非简单请求</h2>
<h3 id="41-预检请求">4.1 预检请求</h3>
<p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是<code>PUT</code>或<code>DELETE</code>，或者<code>Content-Type</code>字段的类型是<code>application/json</code>。</p>
<p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为&quot;预检&quot;请求（preflight）。</p>
<p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错。</p>
<p>下面是一段浏览器的JavaScript脚本。</p>
<blockquote>
<pre><code class="language-javascript">var url = 'http://api.alice.com/cors';
var xhr = new XMLHttpRequest();
xhr.open('PUT', url, true);
xhr.setRequestHeader('X-Custom-Header', 'value');
xhr.send();
</code></pre>
</blockquote>
<p>上面代码中，HTTP请求的方法是<code>PUT</code>，并且发送一个自定义头信息<code>X-Custom-Header</code>。</p>
<p>浏览器发现，这是一个非简单请求，就自动发出一个&quot;预检&quot;请求，要求服务器确认可以这样请求。下面是这个&quot;预检&quot;请求的HTTP头信息。</p>
<blockquote>
<pre><code class="language-http">OPTIONS /cors HTTP/1.1
Origin: http://api.bob.com
Access-Control-Request-Method: PUT
Access-Control-Request-Headers: X-Custom-Header
Host: api.alice.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
</code></pre>
</blockquote>
<p>&quot;预检&quot;请求用的请求方法是<code>OPTIONS</code>，表示这个请求是用来询问的。头信息里面，关键字段是<code>Origin</code>，表示请求来自哪个源。</p>
<p>除了<code>Origin</code>字段，&quot;预检&quot;请求的头信息包括两个特殊字段。</p>
<p><strong>（1）Access-Control-Request-Method</strong></p>
<p>该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是<code>PUT</code>。</p>
<p><strong>（2）Access-Control-Request-Headers</strong></p>
<p>该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是<code>X-Custom-Header</code>。</p>
<h3 id="42-预检请求的回应">4.2 预检请求的回应</h3>
<p>服务器收到&quot;预检&quot;请求以后，检查了<code>Origin</code>、<code>Access-Control-Request-Method</code>和<code>Access-Control-Request-Headers</code>字段以后，确认允许跨源请求，就可以做出回应。</p>
<blockquote>
<pre><code class="language-http">HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:15:39 GMT
Server: Apache/2.0.61 (Unix)
Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
Content-Type: text/html; charset=utf-8
Content-Encoding: gzip
Content-Length: 0
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Content-Type: text/plain
</code></pre>
</blockquote>
<p>上面的HTTP回应中，关键的是<code>Access-Control-Allow-Origin</code>字段，表示<code>http://api.bob.com</code>可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。</p>
<blockquote>
<pre><code class="language-http">Access-Control-Allow-Origin: *
</code></pre>
</blockquote>
<p>如果服务器否定了&quot;预检&quot;请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被<code>XMLHttpRequest</code>对象的<code>onerror</code>回调函数捕获。控制台会打印出如下的报错信息。</p>
<blockquote>
<pre><code class="language-bash">XMLHttpRequest cannot load http://api.alice.com.
Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.
</code></pre>
</blockquote>
<p>服务器回应的其他CORS相关字段如下。</p>
<blockquote>
<pre><code class="language-http">Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
Access-Control-Allow-Credentials: true
Access-Control-Max-Age: 1728000
</code></pre>
</blockquote>
<p><strong>（1）Access-Control-Allow-Methods</strong></p>
<p>该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次&quot;预检&quot;请求。</p>
<p><strong>（2）Access-Control-Allow-Headers</strong></p>
<p>如果浏览器请求包括<code>Access-Control-Request-Headers</code>字段，则<code>Access-Control-Allow-Headers</code>字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在&quot;预检&quot;中请求的字段。</p>
<p><strong>（3）Access-Control-Allow-Credentials</strong></p>
<p>该字段与简单请求时的含义相同。</p>
<p><strong>（4）Access-Control-Max-Age</strong></p>
<p>该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。</p>
<h3 id="43-浏览器的正常请求和回应">4.3 浏览器的正常请求和回应</h3>
<p>一旦服务器通过了&quot;预检&quot;请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个<code>Origin</code>头信息字段。服务器的回应，也都会有一个<code>Access-Control-Allow-Origin</code>头信息字段。</p>
<p>下面是&quot;预检&quot;请求之后，浏览器的正常CORS请求。</p>
<blockquote>
<pre><code class="language-http">PUT /cors HTTP/1.1
Origin: http://api.bob.com
Host: api.alice.com
X-Custom-Header: value
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
</code></pre>
</blockquote>
<p>上面头信息的<code>Origin</code>字段是浏览器自动添加的。</p>
<p>下面是服务器正常的回应。</p>
<blockquote>
<pre><code class="language-http">Access-Control-Allow-Origin: http://api.bob.com
Content-Type: text/html; charset=utf-8
</code></pre>
</blockquote>
<p>上面头信息中，<code>Access-Control-Allow-Origin</code>字段是每次回应都必定包含的。</p>
<h2 id="五-与jsonp的比较">五、与JSONP的比较</h2>
<p>CORS与JSONP的使用目的相同，但是比JSONP更强大。</p>
<p>JSONP只支持<code>GET</code>请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</p>
<h2 id="转载">转载</h2>
<blockquote>
<p>阮一峰</p>
<p><a href="https://www.ruanyifeng.com/blog/2016/04/cors.html">https://www.ruanyifeng.com/blog/2016/04/cors.html</a></p>
</blockquote>
<h2 id="推荐阅读">推荐阅读</h2>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">MDN-CORS</a></p>
<p><a href="https://juejin.cn/post/6844904126246027278">10种跨域解决方案</a></p>
<p><a href="https://segmentfault.com/a/1190000011145364">前端常见跨域解决方案</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[http-浏览器同源政策及其规避方法]]></title>
        <id>https://leecss.com/post/http-kua-yu/</id>
        <link href="https://leecss.com/post/http-kua-yu/">
        </link>
        <updated>2021-07-13T13:37:13.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>**「同源策略」**是一个重要的安全策略，它用于限制一个<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Origin">origin</a>的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。</p>
<p>--来源 MDN</p>
<h2 id="一-概述">一、概述</h2>
<h3 id="11-含义">1.1 含义</h3>
<p>1995年，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策。</p>
<p>最初，它的含义是指，A网页设置的 Cookie，B网页不能打开，除非这两个网页&quot;同源&quot;。所谓&quot;同源&quot;指的是&quot;三个相同&quot;。</p>
<blockquote>
<ul>
<li>协议相同</li>
<li>域名相同</li>
<li>端口相同</li>
</ul>
</blockquote>
<p>举例来说，<code>http://www.example.com/dir/page.html</code>这个网址，协议是<code>http://</code>，域名是<code>www.example.com</code>，端口是<code>80</code>（默认端口可以省略）。它的同源情况如下。</p>
<blockquote>
<ul>
<li><code>http://www.example.com/dir2/other.html</code>：同源</li>
<li><code>http://example.com/dir/other.html</code>：不同源（域名不同）</li>
<li><code>http://v2.www.example.com/dir/other.html</code>：不同源（域名不同）</li>
<li><code>http://www.example.com:81/dir/other.html</code>：不同源（端口不同）</li>
</ul>
</blockquote>
<h3 id="12-目的">1.2 目的</h3>
<p>同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。</p>
<p>设想这样一种情况：A网站是一家银行，用户登录以后，又去浏览其他网站。如果其他网站可以读取A网站的 Cookie，会发生什么？</p>
<p>很显然，如果 Cookie 包含隐私（比如存款总额），这些信息就会泄漏。更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。</p>
<p>由此可见，&quot;同源政策&quot;是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了。</p>
<h3 id="13-限制范围">1.3 限制范围</h3>
<p>随着互联网的发展，&quot;同源政策&quot;越来越严格。目前，如果非同源，共有三种行为受到限制。</p>
<blockquote>
<p>（1） Cookie、LocalStorage 和 IndexDB 无法读取。</p>
<p>（2） DOM 无法获得。</p>
<p>（3） AJAX 请求不能发送。</p>
</blockquote>
<p>虽然这些限制是必要的，但是有时很不方便，合理的用途也受到影响。下面，我将详细介绍，如何规避上面三种限制。</p>
<h2 id="二-cookie">二、Cookie</h2>
<p>Cookie 是服务器写入浏览器的一小段信息，只有同源的网页才能共享。但是，两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置<code>document.domain</code>共享 Cookie。</p>
<p>举例来说，A网页是<code>http://w1.example.com/a.html</code>，B网页是<code>http://w2.example.com/b.html</code>，那么只要设置相同的<code>document.domain</code>，两个网页就可以共享Cookie。</p>
<blockquote>
<pre><code class="language-javascript">document.domain = 'example.com';
</code></pre>
</blockquote>
<p>现在，A网页通过脚本设置一个 Cookie。</p>
<blockquote>
<pre><code class="language-javascript">document.cookie = &quot;test1=hello&quot;;
</code></pre>
</blockquote>
<p>B网页就可以读到这个 Cookie。</p>
<blockquote>
<pre><code class="language-javascript">var allCookie = document.cookie;
</code></pre>
</blockquote>
<p>注意，这种方法只适用于 Cookie 和 iframe 窗口，LocalStorage 和 IndexDB 无法通过这种方法，规避同源政策，而要使用下文介绍的PostMessage API。</p>
<p>另外，服务器也可以在设置Cookie的时候，指定Cookie的所属域名为一级域名，比如<code>.example.com</code>。</p>
<blockquote>
<pre><code class="language-http">Set-Cookie: key=value; domain=.example.com; path=/
</code></pre>
</blockquote>
<p>这样的话，二级域名和三级域名不用做任何设置，都可以读取这个Cookie。</p>
<h2 id="三-iframe">三、iframe</h2>
<p>如果两个网页不同源，就无法拿到对方的DOM。典型的例子是<code>iframe</code>窗口和<code>window.open</code>方法打开的窗口，它们与父窗口无法通信。</p>
<p>比如，父窗口运行下面的命令，如果<code>iframe</code>窗口不是同源，就会报错。</p>
<blockquote>
<pre><code class="language-javascript">document.getElementById(&quot;myIFrame&quot;).contentWindow.document
// Uncaught DOMException: Blocked a frame from accessing a cross-origin frame.
</code></pre>
</blockquote>
<p>上面命令中，父窗口想获取子窗口的DOM，因为跨源导致报错。</p>
<p>反之亦然，子窗口获取主窗口的DOM也会报错。</p>
<blockquote>
<pre><code class="language-javascript">window.parent.document.body
// 报错
</code></pre>
</blockquote>
<p>如果两个窗口一级域名相同，只是二级域名不同，那么设置上一节介绍的<code>document.domain</code>属性，就可以规避同源政策，拿到DOM。</p>
<p>对于完全不同源的网站，目前有三种方法，可以解决跨域窗口的通信问题。</p>
<blockquote>
<ul>
<li>片段识别符（fragment identifier）</li>
<li>window.name</li>
<li>跨文档通信API（Cross-document messaging）</li>
</ul>
</blockquote>
<h3 id="31-片段识别符">3.1 片段识别符</h3>
<p>片段标识符（fragment identifier）指的是，URL的<code>#</code>号后面的部分，比如<code>http://example.com/x.html#fragment</code>的<code>#fragment</code>。如果只是改变片段标识符，页面不会重新刷新。</p>
<p>父窗口可以把信息，写入子窗口的片段标识符。</p>
<blockquote>
<pre><code class="language-javascript">var src = originURL + '#' + data;
document.getElementById('myIFrame').src = src;
</code></pre>
</blockquote>
<p>子窗口通过监听<code>hashchange</code>事件得到通知。</p>
<blockquote>
<pre><code class="language-javascript">window.onhashchange = checkMessage;

function checkMessage() {
  var message = window.location.hash;
  // ...
}
</code></pre>
</blockquote>
<p>同样的，子窗口也可以改变父窗口的片段标识符。</p>
<blockquote>
<pre><code class="language-javascript">parent.location.href= target + &quot;#&quot; + hash;
</code></pre>
</blockquote>
<h3 id="32-windowname">3.2 window.name</h3>
<p>浏览器窗口有<code>window.name</code>属性。这个属性的最大特点是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。</p>
<p>父窗口先打开一个子窗口，载入一个不同源的网页，该网页将信息写入<code>window.name</code>属性。</p>
<blockquote>
<pre><code class="language-javascript">window.name = data;
</code></pre>
</blockquote>
<p>接着，子窗口跳回一个与主窗口同域的网址。</p>
<blockquote>
<pre><code class="language-javascript">location = 'http://parent.url.com/xxx.html';
</code></pre>
</blockquote>
<p>然后，主窗口就可以读取子窗口的<code>window.name</code>了。</p>
<blockquote>
<pre><code class="language-javascript">var data = document.getElementById('myFrame').contentWindow.name;
</code></pre>
</blockquote>
<p>这种方法的优点是，<code>window.name</code>容量很大，可以放置非常长的字符串；缺点是必须监听子窗口<code>window.name</code>属性的变化，影响网页性能。</p>
<h3 id="33-windowpostmessage">3.3 window.postMessage</h3>
<p>上面两种方法都属于破解，HTML5为了解决这个问题，引入了一个全新的API：跨文档通信 API（Cross-document messaging）。</p>
<p>这个API为<code>window</code>对象新增了一个<code>window.postMessage</code>方法，允许跨窗口通信，不论这两个窗口是否同源。</p>
<p>举例来说，父窗口<code>http://aaa.com</code>向子窗口<code>http://bbb.com</code>发消息，调用<code>postMessage</code>方法就可以了。</p>
<blockquote>
<pre><code class="language-javascript">var popup = window.open('http://bbb.com', 'title');
popup.postMessage('Hello World!', 'http://bbb.com');
</code></pre>
</blockquote>
<p><code>postMessage</code>方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源（origin），即&quot;协议 + 域名 + 端口&quot;。也可以设为<code>*</code>，表示不限制域名，向所有窗口发送。</p>
<p>子窗口向父窗口发送消息的写法类似。</p>
<blockquote>
<pre><code class="language-javascript">window.opener.postMessage('Nice to see you', 'http://aaa.com');
</code></pre>
</blockquote>
<p>父窗口和子窗口都可以通过<code>message</code>事件，监听对方的消息。</p>
<blockquote>
<pre><code class="language-javascript">window.addEventListener('message', function(e) {
  console.log(e.data);
},false);
</code></pre>
</blockquote>
<p><code>message</code>事件的事件对象<code>event</code>，提供以下三个属性。</p>
<blockquote>
<ul>
<li><code>event.source</code>：发送消息的窗口</li>
<li><code>event.origin</code>: 消息发向的网址</li>
<li><code>event.data</code>: 消息内容</li>
</ul>
</blockquote>
<p>下面的例子是，子窗口通过<code>event.source</code>属性引用父窗口，然后发送消息。</p>
<blockquote>
<pre><code class="language-javascript">window.addEventListener('message', receiveMessage);
function receiveMessage(event) {
  event.source.postMessage('Nice to see you!', '*');
}
</code></pre>
</blockquote>
<p><code>event.origin</code>属性可以过滤不是发给本窗口的消息。</p>
<blockquote>
<pre><code class="language-javascript">window.addEventListener('message', receiveMessage);
function receiveMessage(event) {
  if (event.origin !== 'http://aaa.com') return;
  if (event.data === 'Hello World') {
      event.source.postMessage('Hello', event.origin);
  } else {
    console.log(event.data);
  }
}
</code></pre>
</blockquote>
<h3 id="34-localstorage">3.4 LocalStorage</h3>
<p>通过<code>window.postMessage</code>，读写其他窗口的 LocalStorage 也成为了可能。</p>
<p>下面是一个例子，主窗口写入iframe子窗口的<code>localStorage</code>。</p>
<blockquote>
<pre><code class="language-javascript">window.onmessage = function(e) {
  if (e.origin !== 'http://bbb.com') {
    return;
  }
  var payload = JSON.parse(e.data);
  localStorage.setItem(payload.key, JSON.stringify(payload.data));
};
</code></pre>
</blockquote>
<p>上面代码中，子窗口将父窗口发来的消息，写入自己的LocalStorage。</p>
<p>父窗口发送消息的代码如下。</p>
<blockquote>
<pre><code class="language-javascript">var win = document.getElementsByTagName('iframe')[0].contentWindow;
var obj = { name: 'Jack' };
win.postMessage(JSON.stringify({key: 'storage', data: obj}), 'http://bbb.com');
</code></pre>
</blockquote>
<p>加强版的子窗口接收消息的代码如下。</p>
<blockquote>
<pre><code class="language-javascript">window.onmessage = function(e) {
  if (e.origin !== 'http://bbb.com') return;
  var payload = JSON.parse(e.data);
  switch (payload.method) {
    case 'set':
      localStorage.setItem(payload.key, JSON.stringify(payload.data));
      break;
    case 'get':
      var parent = window.parent;
      var data = localStorage.getItem(payload.key);
      parent.postMessage(data, 'http://aaa.com');
      break;
    case 'remove':
      localStorage.removeItem(payload.key);
      break;
  }
};
</code></pre>
</blockquote>
<p>加强版的父窗口发送消息代码如下。</p>
<blockquote>
<pre><code class="language-javascript">var win = document.getElementsByTagName('iframe')[0].contentWindow;
var obj = { name: 'Jack' };
// 存入对象
win.postMessage(JSON.stringify({key: 'storage', method: 'set', data: obj}), 'http://bbb.com');
// 读取对象
win.postMessage(JSON.stringify({key: 'storage', method: &quot;get&quot;}), &quot;*&quot;);
window.onmessage = function(e) {
  if (e.origin != 'http://aaa.com') return;
  // &quot;Jack&quot;
  console.log(JSON.parse(e.data).name);
};
</code></pre>
</blockquote>
<h2 id="四-ajax">四、AJAX</h2>
<p>同源政策规定，AJAX请求只能发给同源的网址，否则就报错。</p>
<p>除了架设服务器代理（浏览器请求同源服务器，再由后者请求外部服务），有三种方法规避这个限制。</p>
<blockquote>
<ul>
<li>JSONP</li>
<li>WebSocket</li>
<li>CORS</li>
</ul>
</blockquote>
<h3 id="41-jsonp">4.1 JSONP</h3>
<p>JSONP是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，老式浏览器全部支持，服务器改造非常小。</p>
<p>它的基本思想是，网页通过添加一个<code>&lt;script&gt;</code>元素，向服务器请求JSON数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。</p>
<p>首先，网页动态插入<code>&lt;script&gt;</code>元素，由它向跨源网址发出请求。</p>
<blockquote>
<pre><code class="language-javascript">function addScriptTag(src) {
  var script = document.createElement('script');
  script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;);
  script.src = src;
  document.body.appendChild(script);
}

window.onload = function () {
  addScriptTag('http://example.com/ip?callback=foo');
}

function foo(data) {
  console.log('Your public IP address is: ' + data.ip);
};
</code></pre>
</blockquote>
<p>上面代码通过动态添加<code>&lt;script&gt;</code>元素，向服务器<code>example.com</code>发出请求。注意，该请求的查询字符串有一个<code>callback</code>参数，用来指定回调函数的名字，这对于JSONP是必需的。</p>
<p>服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。</p>
<blockquote>
<pre><code class="language-javascript">foo({
  &quot;ip&quot;: &quot;8.8.8.8&quot;
});
</code></pre>
</blockquote>
<p>由于<code>&lt;script&gt;</code>元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了<code>foo</code>函数，该函数就会立即调用。作为参数的JSON数据被视为JavaScript对象，而不是字符串，因此避免了使用<code>JSON.parse</code>的步骤。</p>
<h3 id="42-websocket">4.2 WebSocket</h3>
<p>WebSocket是一种通信协议，使用<code>ws://</code>（非加密）和<code>wss://</code>（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。</p>
<p>下面是一个例子，浏览器发出的WebSocket请求的头信息（摘自<a href="https://en.wikipedia.org/wiki/WebSocket">维基百科</a>）。</p>
<blockquote>
<pre><code class="language-http">GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
Origin: http://example.com
</code></pre>
</blockquote>
<p>上面代码中，有一个字段是<code>Origin</code>，表示该请求的请求源（origin），即发自哪个域名。</p>
<p>正是因为有了<code>Origin</code>这个字段，所以WebSocket才没有实行同源政策。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。</p>
<blockquote>
<pre><code class="language-http">HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=
Sec-WebSocket-Protocol: chat
</code></pre>
</blockquote>
<h3 id="43-cors">4.3 CORS</h3>
<p>CORS是跨源资源分享（Cross-Origin Resource Sharing）的缩写。它是W3C标准，是跨源AJAX请求的根本解决方法。相比JSONP只能发<code>GET</code>请求，CORS允许任何类型的请求。</p>
<h2 id="转载">转载</h2>
<blockquote>
<p>阮一峰</p>
<p><a href="https://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html">https://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[http-curl命令行]]></title>
        <id>https://leecss.com/post/http-curl-ming-ling-xing/</id>
        <link href="https://leecss.com/post/http-curl-ming-ling-xing/">
        </link>
        <updated>2021-07-12T13:39:28.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p><a href="http://curl.haxx.se/">curl</a>是一种命令行工具，作用是发出网络请求，然后得到和提取数据，显示在&quot;标准输出&quot;（stdout）上面。</p>
<p><strong>一、查看网页源码</strong></p>
<p>直接在curl命令后加上网址，就可以看到网页源码。我们以网址baidu.com为例（选择该网址，主要因为它的网页代码较短）：</p>
<pre><code class="language-shell">curl baidu.com
</code></pre>
<pre><code class="language-html">&lt;html&gt;
&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;url=http://www.baidu.com/&quot;&gt;
&lt;/html&gt;
</code></pre>
<p>页面会重定向到百度</p>
<p>如果要把这个网页保存下来，可以使用<code>-o</code>参数，这就相当于使用wget命令了。</p>
<pre><code class="language-sh">curl -o [文件名] baidu.com
</code></pre>
<pre><code class="language-sh">curl -o baudu.html baidu.com
</code></pre>
<p><strong>二、显示头信息</strong></p>
<p><code>-i</code>参数可以显示http response的头信息，连同网页代码一起。</p>
<p><code>-I</code>参数则是只显示http response的头信息。</p>
<pre><code class="language-sh">curl -i baidu.com
</code></pre>
<pre><code class="language-shell">HTTP/1.1 200 OK                                                   
Date: Sun, 06 Jun 2021 08:49:54 GMT                               
Server: Apache                                                    
Last-Modified: Tue, 12 Jan 2010 13:48:00 GMT                      
ETag: &quot;51-47cf7e6ee8400&quot;                                          
Accept-Ranges: bytes                                              
Content-Length: 81                                                
Cache-Control: max-age=86400                                      
Expires: Mon, 07 Jun 2021 08:49:54 GMT                            
Connection: Keep-Alive                                            
Content-Type: text/html                                           
                                                                  
&lt;html&gt;                                                            
&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;url=http://www.baidu.com/&quot;&gt; 
&lt;/html&gt;                                                           
</code></pre>
<p><strong>三、显示通信过程</strong></p>
<p><code>-v</code>参数可以显示一次http通信的整个过程，包括端口连接和http request头信息。</p>
<pre><code class="language-sh">curl -v baidu.com
</code></pre>
<pre><code class="language-shell">* Rebuilt URL to: baidu.com/
*   Trying 220.181.38.148...
* TCP_NODELAY set
* Connected to baidu.com (220.181.38.148) port 80 (#0)
&gt; GET / HTTP/1.1
&gt; Host: baidu.com
&gt; User-Agent: curl/7.55.1
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 200 OK
&lt; Date: Sun, 06 Jun 2021 08:53:20 GMT
&lt; Server: Apache
&lt; Last-Modified: Tue, 12 Jan 2010 13:48:00 GMT
&lt; ETag: &quot;51-47cf7e6ee8400&quot;
&lt; Accept-Ranges: bytes
&lt; Content-Length: 81
&lt; Cache-Control: max-age=86400
&lt; Expires: Mon, 07 Jun 2021 08:53:20 GMT
&lt; Connection: Keep-Alive
&lt; Content-Type: text/html
&lt;
&lt;html&gt;
&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;url=http://www.baidu.com/&quot;&gt;
&lt;/html&gt;
* Connection #0 to host baidu.com left intact
</code></pre>
<p>如果你觉得上面的信息还不够，那么下面的命令可以查看更详细的通信过程。</p>
<pre><code class="language-sh">curl --trace output.txt baidu.com
</code></pre>
<pre><code class="language-sh">curl --trace-ascii output.txt baidu.com
</code></pre>
<p>推荐阅读</p>
<blockquote>
<p>阮一峰</p>
<p><a href="http://www.ruanyifeng.com/blog/2019/09/curl-reference.html">http://www.ruanyifeng.com/blog/2019/09/curl-reference.html</a></p>
</blockquote>
]]></content>
    </entry>
</feed>