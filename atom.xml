<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://leecss.com</id>
    <title>当下</title>
    <updated>2021-07-14T15:33:42.505Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://leecss.com"/>
    <link rel="self" href="https://leecss.com/atom.xml"/>
    <logo>https://leecss.com/images/avatar.png</logo>
    <icon>https://leecss.com/favicon.ico</icon>
    <rights>All rights reserved 2021, 当下</rights>
    <entry>
        <title type="html"><![CDATA[http-跨域CORS]]></title>
        <id>https://leecss.com/post/http-kua-yu-cors/</id>
        <link href="https://leecss.com/post/http-kua-yu-cors/">
        </link>
        <updated>2021-07-14T15:15:19.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>CORS是一个W3C标准，全称是&quot;跨域资源共享&quot;（Cross-origin resource sharing）。</p>
<p>它允许浏览器向跨源服务器，发出<a href="https://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html"><code>XMLHttpRequest</code></a>请求，从而克服了AJAX只能<a href="https://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html">同源</a>使用的限制。</p>
<h2 id="一-简介">一、简介</h2>
<p>CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。</p>
<p>整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p>
<p>因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p>
<h2 id="二-两种请求">二、两种请求</h2>
<p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p>
<p>只要同时满足以下两大条件，就属于简单请求。</p>
<blockquote>
<p>（1) 请求方法是以下三种方法之一：</p>
<ul>
<li>HEAD</li>
<li>GET</li>
<li>POST</li>
</ul>
<p>（2）HTTP的头信息不超出以下几种字段：</p>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
<li>Content-Type：只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></li>
</ul>
</blockquote>
<p>这是为了兼容表单（form），因为历史上表单一直可以发出跨域请求。AJAX 的跨域设计就是，只要表单可以发，AJAX 就可以直接发。</p>
<p>凡是不同时满足上面两个条件，就属于非简单请求。</p>
<p>浏览器对这两种请求的处理，是不一样的。</p>
<h2 id="三-简单请求">三、简单请求</h2>
<h3 id="31-基本流程">3.1 基本流程</h3>
<p>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个<code>Origin</code>字段。</p>
<p>下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个<code>Origin</code>字段。</p>
<blockquote>
<pre><code class="language-http">GET /cors HTTP/1.1
Origin: http://api.bob.com
Host: api.alice.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
</code></pre>
</blockquote>
<p>上面的头信息中，<code>Origin</code>字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p>
<p>如果<code>Origin</code>指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含<code>Access-Control-Allow-Origin</code>字段（详见下文），就知道出错了，从而抛出一个错误，被<code>XMLHttpRequest</code>的<code>onerror</code>回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。</p>
<p>如果<code>Origin</code>指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p>
<blockquote>
<pre><code class="language-http">Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Credentials: true
Access-Control-Expose-Headers: FooBar
Content-Type: text/html; charset=utf-8
</code></pre>
</blockquote>
<p>上面的头信息之中，有三个与CORS请求相关的字段，都以<code>Access-Control-</code>开头。</p>
<p><strong>（1）Access-Control-Allow-Origin</strong></p>
<p>该字段是必须的。它的值要么是请求时<code>Origin</code>字段的值，要么是一个<code>*</code>，表示接受任意域名的请求。</p>
<p><strong>（2）Access-Control-Allow-Credentials</strong></p>
<p>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为<code>true</code>，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为<code>true</code>，如果服务器不要浏览器发送Cookie，删除该字段即可。</p>
<p><strong>（3）Access-Control-Expose-Headers</strong></p>
<p>该字段可选。CORS请求时，<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到6个基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定。上面的例子指定，<code>getResponseHeader('FooBar')</code>可以返回<code>FooBar</code>字段的值。</p>
<h3 id="32-withcredentials-属性">3.2 withCredentials 属性</h3>
<p>上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定<code>Access-Control-Allow-Credentials</code>字段。</p>
<blockquote>
<pre><code class="language-http">Access-Control-Allow-Credentials: true
</code></pre>
</blockquote>
<p>另一方面，开发者必须在AJAX请求中打开<code>withCredentials</code>属性。</p>
<blockquote>
<pre><code class="language-javascript">var xhr = new XMLHttpRequest();
xhr.withCredentials = true;
</code></pre>
</blockquote>
<p>否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。</p>
<p>但是，如果省略<code>withCredentials</code>设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭<code>withCredentials</code>。</p>
<blockquote>
<pre><code class="language-javascript">xhr.withCredentials = false;
</code></pre>
</blockquote>
<p>需要注意的是，如果要发送Cookie，<code>Access-Control-Allow-Origin</code>就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的<code>document.cookie</code>也无法读取服务器域名下的Cookie。</p>
<h2 id="四-非简单请求">四、非简单请求</h2>
<h3 id="41-预检请求">4.1 预检请求</h3>
<p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是<code>PUT</code>或<code>DELETE</code>，或者<code>Content-Type</code>字段的类型是<code>application/json</code>。</p>
<p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为&quot;预检&quot;请求（preflight）。</p>
<p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错。</p>
<p>下面是一段浏览器的JavaScript脚本。</p>
<blockquote>
<pre><code class="language-javascript">var url = 'http://api.alice.com/cors';
var xhr = new XMLHttpRequest();
xhr.open('PUT', url, true);
xhr.setRequestHeader('X-Custom-Header', 'value');
xhr.send();
</code></pre>
</blockquote>
<p>上面代码中，HTTP请求的方法是<code>PUT</code>，并且发送一个自定义头信息<code>X-Custom-Header</code>。</p>
<p>浏览器发现，这是一个非简单请求，就自动发出一个&quot;预检&quot;请求，要求服务器确认可以这样请求。下面是这个&quot;预检&quot;请求的HTTP头信息。</p>
<blockquote>
<pre><code class="language-http">OPTIONS /cors HTTP/1.1
Origin: http://api.bob.com
Access-Control-Request-Method: PUT
Access-Control-Request-Headers: X-Custom-Header
Host: api.alice.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
</code></pre>
</blockquote>
<p>&quot;预检&quot;请求用的请求方法是<code>OPTIONS</code>，表示这个请求是用来询问的。头信息里面，关键字段是<code>Origin</code>，表示请求来自哪个源。</p>
<p>除了<code>Origin</code>字段，&quot;预检&quot;请求的头信息包括两个特殊字段。</p>
<p><strong>（1）Access-Control-Request-Method</strong></p>
<p>该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是<code>PUT</code>。</p>
<p><strong>（2）Access-Control-Request-Headers</strong></p>
<p>该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是<code>X-Custom-Header</code>。</p>
<h3 id="42-预检请求的回应">4.2 预检请求的回应</h3>
<p>服务器收到&quot;预检&quot;请求以后，检查了<code>Origin</code>、<code>Access-Control-Request-Method</code>和<code>Access-Control-Request-Headers</code>字段以后，确认允许跨源请求，就可以做出回应。</p>
<blockquote>
<pre><code class="language-http">HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:15:39 GMT
Server: Apache/2.0.61 (Unix)
Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
Content-Type: text/html; charset=utf-8
Content-Encoding: gzip
Content-Length: 0
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Content-Type: text/plain
</code></pre>
</blockquote>
<p>上面的HTTP回应中，关键的是<code>Access-Control-Allow-Origin</code>字段，表示<code>http://api.bob.com</code>可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。</p>
<blockquote>
<pre><code class="language-http">Access-Control-Allow-Origin: *
</code></pre>
</blockquote>
<p>如果服务器否定了&quot;预检&quot;请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被<code>XMLHttpRequest</code>对象的<code>onerror</code>回调函数捕获。控制台会打印出如下的报错信息。</p>
<blockquote>
<pre><code class="language-bash">XMLHttpRequest cannot load http://api.alice.com.
Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.
</code></pre>
</blockquote>
<p>服务器回应的其他CORS相关字段如下。</p>
<blockquote>
<pre><code class="language-http">Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
Access-Control-Allow-Credentials: true
Access-Control-Max-Age: 1728000
</code></pre>
</blockquote>
<p><strong>（1）Access-Control-Allow-Methods</strong></p>
<p>该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次&quot;预检&quot;请求。</p>
<p><strong>（2）Access-Control-Allow-Headers</strong></p>
<p>如果浏览器请求包括<code>Access-Control-Request-Headers</code>字段，则<code>Access-Control-Allow-Headers</code>字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在&quot;预检&quot;中请求的字段。</p>
<p><strong>（3）Access-Control-Allow-Credentials</strong></p>
<p>该字段与简单请求时的含义相同。</p>
<p><strong>（4）Access-Control-Max-Age</strong></p>
<p>该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。</p>
<h3 id="43-浏览器的正常请求和回应">4.3 浏览器的正常请求和回应</h3>
<p>一旦服务器通过了&quot;预检&quot;请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个<code>Origin</code>头信息字段。服务器的回应，也都会有一个<code>Access-Control-Allow-Origin</code>头信息字段。</p>
<p>下面是&quot;预检&quot;请求之后，浏览器的正常CORS请求。</p>
<blockquote>
<pre><code class="language-http">PUT /cors HTTP/1.1
Origin: http://api.bob.com
Host: api.alice.com
X-Custom-Header: value
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
</code></pre>
</blockquote>
<p>上面头信息的<code>Origin</code>字段是浏览器自动添加的。</p>
<p>下面是服务器正常的回应。</p>
<blockquote>
<pre><code class="language-http">Access-Control-Allow-Origin: http://api.bob.com
Content-Type: text/html; charset=utf-8
</code></pre>
</blockquote>
<p>上面头信息中，<code>Access-Control-Allow-Origin</code>字段是每次回应都必定包含的。</p>
<h2 id="五-与jsonp的比较">五、与JSONP的比较</h2>
<p>CORS与JSONP的使用目的相同，但是比JSONP更强大。</p>
<p>JSONP只支持<code>GET</code>请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</p>
<h2 id="转载">转载</h2>
<blockquote>
<p>阮一峰</p>
<p><a href="https://www.ruanyifeng.com/blog/2016/04/cors.html">https://www.ruanyifeng.com/blog/2016/04/cors.html</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[http-浏览器同源政策及其规避方法]]></title>
        <id>https://leecss.com/post/http-kua-yu/</id>
        <link href="https://leecss.com/post/http-kua-yu/">
        </link>
        <updated>2021-07-13T13:37:13.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>**「同源策略」**是一个重要的安全策略，它用于限制一个<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Origin">origin</a>的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。</p>
<p>--来源 MDN</p>
<h2 id="一-概述">一、概述</h2>
<h3 id="11-含义">1.1 含义</h3>
<p>1995年，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策。</p>
<p>最初，它的含义是指，A网页设置的 Cookie，B网页不能打开，除非这两个网页&quot;同源&quot;。所谓&quot;同源&quot;指的是&quot;三个相同&quot;。</p>
<blockquote>
<ul>
<li>协议相同</li>
<li>域名相同</li>
<li>端口相同</li>
</ul>
</blockquote>
<p>举例来说，<code>http://www.example.com/dir/page.html</code>这个网址，协议是<code>http://</code>，域名是<code>www.example.com</code>，端口是<code>80</code>（默认端口可以省略）。它的同源情况如下。</p>
<blockquote>
<ul>
<li><code>http://www.example.com/dir2/other.html</code>：同源</li>
<li><code>http://example.com/dir/other.html</code>：不同源（域名不同）</li>
<li><code>http://v2.www.example.com/dir/other.html</code>：不同源（域名不同）</li>
<li><code>http://www.example.com:81/dir/other.html</code>：不同源（端口不同）</li>
</ul>
</blockquote>
<h3 id="12-目的">1.2 目的</h3>
<p>同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。</p>
<p>设想这样一种情况：A网站是一家银行，用户登录以后，又去浏览其他网站。如果其他网站可以读取A网站的 Cookie，会发生什么？</p>
<p>很显然，如果 Cookie 包含隐私（比如存款总额），这些信息就会泄漏。更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。</p>
<p>由此可见，&quot;同源政策&quot;是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了。</p>
<h3 id="13-限制范围">1.3 限制范围</h3>
<p>随着互联网的发展，&quot;同源政策&quot;越来越严格。目前，如果非同源，共有三种行为受到限制。</p>
<blockquote>
<p>（1） Cookie、LocalStorage 和 IndexDB 无法读取。</p>
<p>（2） DOM 无法获得。</p>
<p>（3） AJAX 请求不能发送。</p>
</blockquote>
<p>虽然这些限制是必要的，但是有时很不方便，合理的用途也受到影响。下面，我将详细介绍，如何规避上面三种限制。</p>
<h2 id="二-cookie">二、Cookie</h2>
<p>Cookie 是服务器写入浏览器的一小段信息，只有同源的网页才能共享。但是，两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置<code>document.domain</code>共享 Cookie。</p>
<p>举例来说，A网页是<code>http://w1.example.com/a.html</code>，B网页是<code>http://w2.example.com/b.html</code>，那么只要设置相同的<code>document.domain</code>，两个网页就可以共享Cookie。</p>
<blockquote>
<pre><code class="language-javascript">document.domain = 'example.com';
</code></pre>
</blockquote>
<p>现在，A网页通过脚本设置一个 Cookie。</p>
<blockquote>
<pre><code class="language-javascript">document.cookie = &quot;test1=hello&quot;;
</code></pre>
</blockquote>
<p>B网页就可以读到这个 Cookie。</p>
<blockquote>
<pre><code class="language-javascript">var allCookie = document.cookie;
</code></pre>
</blockquote>
<p>注意，这种方法只适用于 Cookie 和 iframe 窗口，LocalStorage 和 IndexDB 无法通过这种方法，规避同源政策，而要使用下文介绍的PostMessage API。</p>
<p>另外，服务器也可以在设置Cookie的时候，指定Cookie的所属域名为一级域名，比如<code>.example.com</code>。</p>
<blockquote>
<pre><code class="language-http">Set-Cookie: key=value; domain=.example.com; path=/
</code></pre>
</blockquote>
<p>这样的话，二级域名和三级域名不用做任何设置，都可以读取这个Cookie。</p>
<h2 id="三-iframe">三、iframe</h2>
<p>如果两个网页不同源，就无法拿到对方的DOM。典型的例子是<code>iframe</code>窗口和<code>window.open</code>方法打开的窗口，它们与父窗口无法通信。</p>
<p>比如，父窗口运行下面的命令，如果<code>iframe</code>窗口不是同源，就会报错。</p>
<blockquote>
<pre><code class="language-javascript">document.getElementById(&quot;myIFrame&quot;).contentWindow.document
// Uncaught DOMException: Blocked a frame from accessing a cross-origin frame.
</code></pre>
</blockquote>
<p>上面命令中，父窗口想获取子窗口的DOM，因为跨源导致报错。</p>
<p>反之亦然，子窗口获取主窗口的DOM也会报错。</p>
<blockquote>
<pre><code class="language-javascript">window.parent.document.body
// 报错
</code></pre>
</blockquote>
<p>如果两个窗口一级域名相同，只是二级域名不同，那么设置上一节介绍的<code>document.domain</code>属性，就可以规避同源政策，拿到DOM。</p>
<p>对于完全不同源的网站，目前有三种方法，可以解决跨域窗口的通信问题。</p>
<blockquote>
<ul>
<li>片段识别符（fragment identifier）</li>
<li>window.name</li>
<li>跨文档通信API（Cross-document messaging）</li>
</ul>
</blockquote>
<h3 id="31-片段识别符">3.1 片段识别符</h3>
<p>片段标识符（fragment identifier）指的是，URL的<code>#</code>号后面的部分，比如<code>http://example.com/x.html#fragment</code>的<code>#fragment</code>。如果只是改变片段标识符，页面不会重新刷新。</p>
<p>父窗口可以把信息，写入子窗口的片段标识符。</p>
<blockquote>
<pre><code class="language-javascript">var src = originURL + '#' + data;
document.getElementById('myIFrame').src = src;
</code></pre>
</blockquote>
<p>子窗口通过监听<code>hashchange</code>事件得到通知。</p>
<blockquote>
<pre><code class="language-javascript">window.onhashchange = checkMessage;

function checkMessage() {
  var message = window.location.hash;
  // ...
}
</code></pre>
</blockquote>
<p>同样的，子窗口也可以改变父窗口的片段标识符。</p>
<blockquote>
<pre><code class="language-javascript">parent.location.href= target + &quot;#&quot; + hash;
</code></pre>
</blockquote>
<h3 id="32-windowname">3.2 window.name</h3>
<p>浏览器窗口有<code>window.name</code>属性。这个属性的最大特点是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。</p>
<p>父窗口先打开一个子窗口，载入一个不同源的网页，该网页将信息写入<code>window.name</code>属性。</p>
<blockquote>
<pre><code class="language-javascript">window.name = data;
</code></pre>
</blockquote>
<p>接着，子窗口跳回一个与主窗口同域的网址。</p>
<blockquote>
<pre><code class="language-javascript">location = 'http://parent.url.com/xxx.html';
</code></pre>
</blockquote>
<p>然后，主窗口就可以读取子窗口的<code>window.name</code>了。</p>
<blockquote>
<pre><code class="language-javascript">var data = document.getElementById('myFrame').contentWindow.name;
</code></pre>
</blockquote>
<p>这种方法的优点是，<code>window.name</code>容量很大，可以放置非常长的字符串；缺点是必须监听子窗口<code>window.name</code>属性的变化，影响网页性能。</p>
<h3 id="33-windowpostmessage">3.3 window.postMessage</h3>
<p>上面两种方法都属于破解，HTML5为了解决这个问题，引入了一个全新的API：跨文档通信 API（Cross-document messaging）。</p>
<p>这个API为<code>window</code>对象新增了一个<code>window.postMessage</code>方法，允许跨窗口通信，不论这两个窗口是否同源。</p>
<p>举例来说，父窗口<code>http://aaa.com</code>向子窗口<code>http://bbb.com</code>发消息，调用<code>postMessage</code>方法就可以了。</p>
<blockquote>
<pre><code class="language-javascript">var popup = window.open('http://bbb.com', 'title');
popup.postMessage('Hello World!', 'http://bbb.com');
</code></pre>
</blockquote>
<p><code>postMessage</code>方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源（origin），即&quot;协议 + 域名 + 端口&quot;。也可以设为<code>*</code>，表示不限制域名，向所有窗口发送。</p>
<p>子窗口向父窗口发送消息的写法类似。</p>
<blockquote>
<pre><code class="language-javascript">window.opener.postMessage('Nice to see you', 'http://aaa.com');
</code></pre>
</blockquote>
<p>父窗口和子窗口都可以通过<code>message</code>事件，监听对方的消息。</p>
<blockquote>
<pre><code class="language-javascript">window.addEventListener('message', function(e) {
  console.log(e.data);
},false);
</code></pre>
</blockquote>
<p><code>message</code>事件的事件对象<code>event</code>，提供以下三个属性。</p>
<blockquote>
<ul>
<li><code>event.source</code>：发送消息的窗口</li>
<li><code>event.origin</code>: 消息发向的网址</li>
<li><code>event.data</code>: 消息内容</li>
</ul>
</blockquote>
<p>下面的例子是，子窗口通过<code>event.source</code>属性引用父窗口，然后发送消息。</p>
<blockquote>
<pre><code class="language-javascript">window.addEventListener('message', receiveMessage);
function receiveMessage(event) {
  event.source.postMessage('Nice to see you!', '*');
}
</code></pre>
</blockquote>
<p><code>event.origin</code>属性可以过滤不是发给本窗口的消息。</p>
<blockquote>
<pre><code class="language-javascript">window.addEventListener('message', receiveMessage);
function receiveMessage(event) {
  if (event.origin !== 'http://aaa.com') return;
  if (event.data === 'Hello World') {
      event.source.postMessage('Hello', event.origin);
  } else {
    console.log(event.data);
  }
}
</code></pre>
</blockquote>
<h3 id="34-localstorage">3.4 LocalStorage</h3>
<p>通过<code>window.postMessage</code>，读写其他窗口的 LocalStorage 也成为了可能。</p>
<p>下面是一个例子，主窗口写入iframe子窗口的<code>localStorage</code>。</p>
<blockquote>
<pre><code class="language-javascript">window.onmessage = function(e) {
  if (e.origin !== 'http://bbb.com') {
    return;
  }
  var payload = JSON.parse(e.data);
  localStorage.setItem(payload.key, JSON.stringify(payload.data));
};
</code></pre>
</blockquote>
<p>上面代码中，子窗口将父窗口发来的消息，写入自己的LocalStorage。</p>
<p>父窗口发送消息的代码如下。</p>
<blockquote>
<pre><code class="language-javascript">var win = document.getElementsByTagName('iframe')[0].contentWindow;
var obj = { name: 'Jack' };
win.postMessage(JSON.stringify({key: 'storage', data: obj}), 'http://bbb.com');
</code></pre>
</blockquote>
<p>加强版的子窗口接收消息的代码如下。</p>
<blockquote>
<pre><code class="language-javascript">window.onmessage = function(e) {
  if (e.origin !== 'http://bbb.com') return;
  var payload = JSON.parse(e.data);
  switch (payload.method) {
    case 'set':
      localStorage.setItem(payload.key, JSON.stringify(payload.data));
      break;
    case 'get':
      var parent = window.parent;
      var data = localStorage.getItem(payload.key);
      parent.postMessage(data, 'http://aaa.com');
      break;
    case 'remove':
      localStorage.removeItem(payload.key);
      break;
  }
};
</code></pre>
</blockquote>
<p>加强版的父窗口发送消息代码如下。</p>
<blockquote>
<pre><code class="language-javascript">var win = document.getElementsByTagName('iframe')[0].contentWindow;
var obj = { name: 'Jack' };
// 存入对象
win.postMessage(JSON.stringify({key: 'storage', method: 'set', data: obj}), 'http://bbb.com');
// 读取对象
win.postMessage(JSON.stringify({key: 'storage', method: &quot;get&quot;}), &quot;*&quot;);
window.onmessage = function(e) {
  if (e.origin != 'http://aaa.com') return;
  // &quot;Jack&quot;
  console.log(JSON.parse(e.data).name);
};
</code></pre>
</blockquote>
<h2 id="四-ajax">四、AJAX</h2>
<p>同源政策规定，AJAX请求只能发给同源的网址，否则就报错。</p>
<p>除了架设服务器代理（浏览器请求同源服务器，再由后者请求外部服务），有三种方法规避这个限制。</p>
<blockquote>
<ul>
<li>JSONP</li>
<li>WebSocket</li>
<li>CORS</li>
</ul>
</blockquote>
<h3 id="41-jsonp">4.1 JSONP</h3>
<p>JSONP是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，老式浏览器全部支持，服务器改造非常小。</p>
<p>它的基本思想是，网页通过添加一个<code>&lt;script&gt;</code>元素，向服务器请求JSON数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。</p>
<p>首先，网页动态插入<code>&lt;script&gt;</code>元素，由它向跨源网址发出请求。</p>
<blockquote>
<pre><code class="language-javascript">function addScriptTag(src) {
  var script = document.createElement('script');
  script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;);
  script.src = src;
  document.body.appendChild(script);
}

window.onload = function () {
  addScriptTag('http://example.com/ip?callback=foo');
}

function foo(data) {
  console.log('Your public IP address is: ' + data.ip);
};
</code></pre>
</blockquote>
<p>上面代码通过动态添加<code>&lt;script&gt;</code>元素，向服务器<code>example.com</code>发出请求。注意，该请求的查询字符串有一个<code>callback</code>参数，用来指定回调函数的名字，这对于JSONP是必需的。</p>
<p>服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。</p>
<blockquote>
<pre><code class="language-javascript">foo({
  &quot;ip&quot;: &quot;8.8.8.8&quot;
});
</code></pre>
</blockquote>
<p>由于<code>&lt;script&gt;</code>元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了<code>foo</code>函数，该函数就会立即调用。作为参数的JSON数据被视为JavaScript对象，而不是字符串，因此避免了使用<code>JSON.parse</code>的步骤。</p>
<h3 id="42-websocket">4.2 WebSocket</h3>
<p>WebSocket是一种通信协议，使用<code>ws://</code>（非加密）和<code>wss://</code>（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。</p>
<p>下面是一个例子，浏览器发出的WebSocket请求的头信息（摘自<a href="https://en.wikipedia.org/wiki/WebSocket">维基百科</a>）。</p>
<blockquote>
<pre><code class="language-http">GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
Origin: http://example.com
</code></pre>
</blockquote>
<p>上面代码中，有一个字段是<code>Origin</code>，表示该请求的请求源（origin），即发自哪个域名。</p>
<p>正是因为有了<code>Origin</code>这个字段，所以WebSocket才没有实行同源政策。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。</p>
<blockquote>
<pre><code class="language-http">HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=
Sec-WebSocket-Protocol: chat
</code></pre>
</blockquote>
<h3 id="43-cors">4.3 CORS</h3>
<p>CORS是跨源资源分享（Cross-Origin Resource Sharing）的缩写。它是W3C标准，是跨源AJAX请求的根本解决方法。相比JSONP只能发<code>GET</code>请求，CORS允许任何类型的请求。</p>
<h2 id="转载">转载</h2>
<blockquote>
<p>阮一峰</p>
<p><a href="https://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html">https://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[http-curl命令行]]></title>
        <id>https://leecss.com/post/http-curl-ming-ling-xing/</id>
        <link href="https://leecss.com/post/http-curl-ming-ling-xing/">
        </link>
        <updated>2021-07-12T13:39:28.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p><a href="http://curl.haxx.se/">curl</a>是一种命令行工具，作用是发出网络请求，然后得到和提取数据，显示在&quot;标准输出&quot;（stdout）上面。</p>
<p><strong>一、查看网页源码</strong></p>
<p>直接在curl命令后加上网址，就可以看到网页源码。我们以网址baidu.com为例（选择该网址，主要因为它的网页代码较短）：</p>
<pre><code class="language-shell">curl baidu.com
</code></pre>
<pre><code class="language-html">&lt;html&gt;
&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;url=http://www.baidu.com/&quot;&gt;
&lt;/html&gt;
</code></pre>
<p>页面会重定向到百度</p>
<p>如果要把这个网页保存下来，可以使用<code>-o</code>参数，这就相当于使用wget命令了。</p>
<pre><code class="language-sh">curl -o [文件名] baidu.com
</code></pre>
<pre><code class="language-sh">curl -o baudu.html baidu.com
</code></pre>
<p><strong>二、显示头信息</strong></p>
<p><code>-i</code>参数可以显示http response的头信息，连同网页代码一起。</p>
<p><code>-I</code>参数则是只显示http response的头信息。</p>
<pre><code class="language-sh">curl -i baidu.com
</code></pre>
<pre><code class="language-shell">HTTP/1.1 200 OK                                                   
Date: Sun, 06 Jun 2021 08:49:54 GMT                               
Server: Apache                                                    
Last-Modified: Tue, 12 Jan 2010 13:48:00 GMT                      
ETag: &quot;51-47cf7e6ee8400&quot;                                          
Accept-Ranges: bytes                                              
Content-Length: 81                                                
Cache-Control: max-age=86400                                      
Expires: Mon, 07 Jun 2021 08:49:54 GMT                            
Connection: Keep-Alive                                            
Content-Type: text/html                                           
                                                                  
&lt;html&gt;                                                            
&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;url=http://www.baidu.com/&quot;&gt; 
&lt;/html&gt;                                                           
</code></pre>
<p><strong>三、显示通信过程</strong></p>
<p><code>-v</code>参数可以显示一次http通信的整个过程，包括端口连接和http request头信息。</p>
<pre><code class="language-sh">curl -v baidu.com
</code></pre>
<pre><code class="language-shell">* Rebuilt URL to: baidu.com/
*   Trying 220.181.38.148...
* TCP_NODELAY set
* Connected to baidu.com (220.181.38.148) port 80 (#0)
&gt; GET / HTTP/1.1
&gt; Host: baidu.com
&gt; User-Agent: curl/7.55.1
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 200 OK
&lt; Date: Sun, 06 Jun 2021 08:53:20 GMT
&lt; Server: Apache
&lt; Last-Modified: Tue, 12 Jan 2010 13:48:00 GMT
&lt; ETag: &quot;51-47cf7e6ee8400&quot;
&lt; Accept-Ranges: bytes
&lt; Content-Length: 81
&lt; Cache-Control: max-age=86400
&lt; Expires: Mon, 07 Jun 2021 08:53:20 GMT
&lt; Connection: Keep-Alive
&lt; Content-Type: text/html
&lt;
&lt;html&gt;
&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;url=http://www.baidu.com/&quot;&gt;
&lt;/html&gt;
* Connection #0 to host baidu.com left intact
</code></pre>
<p>如果你觉得上面的信息还不够，那么下面的命令可以查看更详细的通信过程。</p>
<pre><code class="language-sh">curl --trace output.txt baidu.com
</code></pre>
<pre><code class="language-sh">curl --trace-ascii output.txt baidu.com
</code></pre>
<p>推荐阅读</p>
<blockquote>
<p>阮一峰</p>
<p><a href="http://www.ruanyifeng.com/blog/2019/09/curl-reference.html">http://www.ruanyifeng.com/blog/2019/09/curl-reference.html</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[http-使用node创建一个简单的web服务]]></title>
        <id>https://leecss.com/post/http-shi-yong-node-chuang-jian-yi-ge-jian-dan-de-web-fu-wu/</id>
        <link href="https://leecss.com/post/http-shi-yong-node-chuang-jian-yi-ge-jian-dan-de-web-fu-wu/">
        </link>
        <updated>2021-07-12T12:47:16.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>电脑上安装好node,新建server.js文件，使用<code>node server.js</code>运行该文件。</p>
<h2 id="代码">代码</h2>
<pre><code class="language-js">const http = require('http')

http.createServer(function (request, response) {
    console.log('request come', request.url)

    response.end('123')
}).listen(8888)

console.log('server listening on 8888')
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[http-状态码]]></title>
        <id>https://leecss.com/post/http-zhuang-tai-ma/</id>
        <link href="https://leecss.com/post/http-zhuang-tai-ma/">
        </link>
        <updated>2021-07-09T00:05:15.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。</p>
<p>HTTP状态码的英文为HTTP Status Code。</p>
<p>下面是常见的HTTP状态码：</p>
<ul>
<li>200 - 请求成功</li>
<li>301 - 资源（网页等）被永久转移到其它URL</li>
<li>404 - 请求的资源（网页等）不存在</li>
<li>500 - 内部服务器错误</li>
</ul>
<h2 id="http状态码分类">HTTP状态码分类</h2>
<p>HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型：</p>
<table>
<thead>
<tr>
<th style="text-align:left">分类</th>
<th style="text-align:left">分类描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1**</td>
<td style="text-align:left">信息，服务器收到请求，需要请求者继续执行操作</td>
</tr>
<tr>
<td style="text-align:left">2**</td>
<td style="text-align:left">成功，操作被成功接收并处理</td>
</tr>
<tr>
<td style="text-align:left">3**</td>
<td style="text-align:left">重定向，需要进一步的操作以完成请求</td>
</tr>
<tr>
<td style="text-align:left">4**</td>
<td style="text-align:left">客户端错误，请求包含语法错误或无法完成请求</td>
</tr>
<tr>
<td style="text-align:left">5**</td>
<td style="text-align:left">服务器错误，服务器在处理请求的过程中发生了错误</td>
</tr>
</tbody>
</table>
<p>HTTP状态码列表:</p>
<table>
<thead>
<tr>
<th style="text-align:left">状态码</th>
<th style="text-align:left">状态码英文名称</th>
<th style="text-align:left">中文描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">100</td>
<td style="text-align:left">Continue</td>
<td style="text-align:left">继续。客户端应继续其请求</td>
</tr>
<tr>
<td style="text-align:left">101</td>
<td style="text-align:left">Switching Protocols</td>
<td style="text-align:left">切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">200</td>
<td style="text-align:left">OK</td>
<td style="text-align:left">请求成功。一般用于GET与POST请求</td>
</tr>
<tr>
<td style="text-align:left">201</td>
<td style="text-align:left">Created</td>
<td style="text-align:left">已创建。成功请求并创建了新的资源</td>
</tr>
<tr>
<td style="text-align:left">202</td>
<td style="text-align:left">Accepted</td>
<td style="text-align:left">已接受。已经接受请求，但未处理完成</td>
</tr>
<tr>
<td style="text-align:left">203</td>
<td style="text-align:left">Non-Authoritative Information</td>
<td style="text-align:left">非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td>
</tr>
<tr>
<td style="text-align:left">204</td>
<td style="text-align:left">No Content</td>
<td style="text-align:left">无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td>
</tr>
<tr>
<td style="text-align:left">205</td>
<td style="text-align:left">Reset Content</td>
<td style="text-align:left">重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td>
</tr>
<tr>
<td style="text-align:left">206</td>
<td style="text-align:left">Partial Content</td>
<td style="text-align:left">部分内容。服务器成功处理了部分GET请求</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">300</td>
<td style="text-align:left">Multiple Choices</td>
<td style="text-align:left">多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td>
</tr>
<tr>
<td style="text-align:left">301</td>
<td style="text-align:left">Moved Permanently</td>
<td style="text-align:left">永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td>
</tr>
<tr>
<td style="text-align:left">302</td>
<td style="text-align:left">Found</td>
<td style="text-align:left">临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td>
</tr>
<tr>
<td style="text-align:left">303</td>
<td style="text-align:left">See Other</td>
<td style="text-align:left">查看其它地址。与301类似。使用GET和POST请求查看</td>
</tr>
<tr>
<td style="text-align:left">304</td>
<td style="text-align:left">Not Modified</td>
<td style="text-align:left">未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td>
</tr>
<tr>
<td style="text-align:left">305</td>
<td style="text-align:left">Use Proxy</td>
<td style="text-align:left">使用代理。所请求的资源必须通过代理访问</td>
</tr>
<tr>
<td style="text-align:left">306</td>
<td style="text-align:left">Unused</td>
<td style="text-align:left">已经被废弃的HTTP状态码</td>
</tr>
<tr>
<td style="text-align:left">307</td>
<td style="text-align:left">Temporary Redirect</td>
<td style="text-align:left">临时重定向。与302类似。使用GET请求重定向</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">400</td>
<td style="text-align:left">Bad Request</td>
<td style="text-align:left">客户端请求的语法错误，服务器无法理解</td>
</tr>
<tr>
<td style="text-align:left">401</td>
<td style="text-align:left">Unauthorized</td>
<td style="text-align:left">请求要求用户的身份认证</td>
</tr>
<tr>
<td style="text-align:left">402</td>
<td style="text-align:left">Payment Required</td>
<td style="text-align:left">保留，将来使用</td>
</tr>
<tr>
<td style="text-align:left">403</td>
<td style="text-align:left">Forbidden</td>
<td style="text-align:left">服务器理解请求客户端的请求，但是拒绝执行此请求</td>
</tr>
<tr>
<td style="text-align:left">404</td>
<td style="text-align:left">Not Found</td>
<td style="text-align:left">服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置&quot;您所请求的资源无法找到&quot;的个性页面</td>
</tr>
<tr>
<td style="text-align:left">405</td>
<td style="text-align:left">Method Not Allowed</td>
<td style="text-align:left">客户端请求中的方法被禁止</td>
</tr>
<tr>
<td style="text-align:left">406</td>
<td style="text-align:left">Not Acceptable</td>
<td style="text-align:left">服务器无法根据客户端请求的内容特性完成请求</td>
</tr>
<tr>
<td style="text-align:left">407</td>
<td style="text-align:left">Proxy Authentication Required</td>
<td style="text-align:left">请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td>
</tr>
<tr>
<td style="text-align:left">408</td>
<td style="text-align:left">Request Time-out</td>
<td style="text-align:left">服务器等待客户端发送的请求时间过长，超时</td>
</tr>
<tr>
<td style="text-align:left">409</td>
<td style="text-align:left">Conflict</td>
<td style="text-align:left">服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</td>
</tr>
<tr>
<td style="text-align:left">410</td>
<td style="text-align:left">Gone</td>
<td style="text-align:left">客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td>
</tr>
<tr>
<td style="text-align:left">411</td>
<td style="text-align:left">Length Required</td>
<td style="text-align:left">服务器无法处理客户端发送的不带Content-Length的请求信息</td>
</tr>
<tr>
<td style="text-align:left">412</td>
<td style="text-align:left">Precondition Failed</td>
<td style="text-align:left">客户端请求信息的先决条件错误</td>
</tr>
<tr>
<td style="text-align:left">413</td>
<td style="text-align:left">Request Entity Too Large</td>
<td style="text-align:left">由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td>
</tr>
<tr>
<td style="text-align:left">414</td>
<td style="text-align:left">Request-URI Too Large</td>
<td style="text-align:left">请求的URI过长（URI通常为网址），服务器无法处理</td>
</tr>
<tr>
<td style="text-align:left">415</td>
<td style="text-align:left">Unsupported Media Type</td>
<td style="text-align:left">服务器无法处理请求附带的媒体格式</td>
</tr>
<tr>
<td style="text-align:left">416</td>
<td style="text-align:left">Requested range not satisfiable</td>
<td style="text-align:left">客户端请求的范围无效</td>
</tr>
<tr>
<td style="text-align:left">417</td>
<td style="text-align:left">Expectation Failed</td>
<td style="text-align:left">服务器无法满足Expect的请求头信息</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">500</td>
<td style="text-align:left">Internal Server Error</td>
<td style="text-align:left">服务器内部错误，无法完成请求</td>
</tr>
<tr>
<td style="text-align:left">501</td>
<td style="text-align:left">Not Implemented</td>
<td style="text-align:left">服务器不支持请求的功能，无法完成请求</td>
</tr>
<tr>
<td style="text-align:left">502</td>
<td style="text-align:left">Bad Gateway</td>
<td style="text-align:left">作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td>
</tr>
<tr>
<td style="text-align:left">503</td>
<td style="text-align:left">Service Unavailable</td>
<td style="text-align:left">由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td>
</tr>
<tr>
<td style="text-align:left">504</td>
<td style="text-align:left">Gateway Time-out</td>
<td style="text-align:left">充当网关或代理的服务器，未及时从远端服务器获取请求</td>
</tr>
<tr>
<td style="text-align:left">505</td>
<td style="text-align:left">HTTP Version not supported</td>
<td style="text-align:left">服务器不支持请求的HTTP协议的版本，无法完成处理</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[http-请求方法]]></title>
        <id>https://leecss.com/post/http-qing-qiu-fang-fa/</id>
        <link href="https://leecss.com/post/http-qing-qiu-fang-fa/">
        </link>
        <updated>2021-07-09T00:02:01.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>根据 HTTP 标准，HTTP 请求可以使用多种请求方法。</p>
<p>HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。</p>
<p>HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。</p>
<h2 id="方法">方法</h2>
<p><strong>幂等</strong>是说这个请求可以重复发送多次相同请求求，会返回相同的响应消息</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>请求指定的页面信息，并返回实体主体</td>
</tr>
<tr>
<td>HEAD</td>
<td>类似于 GET请求，但只返回响应报头，不返回响应正文</td>
</tr>
<tr>
<td>POST (非)</td>
<td>向指定资源提交数据（例如提交表单或者上传文件） 数据被包含在请求体中 POST请求可能会导致新的资源的建立和/或已有资源的修改</td>
</tr>
<tr>
<td>PUT</td>
<td>从客户端向服务器传送的数据取代指定的文档的内容</td>
</tr>
<tr>
<td>DELETE</td>
<td>请求服务器删除指定的页面</td>
</tr>
<tr>
<td>CONNECT</td>
<td>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>允许客户端查看服务器的性能</td>
</tr>
<tr>
<td>TRACE</td>
<td>回显服务器收到的请求，主要用于测试或诊断</td>
</tr>
<tr>
<td>PATCH(非)</td>
<td>是对 PUT 方法的补充，用来对已知资源进行局部更新 。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>GET：get方法一般用于获取服务器资源</p>
<p>POST：post方法一般用于传输实体主体</p>
<p>PUT：put方法一般用于传输文件</p>
<p>DELETE：delete方法用于删除文件</p>
<p>HEAD：head方法用于获取报文首部，不返回报文主体</p>
<p>OPTIONS：options方法用于询问请求URI资源支持的方法</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[http-报文]]></title>
        <id>https://leecss.com/post/http-bao-wen/</id>
        <link href="https://leecss.com/post/http-bao-wen/">
        </link>
        <updated>2021-07-08T15:04:50.000Z</updated>
        <content type="html"><![CDATA[<h2 id="http报文结构">HTTP报文结构</h2>
<p>用于HTTP协议交互的信息被称为HTTP报文。请求端（客户端）的HTTP报文叫做<strong>请求报文</strong>，响应端（服务器端）的叫做<strong>响应报文</strong>。HTTP报文本身是由多行（用CR+LF作换行符）数据构成的字符串文本。 HTTP报文大致可分为<strong>请求行/响应行、报文首部和报文主体</strong>两块。两者由最初出现的空行（CR+LF）来划分。</p>
<figure data-type="image" tabindex="1"><img src="https://leecss.com/post-images/1625756720174.png" alt="" loading="lazy"></figure>
<h3 id="请求报文">请求报文</h3>
<p>请求报文的请求行主要三个部分组成：请求方法、URI地址和HTTP协议版本号。</p>
<pre><code>POST /test/hi-there.txt HTTP/1.1
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://leecss.com/post-images/1625756732543.jpg" alt="" loading="lazy"></figure>
<h3 id="响应报文">响应报文</h3>
<p>响应报文的响应行主要三个部分组成：HTTP协议版本号、HTTP状态码和状态描述。</p>
<pre><code>HTTP/1.1 200 OK
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://leecss.com/post-images/1625756742764.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[http-URL]]></title>
        <id>https://leecss.com/post/http-url/</id>
        <link href="https://leecss.com/post/http-url/">
        </link>
        <updated>2021-07-08T14:13:44.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>HTTP协议使用 URI 定位互联网上的资源。</p>
<h2 id="定义">定义</h2>
<h3 id="uri">URI</h3>
<p>Uniform Resource Identifier：统一资源标识符</p>
<p>用来唯一标识互联网上的信息资源</p>
<p>URI包括URL和URN。</p>
<h3 id="url">URL</h3>
<p>Uniform Resource Locator：统一资源定位器</p>
<p><code>http://user:pass@host.com:80/path?query=string#hash</code></p>
<p>协议 用户名密码 域名或hostName 端口 路由 搜索参数 哈希(锚点定位)</p>
<p>上述格式的都叫做URL，平常见到的URI 基本都是URL</p>
<h3 id="urn">URN</h3>
<p>Uniform Resource Name：统一资源名称(永久统一资源定位符)</p>
<p>在资源移动之后还能被找到</p>
<p>目前还没有非常成熟的使用方案</p>
<hr>
<p>假如互联网上的资源换了位置，我们访问之前的路径就会404，但是URL并不会告诉你资源搬到了哪里，URN就是为了解决这个问题，当URN指向一个资源，无论它换了多少位置，依然可以找到它。</p>
<h2 id="关系">关系</h2>
<p>URI是抽象的定义，不管用什么方法表示，只要能定位一个资源，就叫URI</p>
<p>定位资源的两种方式：1，URL，用地址定位；2，URN，用名称定位。</p>
<p>举个例子：</p>
<p>找个具体的人（URI），</p>
<p>如果用地址：住在中国北京昌平区某村多少号房子第几间屋子的人 就是URL，</p>
<p>如果用身份证号+名字 去找就是URN。</p>
<hr>
<p>找个具体的学生(URI)</p>
<p>如果用地址： 南开小学三年二班的第一排第几列的人 就是URL</p>
<p>如果用学号+名字 去找就是URN</p>
<h2 id="推荐阅读">推荐阅读</h2>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Identifying_resources_on_the_Web">标志互联网上的内容</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[http-TCP/IP三次握手]]></title>
        <id>https://leecss.com/post/http-tcpip-san-ci-wo-shou/</id>
        <link href="https://leecss.com/post/http-tcpip-san-ci-wo-shou/">
        </link>
        <updated>2021-07-07T14:33:24.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>目的是为了保证可靠的通信</p>
<h2 id="三个版本的解释">三个版本的解释</h2>
<h3 id="版本一">版本一</h3>
<p>简单说，让双方都证实对方能发收。<br>
知道对方能收是因为收到对方的因为收到而发的回应。<br>
具体：<br>
1：A发，B收， B知道A能发<br>
2：B发，A收， A知道B能发收<br>
3：A发，B收， B知道A能收</p>
<hr>
<p>tcp三次握手是tcp的建立连接的过程，所谓连接就是客户端知道服务端的发送和接收能力是否正常，服务端知道客户端的发送和接收能力是否正常。</p>
<p>第一次握手，客户端向服务端发送报文，服务端接收到信息之后，知道了客户端的发送能力正常</p>
<p>第二次握手，服务端向客户端发送报文，客户端接收到了信息之后，知道了服务端的发送和接收能力都正常</p>
<p>第三次握手，客户端再向服务端发送报文，服务端接收到信息之后，知道了客户端的发送和接收能力都正常</p>
<p>至此，三次握手完成，客户端和服务端都确定了双方的发送和接收能力，可以进行数据传输了</p>
<h3 id="版本二图解http">版本二：图解HTTP</h3>
<p>按层次分，TCP 位于传输层，提供可靠的字节流服务。</p>
<p>所谓的字节流服务（Byte Stream Service）是指，为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理。而可靠的传输服务是指，能够把数据准确可靠地传给对方。一言以蔽之，TCP 协议为了更容易传送大数据才把数据分割，而且 TCP 协议能够确认数据最终是否送达到对方。</p>
<p><strong>确保数据能到达目标</strong></p>
<p>为了准确无误地将数据送达目标处，TCP 协议采用了三次握手（three-way handshaking）策略。用 TCP 协议把数据包送出去后，TCP不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了 TCP 的标志（flag） —— SYN（synchronize） 和ACK（acknowledgement）。</p>
<p>发送端首先发送一个带 SYN 标志的数据包给对方。接收端收到后，回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。最后，发送端再回传一个带 ACK 标志的数据包，代表“握手”结束。</p>
<p>若在握手过程中某个阶段莫名中断，TCP 协议会再次以相同的顺序发送相同的数据包。</p>
<figure data-type="image" tabindex="1"><img src="https://leecss.com/post-images/1625668531620.jpg" alt="" loading="lazy"></figure>
<p>除了上述三次握手，TCP 协议还有其他各种手段来保证通信的可靠性。</p>
<h3 id="版本三车小胖">版本三：车小胖</h3>
<p>TCP作为一种可靠传输控制协议，其<strong>核心思想</strong>：既要保证数据可靠传输，又要提高传输的效率，而用<strong>三次恰恰可以满足以上两方面的需求！</strong></p>
<p><strong>TCP可靠传输的精髓</strong>：TCP连接的一方A，由操作系统动态随机选取一个<strong>32位长的序列号（Initial Sequence Number）</strong>，假设A的初始序列号为1000，以该序列号为原点，对自己将要发送的每个字节的数据进行编号，1001，1002，1003…，并把自己的初始序列号ISN告诉B，<strong>让B有一个思想准备</strong>，什么样编号的数据是合法的，什么编号是非法的，比如编号900就是非法的，同时B还可以对A每一个编号的字节数据进行确认。如果A收到B确认编号为2001，则意味着字节编号为1001-2000，共1000个字节已经安全到达。</p>
<p>同理B也是类似的操作，假设B的初始序列号ISN为2000，以该序列号为原点，对自己将要发送的每个字节的数据进行编号，2001，2002，2003…，并把自己的初始序列号ISN告诉A，以便A可以确认B发送的每一个字节。如果B收到A确认编号为4001，则意味着字节编号为2001-4000，共2000个字节已经安全到达。</p>
<p><strong>一句话概括，TCP连接握手，握的是啥？</strong></p>
<p><strong>通信双方数据原点的序列号！</strong></p>
<p>以此核心思想我们来分析二、三、四次握手的过程。</p>
<p>A &lt;-------&gt; B</p>
<p><strong>四次握手的过程：</strong></p>
<p><strong>1.1</strong> A 发送同步信号<strong>SYN</strong> + <strong>A'sInitial sequence number</strong></p>
<p><strong>1.2</strong> B 确认收到A的同步信号，并记录A's ISN 到本地，命名 <strong>B's ACK sequence number<br>
**<br>
<strong>1.3</strong> B发送同步信号</strong>SYN** + **B's Initial sequence number<br>
**<br>
<strong>1.4</strong> A确认收到B的同步信号，并记录B's ISN 到本地，命名 <strong>A's ACK sequence number</strong></p>
<p>很显然1.2和1.3 这两个步骤可以合并，**只需要三次握手，**可以提高连接的速度与效率。</p>
<p><strong>二次握手的过程：</strong></p>
<p><strong>2.1</strong> A 发送同步信号<strong>SYN</strong> + <strong>A'sInitial sequence number</strong></p>
<p><strong>2.2</strong> B发送同步信号<strong>SYN</strong> + <strong>B'sInitial sequence number</strong> + <strong>B's ACK sequence number</strong></p>
<p>这里有一个问题，A与B就A的初始序列号达成了一致，这里是1000。<strong>但是</strong>B无法知道A是否已经接收到自己的同步信号，如果这个同步信号丢失了，<strong>A和B就B的初始序列号将无法达成一致。</strong></p>
<p>于是TCP的设计者将<strong>SYN这个同步标志位SYN设计成占用一个字节的编号（FIN标志位也是）</strong>，既然是一个字节的数据，按照TCP对有数据的TCP segment 必须确认的原则，所以在这里A必须给B一个确认，以确认A已经接收到B的同步信号。</p>
<p>有童鞋会说，如果A发给B的确认丢了，该如何？<br>
A会超时重传这个ACK吗？不会！<strong>TCP不会为没有数据的ACK超时重传</strong>。</p>
<p>那该如何是好？<strong>B如果没有收到A的ACK，会超时重传自己的SYN同步信号，一直到收到A的ACK为止。</strong></p>
<p><strong>补充阅读</strong></p>
<p><strong>第一个包，即A发给B的SYN 中途被丢，没有到达B</strong></p>
<p>A会周期性超时重传，直到收到B的确认</p>
<p><strong>第二个包，即B发给A的SYN +ACK 中途被丢，没有到达A</strong></p>
<p>B会周期性超时重传，直到收到A的确认</p>
<p><strong>第三个包，即A发给B的ACK 中途被丢，没有到达B</strong></p>
<p>A发完ACK，单方面认为TCP为 Established状态，而B显然认为TCP为Active状态：</p>
<p>a. 假定此时双方都没有数据发送，B会周期性超时重传，直到收到A的确认，收到之后B的TCP 连接也为 Established状态，双向可以发包。</p>
<p>b. 假定此时A有数据发送，B收到A的 Data + ACK，自然会切换为established 状态，并接受A的Data。</p>
<p>c. 假定B有数据发送，数据发送不了，会一直周期性超时重传SYN + ACK，直到收到A的确认才可以发送数据。</p>
<hr>
<p>记得第一次看TCP握手连接的时候，有同样的疑问，我的疑问是，为何不是两次呢？</p>
<p>后来随着对网络的理解深入，明白TCP报文是交由IP网络来负责运输，IP网络并不能保证TCP报文到达目的地，既然IP网络是指望不上了，那TCP就自力更生吧，TCP必须依赖自身的努力来保证数据传输的可靠。</p>
<p>TCP看似复杂，其实可以归纳为以下5种报文：</p>
<p><strong>（1）</strong>   <strong>SYN</strong></p>
<p><strong>（2）</strong>   <strong>Data</strong> <strong>（唯一携带用户数据）</strong></p>
<p><strong>（3）</strong>   <strong>FIN</strong></p>
<p><strong>（4）</strong>   <strong>Reset</strong></p>
<p><strong>（5）</strong>   <strong>ACK</strong></p>
<p>其中1、2、3分别为<strong>建立连接、数据传输、断开连接</strong>，这三种报文对方接收到一定要ACK确认，为何要确认，因为这就是可靠传输的依赖的机制。如果对方在超时时间内不确认，发送方会一直重传，直到对方确认为止、或到达重传上限次数而Reset连接。</p>
<p>4、5 为<strong>重置连接报文、确认ACK报文</strong>，这两种报文对方接收到要ACK确认吧？不需要！自然发送方也不会重传这2种类型的报文。</p>
<p><strong>为何Reset报文不需要ACK确认?</strong></p>
<p>因为发送Reset报文的一端，在发送完这个报文之后，和该TCP Session有关的内存结构体瞬间全部释放，无论对方收到或没有收到，关系并不大。</p>
<p>如果对方收到Reset报文，也会释放该TCP Session 的相关内存结构体。</p>
<p>如果对方没有收到Reset 报文，可能会继续发送让接收方弹射出Reset报文的报文，到最后对方一样会收到Reset 报文，并最终释放内存。</p>
<p><strong>为何ACK报文不需要ACK确认?</strong></p>
<p>这里的ACK报文，是指没有携带任何数据的裸ACK报文，对方收到这样的ACK报文，自然也不需要ACK。否则，对方为了ACK己方的ACK，那己方收到对方的ACK，也要ACK对方的ACK，这就是一个死循环，永无止息。</p>
<p>所以为了避免这个死循环，一律不允许ACK对方的裸ACK报文。</p>
<p>有同学会说，按照这么说，TCP连接应该是四次消息交互啊。</p>
<p><strong>1.A 发送SYN 报文给B，这是第一次报文交互。</strong></p>
<p><strong>2. B发送ACK确认A的SYN报文，这是第二次报文交互</strong></p>
<p><strong>3. B发送自己的SYN报文给A，这是第三次报文交互</strong></p>
<p><strong>4. A需要ACK确认B的SYN报文，这是第四次报文交互</strong></p>
<p>以上的演绎没有问题，但是报文2、3为何要分开发送呢？增加了延迟不说，同时还白白浪费了网络的带宽，完全可以将报文2、3合并起来，不就是在报文2的ACK状态位的位置置“1”就结了吗？</p>
<p>这就是三次消息交互的由来！</p>
<h2 id="推荐阅读">推荐阅读</h2>
<p><a href="https://mp.weixin.qq.com/s/NIjxgx4NPn7FC4PfkHBAAQ">车小胖谈网络</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[http-连接管理]]></title>
        <id>https://leecss.com/post/http-lian-jie-guan-li/</id>
        <link href="https://leecss.com/post/http-lian-jie-guan-li/">
        </link>
        <updated>2021-07-07T13:12:39.000Z</updated>
        <content type="html"><![CDATA[<h1 id="http-连接管理">http-连接管理</h1>
<h2 id="概述">概述</h2>
<p>http连接的几种方式：串行连接、并行连接、持久连接、管道化连接……</p>
<h2 id="分类">分类</h2>
<h3 id="串行连接">串行连接</h3>
<p>也称为短连接、短轮询。</p>
<p>HTTP事务需要按顺序进行传输，等待服务端完成处理并回传。</p>
<p>缺点：</p>
<p>每次HTTP通信后都要断开TCP连接，所以每个新的HTTP请求都需要建立一个新的tcp连接，极大的增加了通信开销。</p>
<figure data-type="image" tabindex="1"><img src="https://leecss.com/post-images/1625668312340.png" alt="" loading="lazy"></figure>
<h3 id="并行连接">并行连接</h3>
<p>并发的执行多条HTTP请求，且每个请求都有自己的TCP连接。</p>
<p>特点：</p>
<p>并行连接的速度可能会更快，但不一定总是更快。</p>
<p>实际上多条连接会产生一些额外的开销，使用并行连接装载整个页面所需的时间很可能比串行下载的时间更长。</p>
<p>如果并行加载多个对象，每个对象都会去竞争这有限的带宽，每个对象都会以比较慢的速度按比例加载，这样带来的性能提升就很小，甚至没什么提升。</p>
<p>而且打开大量连接会消耗很多内存资源，从而引发自身的性能问题。</p>
<p>假如一百个用户同时发出申请，每个用户打开100个连接，服务器就要处理10 000个连接。这会造成服务器性能的严重下降。</p>
<hr>
<p>实际上，浏览器确实使用了并行连接，但它们并行连接的总数限制为一个较小的值(通常是4个)。</p>
<p>服务器可以随意的关闭来自特定客户端的超量连接。</p>
<figure data-type="image" tabindex="2"><img src="https://leecss.com/post-images/1625668321507.png" alt="" loading="lazy"></figure>
<h3 id="持久连接">持久连接</h3>
<p>也叫长连接、长轮询</p>
<p>在事务处理结束之后仍然保持在打开状态的TCP连接称为持久连接。</p>
<p><strong>方式</strong></p>
<p>持久连接有两种方式，分别为HTTP/1.0+的“Keep-alive”连接，以及HTTP/1.1的“persistent”连接。</p>
<p><strong>Keep-alive</strong>：该首部只是请求将连接保持在活跃状态，客户端和服务端可以随时关闭空闲的Keep-alive连接。</p>
<p>限制和规则：</p>
<p>1、必须客户端发送一个Connection：Keep-alive请求首部来激活Keep-alive连接，服务端不一定答应启用Keep-Alive会话；</p>
<p>2、必须随每个希望保持持久连接的请求的头部一起发送，如果某个请求没有带Keep-Alive头部，则服务器会在这个请求后关闭该连接。</p>
<hr>
<p><strong>Persistent</strong>：该首部默认情况下是激活的，除非特别指明，否则HTTP/1.1假定所有连接都是持久的。</p>
<p>限制和规则：</p>
<p>1、发送了 Connection: close 请求首部之后，客户端就无法在那条连接上发送更多的请求了。</p>
<p>如果客户端不想在连接上发送其他请求了，就应该在最后一条请求中发送一个Connection: close 请求首部。</p>
<p>2、只有当连接上所有的报文都有正确的、自定义报文长度时——也就是说，实体主体部分的长度都和相应的Content-Length 一致，或者是用分块传输编码方式编码的——连接才能持久保持。</p>
<figure data-type="image" tabindex="3"><img src="https://leecss.com/post-images/1625668334800.png" alt="" loading="lazy"></figure>
<h3 id="管道化连接">管道化连接</h3>
<p>在持久连接的基础上可选的使用请求管道。在响应到达之前，可以将多条请求放入队列。</p>
<p>限制：</p>
<p>1、如果HTTP客户端无法确认连接是持久的,就不应该使用管道。</p>
<p>2、必须按照与请求相同的顺序回送HTTP响应。HTTP报文中没有序列号标签,因此如果收到的响应失序了,就没办法将其与请求匹配起来了。</p>
<p>3、HTTP 客户端必须做好连接会在任意时刻关闭的准备,还要准备好重发所有未完成的管道化请求。如果客户端打开了一条持久连接,并立即发出了10条请求,服务器可能在只处理了,比方说,5条请求之后关闭连接。剩下的5 条请求会失败,客户端必须能够应对这些过早关闭连接的情况,重新发出这些请求。</p>
<p>4、HTTP 客户端不应该用管道化的方式发送会产生副作用的请求(比如POST)。总之,出错的时候,管道化方式会阻碍客户端了解服务器执行的是一系列管道化请求中的哪一些。由于无法安全地重试POST这样的<strong>非幂等请求</strong>,所以出错时,就存在某些方法永远不会被执行的风险。</p>
<figure data-type="image" tabindex="4"><img src="https://leecss.com/post-images/1625668345578.png" alt="" loading="lazy"></figure>
<p><strong>幂等请求</strong></p>
<p>所谓幂等就是 多次执行对资源的影响，和一次执行对资源的影响相同。不管进行多少次重复操作，都是实现相同的结果。</p>
<p>幂等保证在pipeline中的所有请求可以不必关心发送次序和到达服务器后执行的次序，即使多次请求，返回的结果一直是一样的。</p>
<p>反之，若其中包含了不幂等的请求，两个请求，第一个是更新用户张三信息，第二请求是获取更新后的张三最新信息。 他们是按照次序顺序在服务器端执行的：1先执行，2紧接着执行。 但是<strong>后一个请求不会等前一个请求完成才执行</strong>， 即可能 获取张三最新信息的2号请求先<strong>执行完成</strong>，这样返回的信息就不是期望的了。</p>
<p>所有请求虽然是按次序到达执行，<strong>但是不能保证一定是按照次序依次执行</strong>，比如1，2两个请求顺序到达，1是更新用户信息，2是获取这个更新用户的最新信息，1先执行，2不等1执行完就开始执行，得到的用户信息是旧的。</p>
<p>即，依次发了1，2，3这三个请求。如果1和2和3不是幂等的，即2可能要依赖1的返回，3可能要依赖1和2的返回，此种情况下就不能通过pipeline来进行发送。</p>
<p><strong>REST请求按幂等区分</strong></p>
<p>GET请求很好理解，对资源做查询多次，此实现的结果都是一样的。</p>
<p>PUT请求的幂等性可以这样理解，将A修改为B，它第一次请求值变为了B，再进行多次此操作，最终的结果还是B，与一次执行的结果是一样的，所以PUT是幂等操作。</p>
<p>DELETE请求，第一次将资源删除后，后面多次进行此删除请求，最终结果是一样的，将资源删除掉了。</p>
<p>POST不是幂等操作，因为一次请求添加一份新资源，二次请求则添加了两份新资源，多次请求会产生不同的结果，因此POST不是幂等操作。</p>
<hr>
<p>比较容易混淆的是HTTP POST和PUT。POST和PUT的区别容易被简单地误认为“POST表示创建资源，PUT表示更新资源”；而实际上，二者均可用于创建资源，更为本质的差别是在幂等性方面。在HTTP规范中对POST和PUT是这样定义的：</p>
<blockquote>
<p>The POST method is used to request that the origin server accept the entity enclosed in the request as a new subordinate of the resource identified by the Request-URI in the Request-Line ...... If a resource has been created on the origin server, the response SHOULD be 201 (Created) and contain an entity which describes the status of the request and refers to the new resource, and a Location header.</p>
<p>The PUT method requests that the enclosed entity be stored under the supplied Request-URI. If the Request-URI refers to an already existing resource, the enclosed entity SHOULD be considered as a modified version of the one residing on the origin server. If the Request-URI does not point to an existing resource, and that URI is capable of being defined as a new resource by the requesting user agent, the origin server can create the resource with that URI.</p>
</blockquote>
<p>POST所对应的URI并非创建的资源本身，而是资源的接收者。比如：POST <code>createArticles</code>的语义是在目标网站下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，POST方法不具备幂等性。而PUT所对应的URI是要创建或更新的资源本身。比如：PUT <code>updateArticles/4231</code>的语义是创建或更新ID为4231的帖子。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，PUT方法具有幂等性。</p>
]]></content>
    </entry>
</feed>