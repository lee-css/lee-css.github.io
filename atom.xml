<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://localhost:4000</id>
    <title>当下</title>
    <updated>2022-09-27T00:24:40.770Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://localhost:4000"/>
    <link rel="self" href="http://localhost:4000/atom.xml"/>
    <logo>http://localhost:4000/images/avatar.png</logo>
    <icon>http://localhost:4000/favicon.ico</icon>
    <rights>All rights reserved 2022, 当下</rights>
    <entry>
        <title type="html"><![CDATA[138-css-17-图文~伪类和伪元素]]></title>
        <id>http://localhost:4000/post/138-css-17-tu-wen-~wei-lei-he-wei-yuan-su/</id>
        <link href="http://localhost:4000/post/138-css-17-tu-wen-~wei-lei-he-wei-yuan-su/">
        </link>
        <updated>2022-09-27T00:21:04.000Z</updated>
        <content type="html"><![CDATA[<h1 id="138-css-17-图文~伪类和伪元素">138-css-17-图文~伪类和伪元素</h1>
<h2 id="概述">概述</h2>
<p>核心区别在于，是否创造了“新的元素”</p>
<ol>
<li>伪类表示被选择元素的某种状态，例如:hover</li>
<li>伪元素表示的是被选择元素的某个部分，这个部分看起来像一个独立的元素，但是是&quot;假元素&quot;，只存在于css中，所以叫&quot;伪&quot;的元素，例如:after</li>
</ol>
<p><strong>伪元素</strong></p>
<figure data-type="image" tabindex="1"><img src="http://localhost:4000/post-images/1664238100333.jpg" alt="" loading="lazy"></figure>
<p><strong>伪类</strong></p>
<figure data-type="image" tabindex="2"><img src="http://localhost:4000/post-images/1664238107754.jpg" alt="" loading="lazy"></figure>
<p><strong>应用</strong></p>
<p>after: 三角箭头</p>
<p><strong>参考</strong></p>
<p><a href="https://juejin.cn/post/6976646049456717838">一篇搞清伪类和伪元素 - 掘金</a></p>
<p><a href="https://juejin.cn/post/6844903654756089864">从青铜到王者10个css3伪类使用技巧和运用，了解一哈 - 掘金</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[137-css-16-图文~选择器优先级]]></title>
        <id>http://localhost:4000/post/137-css-16-tu-wen-~xuan-ze-qi-you-xian-ji/</id>
        <link href="http://localhost:4000/post/137-css-16-tu-wen-~xuan-ze-qi-you-xian-ji/">
        </link>
        <updated>2022-09-27T00:16:53.000Z</updated>
        <content type="html"><![CDATA[<h1 id="137-css-16-图文~选择器优先级">137-css-16-图文~选择器优先级</h1>
<h2 id="选择器优先级">选择器优先级</h2>
<pre><code>内联 &gt; ID选择器 &gt; 类选择器 &gt; 标签选择器。
</code></pre>
<h2 id="计算规则">计算规则</h2>
<pre><code>第一优先级：!important会覆盖页面内任何位置的元素样式
</code></pre>
<pre><code>优先级是由 A 、B、C、D 的值来决定的，其中它们的值计算规则如下：

如果存在内联样式(style=&quot;color: green&quot;)，那么 A = 1, 否则 A = 0;
B 的值等于 ID选择器(#app) 出现的次数;
C 的值等于 类选择器(.foo) 和 属性选择器(div[class=&quot;foo&quot;]) 和 伪类(:first-child) 出现的总次数;
D 的值等于 标签选择器(div) 和 伪元素(::before ::after) 出现的总次数 。

#nav-global &gt; ul &gt; li &gt; a.nav-link

因为没有内联样式 ，所以 A = 0;
ID选择器总共出现了1次， B = 1;
类选择器出现了1次， 属性选择器出现了0次，伪类选择器出现0次，所以 C = (1 + 0 + 0) = 1；
标签选择器出现了3次， 伪元素出现了0次，所以 D = (3 + 0) = 3;
上面算出的A、B、C、D 可以简记作：(0, 1, 1, 3)。
</code></pre>
<pre><code>li                                  /* (0, 0, 0, 1) */
ul li                               /* (0, 0, 0, 2) */
ul ol+li                            /* (0, 0, 0, 3) */
h1 + *[REL=up]                      /* (0, 0, 1, 1) */
ul ol li.red                        /* (0, 0, 1, 3) */
li.red.level                        /* (0, 0, 2, 1) */
a1.a2.a3.a4.a5.a6.a7.a8.a9.a10.a11  /* (0, 0, 11,0) */
#x34y                               /* (0, 1, 0, 0) */
li:first-child h2 .title            /* (0, 0, 2, 2) */
#nav .selected &gt; a:hover            /* (0, 1, 2, 1) */
html body #nav .selected &gt; a:hover  /* (0, 1, 2, 3) */
</code></pre>
<p><strong>比较规则是: 从左往右依次进行比较 ，较大者胜出，如果相等，则继续往右移动一位进行比较 。如果4位全部相等，则后面的会覆盖前面的</strong></p>
<p><strong>参考</strong></p>
<p><a href="https://juejin.cn/post/6953405751104634916">https://juejin.cn/post/6953405751104634916</a></p>
<p><a href="https://juejin.cn/post/6844903709772611592">https://juejin.cn/post/6844903709772611592</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[136-css-15-布局~flex画骰子]]></title>
        <id>http://localhost:4000/post/136-css-15-bu-ju-~flex-hua-tou-zi/</id>
        <link href="http://localhost:4000/post/136-css-15-bu-ju-~flex-hua-tou-zi/">
        </link>
        <updated>2022-09-26T23:46:43.000Z</updated>
        <content type="html"><![CDATA[<h1 id="136-css-15-布局~flex画骰子">136-css-15-布局~flex画骰子</h1>
<pre><code>flex最常用的语法：（熟练掌握）
flex-direction:主轴的方向（可横向可纵向）
justify-content：主轴对齐方式（开始对齐、两边对齐...）
align-items:交叉轴对齐方式（和主轴垂直的轴）
flex-wrap:什么时候换行
align-self：子元素在交叉轴的对齐方式（开始对齐、居中对齐...）
</code></pre>
<pre><code>实现一个三点的骰子：
.box{
    display:flex;//flex布局
    justify-content:space-between;//两端对齐
}
.item {
    //背景色、颜色、大小边框等
}
.item:nth-child(2) {
    align-self:center;//第二项居中对齐
}
.item:nth-child(3) {
    align-self:flex-end；//第三项尾对齐
}
&lt;div class = &quot;box&quot;&gt;
    &lt;span class=&quot;item&quot;&gt;&lt;/span&gt;
    &lt;span class=&quot;item&quot;&gt;&lt;/span&gt;
    &lt;span class=&quot;item&quot;&gt;&lt;/span&gt;
&lt;/div&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[135-css-14-布局~float清除浮动]]></title>
        <id>http://localhost:4000/post/135-css-14-bu-ju-~float-qing-chu-fu-dong/</id>
        <link href="http://localhost:4000/post/135-css-14-bu-ju-~float-qing-chu-fu-dong/">
        </link>
        <updated>2022-09-26T23:41:46.000Z</updated>
        <content type="html"><![CDATA[<h1 id="135-css-14-布局~float清除浮动">135-css-14-布局~float清除浮动</h1>
<h2 id="方式">方式</h2>
<p>1、clear</p>
<p>2、bfc (<code>overflow:hidden;</code>)</p>
<h2 id="伪类">伪类</h2>
<pre><code>.clearfix:after {
    content: '';
    display: table;
    clear: both;
}
.clearfix {
    *zoom: 1; /* 兼容IE低版本 */
}
</code></pre>
<pre><code>.clearfix:before,
.clearfix:after {
    display: table;
    content: &quot; &quot;;
}
.clearfix:after {
    clear: both;
}
.clearfix{
    *zoom: 1;
}
</code></pre>
<h2 id="兼容">兼容</h2>
<pre><code>*zoom:1;*放在css属性前面，表示这个属性仅仅应用到Internet Explorer 7 以及以下版本。因为Internet Explorer 版本 7 以及以下承认非字母数字（除了下划线）前缀的属性。
</code></pre>
<h2 id="原理">原理</h2>
<pre><code>在要清除浮动的元素后面加一个空的块级元素，并给这个元素清除浮动clear:both;
</code></pre>
<pre><code>clear 属性用于清除浮动元素带来的影响，本质上是不与浮动元素在同一行
该属性只能影响使用清除的元素本身，不能影响其他元素。

适用于浮动和非浮动元素。
</code></pre>
<pre><code>::after用来创建一个伪元素，作为已选中元素的最后一个子元素。
clearfix类加在浮动元素父元素上，相当于在浮动元素最后加了一个新元素

设置display:block，display:table是需要设置一个块元素，独占一行，撑起父元素高度
</code></pre>
<h2 id="参考">参考</h2>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/clear">https://developer.mozilla.org/zh-CN/docs/Web/CSS/clear</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[134-css-13-布局~两栏方案]]></title>
        <id>http://localhost:4000/post/134-css-13-bu-ju-~liang-lan-fang-an/</id>
        <link href="http://localhost:4000/post/134-css-13-bu-ju-~liang-lan-fang-an/">
        </link>
        <updated>2022-09-26T23:35:41.000Z</updated>
        <content type="html"><![CDATA[<h1 id="134-css-13-布局~两栏方案">134-css-13-布局~两栏方案</h1>
<h2 id="两栏布局">两栏布局</h2>
<p>左侧定宽，右侧自适应</p>
<pre><code>1、float+calc()函数; 左侧浮动，右侧浮动、calc(100% - 左侧宽度)
2、float+margin-left; 左侧浮动，右侧margin-left左侧宽度
3、absolute+margin-left; 左侧absolute，右侧margin-left左侧宽度
4、float+overflow; 左侧浮动，右侧overflow:hidden(BFC)
5、absolute; 左侧absolute，右侧absolute、left左侧宽度
6、百分比; 左侧百分比，右侧百分比(行内块或者浮动)
7、flex; 父级flex,右侧flex:1
8、grid; 父级grid、grid-template-columns: auto 1fr;
</code></pre>
<h3 id="1-floatcalc函数">1、float+calc()函数</h3>
<pre><code>.left {
  float: left;
}
.right {
  float: left;
  width: calc(100% - 200px); /* 宽度减去左列的宽度 */
}
</code></pre>
<h3 id="2-floatmargin-left">2、float+margin-left</h3>
<pre><code>.left {
  float: left;
}
.right {
  margin-left: 200px; /* 通过外边距的方式使该容器的左边有200px */
}
</code></pre>
<h3 id="3-absolutemargin-left">3、absolute+margin-left</h3>
<pre><code>.left {
  position: absolute; /* 开启定位脱离文档流 */
}
.right {
  margin-left: 200px; /* 通过外边距的方式使该容器的左边有200px */
}
</code></pre>
<h3 id="4-floatoverflow">4、float+overflow</h3>
<pre><code>.left {
  float: left;
}
.right {
  overflow: hidden; /* 设置 overflow会创建一个BFC 完成自适应 */
}
</code></pre>
<h3 id="5-absolute">5、absolute</h3>
<pre><code>.left {
  position: absolute;
}
.right {
  position: absolute;
  left: 200px; /* 定位间隔左侧的宽的200px */
}
</code></pre>
<h3 id="6-百分比">6、百分比</h3>
<pre><code>.left {
  display:inline-block;
  width:50%;
}
.right {
  display:inline-block;
  width:50%;
}
</code></pre>
<h3 id="7-flex">7、flex</h3>
<pre><code>.parent {
  display:flex;
  width:50%
}
.right {
  flex:1; /* flex: 1; 表示 flex-grow: 1; 即该项占所有剩余空间 */
}
</code></pre>
<h3 id="8-grid">8、grid</h3>
<pre><code>.parent {
  display: grid;
  grid-template-columns: 100px auto;  /*设定2列就ok了,auto换成1fr也行*/
}
</code></pre>
<pre><code>.parent {
  display: grid;
  grid-template-columns: auto 1fr; /* 将其划分为两行，其中一列由本身宽度决定， 一列占剩余宽度*/
}
</code></pre>
<h2 id="参考">参考</h2>
<p><a href="https://juejin.cn/post/6844903574929932301">https://juejin.cn/post/6844903574929932301</a></p>
<p><a href="https://juejin.cn/post/7028962991345254407">https://juejin.cn/post/7028962991345254407</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[133-css-12-定位~文档流]]></title>
        <id>http://localhost:4000/post/133-css-12-ding-wei-~wen-dang-liu/</id>
        <link href="http://localhost:4000/post/133-css-12-ding-wei-~wen-dang-liu/">
        </link>
        <updated>2022-09-26T23:31:28.000Z</updated>
        <content type="html"><![CDATA[<h1 id="133-css-12-定位~文档流">133-css-12-定位~文档流</h1>
<h2 id="三个定位方案">三个定位方案</h2>
<p>在定位的时候，浏览器就会根据元素的盒类型和上下文对这些元素进行定位，可以说盒就是定位的基本单位。定位时，有三种定位方案，分别是常规流，浮动已经绝对定位。</p>
<h3 id="常规流normal-flow">常规流(Normal flow)</h3>
<ul>
<li>在常规流中，盒一个接着一个排列;</li>
<li>在<strong>块级格式化上下文</strong>里面， 它们<strong>竖着</strong>排列；</li>
<li>在<strong>行内格式化上下文</strong>里面， 它们<strong>横着</strong>排列;</li>
<li>当<code>position</code>为<code>static</code>或<code>relative</code>，并且<code>float</code>为<code>none</code>时会触发常规流；</li>
<li>对于<strong>静态定位</strong>(static positioning)，<code>position: static</code>，<strong>盒的位置是常规流布局里的位置</strong>；</li>
<li>对于<strong>相对定位</strong>(relative positioning)，<code>position: relative</code>，盒偏移位置由这些属性定义<code>top</code>，<code>bottom</code>，<code>left</code>and<code>right</code>。<strong>即使有偏移，仍然保留原有的位置</strong>，其它常规流不能占用这个位置。</li>
</ul>
<h3 id="浮动floats">浮动(Floats)</h3>
<ul>
<li>盒称为浮动盒(floating boxes)；</li>
<li>它位于当前行的开头或末尾；</li>
<li>这<strong>导致常规流环绕在它的周边</strong>，除非设置 clear 属性；</li>
</ul>
<h3 id="绝对定位absolute-positioning">绝对定位(Absolute positioning)</h3>
<ul>
<li>绝对定位方案，<strong>盒从常规流中被移除</strong>，不影响常规流的布局；</li>
<li>它的定位相对于它的包含块，相关CSS属性：<code>top</code>，<code>bottom</code>，<code>left</code>及<code>right</code>；</li>
<li>如果元素的属性<code>position</code>为<code>absolute</code>或<code>fixed</code>，它是绝对定位元素；</li>
<li>对于<code>position: absolute</code>，元素定位将相对于最近的一个<code>relative</code>、<code>fixed</code>或<code>absolute</code>的父元素，如果没有则相对于<code>body</code>；</li>
</ul>
<h2 id="脱离文档流">脱离文档流</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[132-css-11-布局~盒模型]]></title>
        <id>http://localhost:4000/post/132-css-11-bu-ju-~he-mo-xing/</id>
        <link href="http://localhost:4000/post/132-css-11-bu-ju-~he-mo-xing/">
        </link>
        <updated>2022-09-26T22:53:07.000Z</updated>
        <content type="html"><![CDATA[<h1 id="132-css-11-布局~盒模型">132-css-11-布局~盒模型</h1>
<h2 id="盒模型">盒模型</h2>
<p>CSS 盒模型实质上是一个包围每个 HTML 元素的框。展示在页面上的每一个元素都可以视为一个盒模型。</p>
<p>盒模型包括：</p>
<ul>
<li>
<p>外边距 → margin（可以为负值）</p>
</li>
<li>
<p>边框 → border</p>
</li>
<li>
<p>内边距 → padding（不允许负值）</p>
</li>
<li>
<p>实际的内容 → content</p>
</li>
</ul>
<blockquote>
<ul>
<li>无论是div、span、还是a都是盒子。</li>
<li>图片、表单元素一律看作是文本，它们并不是盒子，因为一张图片里面并不能放东西，它自己就是自己的内容。</li>
</ul>
</blockquote>
<p><strong>宽度计算：</strong></p>
<p>offsetWidth = 内容 + 内边距（padding） + 边框（border）</p>
<p><strong>分类：</strong></p>
<ul>
<li>标准模型width不计算padding和border；</li>
<li>ie模型width计算padding 和border；</li>
</ul>
<pre><code>（标准盒模型 box-sizing: content-box）offsetWidth = width + padding + border

（怪异盒模型 box-sizing: border-box）offsetWidth = width
</code></pre>
<p><strong>box-sizing</strong></p>
<pre><code class="language-css">box-sizing: content-box|border-box|inherit;
</code></pre>
<ul>
<li>content-box
<ul>
<li>默认值，设置为W3C标准盒模型</li>
</ul>
</li>
<li>border-box
<ul>
<li>设置为IE盒模型</li>
</ul>
</li>
<li>inherit
<ul>
<li>继承父级盒子类型</li>
</ul>
</li>
</ul>
<p><strong>JS如何设置/获取盒模型对应的宽和高？</strong></p>
<p>offsetWidth、offsetHeight</p>
<pre><code>.box {}
----------------------------
let targetDom = document.querySelector('.box');
let width = targetDom.offsetWidth;
let height = targetDom.offsetHeight;
console.log('width',width)
console.log('height',height)
</code></pre>
<p><strong>参考：</strong></p>
<blockquote>
<p><a href="https://juejin.cn/post/6988877671606272031">https://juejin.cn/post/6988877671606272031</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[131-html-3-元信息]]></title>
        <id>http://localhost:4000/post/131-html-3-yuan-xin-xi/</id>
        <link href="http://localhost:4000/post/131-html-3-yuan-xin-xi/">
        </link>
        <updated>2022-09-26T00:33:39.000Z</updated>
        <content type="html"><![CDATA[<h1 id="131-html-3-元信息">131-html-3-元信息</h1>
<h2 id="元信息类标签head-title-meta的使用目的和配置方法">元信息类标签(<code>head</code>、<code>title</code>、<code>meta</code>)的使用目的和配置方法</h2>
<p><code>meta</code>存在两个非必须的属性<code>http-equiv</code>和<code>name</code>, 用于表示要设置的项。</p>
<p><code>meta</code>有个必须的属性<code>content</code>用于表示需要设置的项的值。</p>
<p><strong>http-equiv</strong></p>
<pre><code>// http-equiv一般设置的都是与http请求头相关的信息

// 声明文档类型、设字符集
&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;
// 自动将http的不安全请求升级为https
&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;upgrade-insecure-requests&quot;&gt;
// 以最高版本的IE来渲染页面
&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
// 用于设置浏览器的过期时间, 其实就是响应头中的expires属性。
&lt;meta http-equiv=&quot;expires&quot; content=&quot;31 Dec 2021&quot;&gt;
// 重新载入页面的时间间隔,或重定向到指定链接的时间间隔
&lt;meta http-equiv=&quot;refresh&quot; content=&quot;3;url=https://www.mozilla.org&quot;&gt;
// 强制页面在当前窗口以独立页面显示
&lt;meta http-equiv=&quot;window-target&quot; content=&quot;_top'&gt;
// 禁止浏览器从本地计算机的缓存中访问页面的内容
&lt;meta http-equiv=&quot;pragma&quot; content=&quot;no-cache&quot;&gt;
</code></pre>
<p><strong>name</strong></p>
<pre><code>// name属性主要用于描述网页，与对应的content中的内容主要是便于搜索引擎查找信息和分类信息用的

author：文档作者的名字。
description：一段简短而精确的、对页面内容的描述。一些浏览器，比如 Firefox 和 Opera，将其用作书签的默认描述。
keywords：与页面内容相关的关键词，使用逗号分隔。
generator：生成此页面的软件的标识符（identifier）。
</code></pre>
<p><strong>CSS 设备适配规范</strong></p>
<pre><code>// 自动以原始比例显示，并且不允许用户缩放
&lt;meta charset=&quot;utf-8&quot; name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, minimum-scale=1, maximum-scale=1, user-scalable=no&quot;/&gt;
</code></pre>
<p><strong>og</strong></p>
<pre><code>// Facebook 编写的元数据协议 Open Graph Data 为网站提供了更丰富的元数据。

&lt;meta property=&quot;og:type&quot; content=&quot;website&quot; /&gt;
&lt;meta property=&quot;og:url&quot; content=&quot;要分享的链接&quot; /&gt;
&lt;meta property=&quot;og:title&quot; content=&quot;标题&quot; /&gt;
&lt;meta property=&quot;og:description&quot; content=&quot;简介&quot; /&gt;
&lt;meta property=&quot;og:image&quot; content=&quot;图片&quot; /&gt;
&lt;meta property=&quot;og:site_name&quot; content=&quot;O課&quot; /&gt;

let titleMeta = document.createElement('meta')
titleMeta.setAttribute('property', 'og:title')
titleMeta.content = 'hello'
document.getElementsByTagName('head')[0].appendChild(titleMeta)
</code></pre>
<p><strong>参考</strong></p>
<p>https://juejin.cn/post/6987919006468407309</p>
<p>https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta/name</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[130-html-2-元素分类]]></title>
        <id>http://localhost:4000/post/130-html-2-yuan-su-fen-lei/</id>
        <link href="http://localhost:4000/post/130-html-2-yuan-su-fen-lei/">
        </link>
        <updated>2022-09-26T00:32:39.000Z</updated>
        <content type="html"><![CDATA[<h1 id="130-html-2-元素分类">130-html-2-元素分类</h1>
<h2 id="哪些html标签是块级元素哪些是内联元素">哪些HTML标签是块级元素，哪些是内联元素？</h2>
<p>块状元素（block/table）：div, h1,h2,table,ul,lo,p；独占一行</p>
<p>内联元素（inline/inline-block）:span,img,input,button；不独占一行</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[129-html-1-HTML语义化]]></title>
        <id>http://localhost:4000/post/129-html-1-html-yu-yi-hua/</id>
        <link href="http://localhost:4000/post/129-html-1-html-yu-yi-hua/">
        </link>
        <updated>2022-09-26T00:25:45.000Z</updated>
        <content type="html"><![CDATA[<h1 id="129-html-1-html语义化">129-html-1-HTML语义化</h1>
<h2 id="如何理解html语义化">如何理解HTML语义化？</h2>
<p>HTML语义化是指从代码上来展示页面的结构，而不是从最终视觉上来展示结构。</p>
<p><strong>优点</strong>：</p>
<p>1、方便爬虫抓取信息，有利于SEO</p>
<p>2、提升代码可读性，方便团队开发维护</p>
<p>3、CSS文件还未加载时（没有CSS），页面仍然清晰、可读、好看。</p>
<p>4、提升用户体验，例如title、alt可用于解释名词或解释图片信息。</p>
<p><strong>做法：</strong></p>
<ul>
<li><code>&lt;h1&gt;</code>~<code>&lt;h6&gt;</code> ，作为标题使用，并且依据重要性递减，<code>&lt;h1&gt;</code> 是最高的等级。</li>
<li>少用div和span,使用p做为段落标记</li>
<li>导航条使用ul、li</li>
<li>需要强调的文本，可以包含在strong或者em标签</li>
<li>header（头部）main（主体内容）nav（导航）section（某一块内容）footer（底部）aside（侧边）</li>
</ul>
]]></content>
    </entry>
</feed>