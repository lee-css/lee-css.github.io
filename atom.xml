<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://leecss.com</id>
    <title>当下</title>
    <updated>2021-07-22T00:13:39.985Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://leecss.com"/>
    <link rel="self" href="https://leecss.com/atom.xml"/>
    <logo>https://leecss.com/images/avatar.png</logo>
    <icon>https://leecss.com/favicon.ico</icon>
    <rights>All rights reserved 2021, 当下</rights>
    <entry>
        <title type="html"><![CDATA[http-其他首部字段]]></title>
        <id>https://leecss.com/post/http-qi-ta-shou-bu-zi-duan/</id>
        <link href="https://leecss.com/post/http-qi-ta-shou-bu-zi-duan/">
        </link>
        <updated>2021-07-22T00:13:10.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>HTTP 首部字段是可以自行扩展的。所以在 Web 服务器和浏览器的应用上，会出现各种非标准的首部字段。</p>
<h2 id="常用的首部字段">常用的首部字段</h2>
<h3 id="x-frame-options">X-Frame-Options</h3>
<p>首部字段 X-Frame-Options 属于 HTTP 响应首部，用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。其主要目的是为了防止点击劫持（clickjacking）攻击。</p>
<p>取值：</p>
<ul>
<li><strong>DENY</strong>：表示该页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许。</li>
<li><strong>SAMEORIGIN</strong>：表示该页面可以在相同域名页面的 frame 中展示。</li>
<li><strong>ALLOW-FROM uri</strong>：表示该页面可以在指定来源的 frame 中展示。</li>
</ul>
<pre><code class="language-http">X-Frame-Options: DENY
X-Frame-Options: SAMEORIGIN
X-Frame-Options: ALLOW-FROM http://hackr.jp
</code></pre>
<h3 id="x-xss-protection">X-XSS-Protection</h3>
<p>首部字段 X-XSS-Protection 属于 HTTP 响应首部，它是针对跨站脚本攻击（XSS）的一种对策，用于控制浏览器 XSS 防护机制的开关。</p>
<p>当检测到跨站脚本攻击 (XSS)时，浏览器将停止加载页面。针对现代浏览器，会选择更强大的Content-Security-Policy。</p>
<pre><code>X-XSS-Protection: 0  //禁止XSS过滤。
X-XSS-Protection: 1  //启用XSS过滤（通常浏览器是默认的）。如果检测到跨站脚本攻击，浏览器将清除页面（删除不安全的部分）。
X-XSS-Protection: 1; mode=block //启用XSS过滤。 如果检测到攻击，浏览器将不会清除页面，而是阻止页面加载。
X-XSS-Protection: 1; report=&lt;reporting-uri&gt; //启用XSS过滤。 如果检测到跨站脚本攻击，浏览器将清除页面并使用CSP report-uri指令的功能发送违规报告。
</code></pre>
<h3 id="dnt">DNT</h3>
<p>首部字段 DNT 属于 HTTP 请求首部，其中 DNT 是 Do Not Track 的简称，意为拒绝个人信息被收集，是表示拒绝被精准广告追踪的一种方法。</p>
<pre><code class="language-http">DNT:0 //同意被追踪
DNT:1 //拒绝被追踪
</code></pre>
<p>由于首部字段 DNT 的功能具备有效性，所以 Web 服务器需要对 DNT做对应的支持。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[http-cookie相关首部字段]]></title>
        <id>https://leecss.com/post/http-cookie-xiang-guan-shou-bu-zi-duan/</id>
        <link href="https://leecss.com/post/http-cookie-xiang-guan-shou-bu-zi-duan/">
        </link>
        <updated>2021-07-21T23:58:55.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>管理服务器与客户端之间状态的 Cookie，虽然没有被编入标准化HTTP/1.1 的 RFC2616 中，但在 Web 网站方面得到了广泛的应用。</p>
<p>Cookie 的工作机制是用户识别及状态管理。Web 网站为了管理用户的状态会通过 Web 浏览器，把一些数据临时写入用户的计算机内。接着当用户访问该Web网站时，可通过通信方式取回之前发放的Cookie。</p>
<p>调用 Cookie 时，由于可校验 Cookie 的有效期，以及发送方的域、路径、协议等信息，所以正规发布的 Cookie 内的数据不会因来自其他Web 站点和攻击者的攻击而泄露。</p>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
<th>首部类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>Set-Cookie</td>
<td>开始状态管理所使用的Cookie信息</td>
<td>响应首部字段</td>
</tr>
<tr>
<td>Cookie</td>
<td>服务器接收到的Cookie信息</td>
<td>请求首部字段</td>
</tr>
</tbody>
</table>
<h2 id="服务器">服务器</h2>
<p>当服务器准备开始管理客户端的状态时，会事先告知各种信息。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>NAME=VALUE</td>
<td>赋予 Cookie 的名称和其值（必需项）</td>
</tr>
<tr>
<td>expires=DATE</td>
<td>Cookie的有效期（若不明确指定则默认为浏览器关闭前为止）</td>
</tr>
<tr>
<td>path=PATH</td>
<td>将服务器上的文件目录作为Cookie的适用对象（若不指定则默认为文档所在的文件目录）</td>
</tr>
<tr>
<td>domain=域名</td>
<td>作为 Cookie 适用对象的域名 （若不指定则默认为创建 Cookie的服务器的域名）</td>
</tr>
<tr>
<td>Secure</td>
<td>仅在 HTTPS 安全通信时才会发送 Cookie</td>
</tr>
<tr>
<td>HttpOnly</td>
<td>加以限制，使 Cookie 不能被 JavaScript 脚本访问</td>
</tr>
</tbody>
</table>
<h3 id="expires">expires</h3>
<p>Cookie 的 expires 属性指定浏览器可发送 Cookie 的有效期。</p>
<p>当省略 expires 属性时，其有效期仅限于维持浏览器会话（Session）时间段内。这通常限于浏览器应用程序被关闭之前。</p>
<p>另外，一旦 Cookie 从服务器端发送至客户端，服务器端就不存在可以显式删除 Cookie 的方法。但可通过覆盖已过期的 Cookie，实现对客户端 Cookie 的实质性删除操作。</p>
<h3 id="path">path</h3>
<p>限定可以发送Cookie的路径</p>
<p>Cookie 的 path 属性可用于限制指定 Cookie 的发送范围的文件目录。</p>
<h3 id="domain">domain</h3>
<p>通过 Cookie 的 domain 属性指定的域名可做到与结尾匹配一致。比如，当指定 <code>example.com</code> 后，除<code>example.com</code> 以外，<code>www.example.com</code>或 <code>www2.example.com</code> 等都可以发送 Cookie。</p>
<p>因此，除了针对具体指定的多个域名发送 Cookie 之 外，不指定domain 属性显得更安全。</p>
<h3 id="secure">secure</h3>
<p>Cookie 的 secure 属性用于限制 Web 页面仅在 HTTPS 安全连接时，才可以发送 Cookie。</p>
<pre><code class="language-http">Set-Cookie: name=value; secure
</code></pre>
<p>以上例子仅当在 <code>https://www.example.com/</code>（HTTPS）安全连接的情况下才会进行 Cookie 的回收。也就是说，即使域名相同，<code>http://www.example.com/</code>（HTTP）也不会发生 Cookie 回收行为。</p>
<p>当省略 secure 属性时，不论 HTTP 还是 HTTPS，都会对 Cookie 进行回收。</p>
<h3 id="httponly">HttpOnly</h3>
<p>Cookie 的 HttpOnly 属性是 Cookie 的扩展功能，它使 JavaScript 脚本无法获得 Cookie。其主要目的为防止跨站脚本攻击（Cross-site scripting，XSS）对 Cookie 的信息窃取。</p>
<pre><code class="language-http">Set-Cookie: name=value; HttpOnly
</code></pre>
<p>通过上述设置，通常从 Web 页面内还可以对 Cookie 进行读取操作。但使用 JavaScript 的 document.cookie 就无法读取附加 HttpOnly 属性后的 Cookie 的内容了。因此，也就无法在 XSS 中利用 JavaScript 劫持Cookie 了。</p>
<h2 id="客户端">客户端</h2>
<p>首部字段 Cookie 会告知服务器，当客户端想获得 HTTP 状态管理支持时，就会在请求中包含从服务器接收到的 Cookie。接收到多个Cookie 时，同样可以以多个 Cookie 形式发送。</p>
<pre><code class="language-http">Cookie: status=enable
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[http-实体首部字段]]></title>
        <id>https://leecss.com/post/http-shi-ti-shou-bu-zi-duan/</id>
        <link href="https://leecss.com/post/http-shi-ti-shou-bu-zi-duan/">
        </link>
        <updated>2021-07-21T23:33:49.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>实体首部字段是包含在请求报文和响应报文中的实体部分所使用的首部，用于补充内容的更新时间等与实体相关的信息。</p>
<h2 id="列表">列表</h2>
<table>
<thead>
<tr>
<th>实体首部</th>
<th>作用（补充请求报文或响应报文相关信息）</th>
</tr>
</thead>
<tbody>
<tr>
<td>Allow</td>
<td>告诉客户端资源所支持的HTTP方法：<code>GET HEAD POST</code></td>
</tr>
<tr>
<td>Content-Encoding</td>
<td>告知客户端，服务器对实体主体部分选用的内容编码方式：<code>gzip deflate</code></td>
</tr>
<tr>
<td>Content-Language</td>
<td>告知客户端，实体主体使用的自然语言。：<code>zh-CN</code></td>
</tr>
<tr>
<td>Content-Length</td>
<td>表明实体主体部分的大小，单位是字节。</td>
</tr>
<tr>
<td>Content-Location</td>
<td>表示返回的数据对应的URI</td>
</tr>
<tr>
<td>Content-MD5</td>
<td>Base64加密格式的内容 MD5检验值</td>
</tr>
<tr>
<td>Content-Range</td>
<td>主要用于范围请求，告知客户端当前发送部分的内容范围以及整个实体大小。</td>
</tr>
<tr>
<td>Content-Type</td>
<td>表明实体主体内对象的媒体类型。</td>
</tr>
<tr>
<td>Expires</td>
<td>内容的过期时间</td>
</tr>
<tr>
<td>Last_modified</td>
<td>内容的最后修改时间</td>
</tr>
</tbody>
</table>
<h3 id="allow">Allow</h3>
<p>首部字段 Allow 用于通知客户端能够支持 Request-URI 指定资源的所有 HTTP 方法。当服务器接收到不支持的 HTTP 方法时，会以状态码405 Method Not Allowed 作为响应返回。与此同时，还会把所有能支持的 HTTP 方法写入首部字段 Allow 后返回。</p>
<pre><code class="language-http">Allow: GET, HEAD
</code></pre>
<h3 id="content-encoding">Content-Encoding</h3>
<p>首部字段 Content-Encoding 会告知客户端服务器对实体的主体部分选用的内容编码方式。内容编码是指在不丢失实体信息的前提下所进行的压缩。</p>
<p>告知客户端以同样的方式解压。</p>
<p>主要采用以下 4 种内容编码的方式。</p>
<pre><code>gzip
compress
deflate
identity
</code></pre>
<pre><code class="language-http">Content-Encoding: gzip
</code></pre>
<h3 id="content-language">Content-Language</h3>
<p>首部字段 Content-Language 会告知客户端，实体主体使用的自然语言（指中文或英文等语言）。</p>
<pre><code class="language-http">Content-Language: zh-CN
</code></pre>
<h3 id="content-length">Content-Length</h3>
<p>首部字段 Content-Length 表明了实体主体部分的大小（单位是字节）。对实体主体进行内容编码传输时，不能再使用 Content-Length首部字段。</p>
<pre><code class="language-http">Content-Length: 15000
</code></pre>
<p>该资源的大小为15000字节</p>
<h3 id="content-location">Content-Location</h3>
<p>首部字段 Content-Location 给出与报文主体部分相对应的 URI。和首部字段 Location 不同，Content-Location 表示的是报文主体返回资源对应的 URI。</p>
<p>比如，对于使用首部字段 Accept-Language 的服务器驱动型请求，当返回的页面内容与实际请求的对象不同时，首部字段 Content-Location内会写明 URI。（访问 <code>http://www.hackr.jp/</code> 返回的对象却是<code>http://www.hackr.jp/index-ja.html</code> 等类似情况）</p>
<pre><code class="language-http">Content-Location: http://www.hackr.jp/index-ja.html
</code></pre>
<h3 id="content-md5">Content-MD5</h3>
<p>首部字段 Content-MD5 是一串由 MD5 算法生成的值，其目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达。</p>
<p>对报文主体执行 MD5 算法获得的 128 位二进制数，再通过 Base64 编码后将结果写入 Content-MD5 字段值。由于 HTTP 首部无法记录二进制值，所以要通过 Base64 编码处理。为确保报文的有效性，作为接收方的客户端会对报文主体再执行一次相同的 MD5 算法。计算出的值与字段值作比较后，即可判断出报文主体的准确性。</p>
<p>采用这种方法，对内容上的偶发性改变是无从查证的，也无法检测出恶意篡改。其中一个原因在于，内容如果能够被篡改，那么同时意味着 Content-MD5 也可重新计算然后被篡改。所以处在接收阶段的客户端是无法意识到报文主体以及首部字段 Content-MD5 是已经被篡改过的。</p>
<pre><code class="language-http">Content-MD5: OGFkZDUwNGVhNGY3N2MxMDIwZmQ4NTBmY2IyTY==
</code></pre>
<pre><code>报文主体 -&gt; MD5算法 -&gt; Base64编码
</code></pre>
<h3 id="content-range">Content-Range</h3>
<p>针对范围请求，返回响应时使用的首部字段 Content-Range，能告知客户端作为响应返回的实体的哪个部分符合范围请求。字段值以字节为单位，表示当前发送部分及整个实体大小。</p>
<pre><code class="language-http">Content-Range: bytes 5001-10000/10000
</code></pre>
<h3 id="content-type">Content-Type</h3>
<p>首部字段 Content-Type 说明了实体主体内对象的媒体类型。和首部字段 Accept 一样，字段值用 type/subtype 形式赋值。<br>
参数 charset 使用 iso-8859-1 或 euc-jp 等字符集进行赋值。</p>
<pre><code class="language-http">Content-Type: text/html; charset=UTF-8
</code></pre>
<h3 id="expires">Expires</h3>
<p>首部字段 Expires 会将资源失效的日期告知客户端。缓存服务器在接收到含有首部字段 Expires 的响应后，会以缓存来应答请求，在Expires 字段值指定的时间之前，响应的副本会一直被保存。当超过指定的时间后，缓存服务器在请求发送过来时，会转向源服务器请求资源。</p>
<p>源服务器不希望缓存服务器对资源缓存时，最好在 Expires 字段内写入与首部字段 Date 相同的时间值。</p>
<p>但是，当首部字段 Cache-Control 有指定 max-age 指令时，比起首部字段 Expires，会优先处理 max-age 指令。</p>
<pre><code class="language-http">Expires: Wed, 04 Jul 2012 08:26:05 GMT
</code></pre>
<p>源服务器告知缓存服务器此缓存可使用到2012年7月4日</p>
<h3 id="last-modified">Last-Modified</h3>
<p>首部字段 Last-Modified 指明资源最终修改的时间。一般来说，这个值就是 Request-URI 指定资源被修改的时间。但类似使用 CGI 脚本进行动态数据处理时，该值有可能会变成数据最终修改时的时间。</p>
<pre><code class="language-http">Last-Modified: Wed, 23 May 2012 09:59:55 GMT
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[http-响应首部字段]]></title>
        <id>https://leecss.com/post/http-xiang-ying-shou-bu-zi-duan/</id>
        <link href="https://leecss.com/post/http-xiang-ying-shou-bu-zi-duan/">
        </link>
        <updated>2021-07-21T14:22:10.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>响应首部字段是由服务器端向客户端返回响应报文中所使用的字段，用于补充响应的附加信息、服务器信息，以及对客户端的附加要求等信息。</p>
<h2 id="列表">列表</h2>
<table>
<thead>
<tr>
<th>响应首部</th>
<th>作用（响应报文专用）</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept-Ranges</td>
<td>告知客户端服务器是否可接受范围请求，是<code>bytes</code>，否<code>none</code></td>
</tr>
<tr>
<td>Age</td>
<td>资源在代理缓存中存在的时间</td>
</tr>
<tr>
<td>ETag</td>
<td>资源标识，资源发生变化时标识也会发生改变</td>
</tr>
<tr>
<td>Location</td>
<td>客户端重定向到某个 URL</td>
</tr>
<tr>
<td>Proxy-Authenticate</td>
<td>向代理服务器发送验证信息</td>
</tr>
<tr>
<td>Retry-After</td>
<td>告知客户端应该在多久之后再次发送请求</td>
</tr>
<tr>
<td>Server</td>
<td>服务器名字：<code>Apache Nginx</code></td>
</tr>
<tr>
<td>Vary</td>
<td>对缓存进行控制 <code>Vary: Accept-Language</code></td>
</tr>
<tr>
<td>WWW-Authenticate</td>
<td>定义了使用何种验证方式去获取对资源的连接。</td>
</tr>
</tbody>
</table>
<h3 id="accept-ranges">Accept-Ranges</h3>
<p>首部字段 Accept-Ranges 是用来告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资源。</p>
<p>可指定的字段值有两种，可处理范围请求时指定其为 bytes，反之则指定其为 none。</p>
<pre><code class="language-http">Accept-Ranges: bytes
Accept-Ranges: none    //不支持范围请求
</code></pre>
<h3 id="age">Age</h3>
<p>首部字段 Age 能告知客户端，源服务器在多久前创建了响应。字段值的单位为秒。</p>
<p>若创建该响应的服务器是缓存服务器，Age 值是指缓存后的响应再次发起认证到认证完成的时间值。代理创建响应时必须加上首部字段Age。</p>
<pre><code class="language-http">Age: 600
</code></pre>
<h3 id="etag">ETag</h3>
<pre><code class="language-http">ETag: &quot;82e22293907ce725faf67773957acd12&quot;
</code></pre>
<p>首部字段 ETag 能告知客户端实体标识。它是一种可将资源以字符串形式做唯一性标识的方式。服务器会为每份资源分配对应的 ETag值。</p>
<p>另外，当资源更新时，ETag 值也需要更新。生成 ETag 值时，并没有统一的算法规则，而仅仅是由服务器来分配。</p>
<p>资源被缓存时，就会被分配唯一性标识。例如，当使用中文版的浏览器访问 <code>http://www.google.com/</code> 时，就会返回中文版对应的资源，而使用英文版的浏览器访问时，则会返回英文版对应的资源。两者的URI 是相同的，所以仅凭 URI 指定缓存的资源是相当困难的。若在下载过程中出现连接中断、再连接的情况，都会依照 ETag 值来指定资源。</p>
<p><strong>强 ETag 值和弱 Tag 值</strong></p>
<p>ETag 中有强 ETag 值和弱 ETag 值之分。<br>
1、强 ETag 值<br>
强 ETag 值，不论实体发生多么细微的变化都会改变其值</p>
<pre><code class="language-sh">ETag: &quot;usagi-1234&quot;
</code></pre>
<p>弱 ETag 值<br>
弱 ETag 值只用于提示资源是否相同。只有资源发生了根本改变，产生差异时才会改变 ETag 值。这时，会在字段值最开始处附加 W/。</p>
<pre><code class="language-http">ETag: W/&quot;usagi-1234&quot;
</code></pre>
<h3 id="location">Location</h3>
<p>使用首部字段 Location 可以将响应接收方引导至某个与请求 URI 位置不同的资源。</p>
<p>基本上，该字段会配合 3xx ：Redirection 的响应，提供重定向的URI。</p>
<p>几乎所有的浏览器在接收到包含首部字段 Location 的响应后，都会强制性地尝试对已提示的重定向资源的访问。</p>
<pre><code class="language-http">Location: http://www.usagidesign.jp/sample.html
</code></pre>
<h3 id="proxy-authenticate">Proxy-Authenticate</h3>
<p>首部字段 Proxy-Authenticate 会把由代理服务器所要求的认证信息发送给客户端。</p>
<p>它与客户端和服务器之间的 HTTP 访问认证的行为相似，不同之处在于其认证行为是在客户端与代理之间进行的。而客户端与服务器之间进行认证时，首部字段 WWW-Authorization 有着相同的作用。</p>
<pre><code class="language-http">Proxy-Authenticate: Basic realm=&quot;Usagidesign Auth&quot;
</code></pre>
<h3 id="retry-after">Retry-After</h3>
<p>首部字段 Retry-After 告知客户端应该在多久之后再次发送请求。主要配合状态码 503 Service Unavailable 响应，或 3xx Redirect 响应一起使用。</p>
<p>字段值可以指定为具体的日期时间（Wed, 04 Jul 2012 06：34：24GMT 等格式），也可以是创建响应后的秒数。</p>
<pre><code class="language-http">Retry-After: Wed, 21 Oct 2015 07:28:00 GMT
Retry-After: 120
</code></pre>
<h3 id="server">Server</h3>
<p>首部字段 Server 告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息。不单单会标出服务器上的软件应用名称，还有可能包括版本号和安装时启用的可选项。</p>
<pre><code class="language-http">Server: Apache/2.2.17 (Unix)
Server: Apache/2.2.6 (Unix) PHP/5.2.5
</code></pre>
<h3 id="vary">Vary</h3>
<p>首部字段 Vary 可对缓存进行控制。源服务器会向代理服务器传达关于本地缓存使用方法的命令。</p>
<p>从代理服务器接收到源服务器返回包含 Vary 指定项的响应之后，若再要进行缓存，仅对请求中含有相同 Vary 指定首部字段的请求返回缓存。即使对相同资源发起请求，但由于 Vary 指定的首部字段不相同，因此必须要从源服务器重新获取资源。</p>
<pre><code class="language-http">Vary: Accept-Language
</code></pre>
<p>当代理服务器接收到带有 Vary 首部字段指定获取资源的请求时，如果使用的 Accept-Language 字段的值相同，那么就直接从缓存返回响应。反之，则需要先从源服务器端获取资源后才能作为响应返回</p>
<h3 id="www-authenticate">WWW-Authenticate</h3>
<p>首部字段 WWW-Authenticate 用于 HTTP 访问认证。它会告知客户端适用于访问请求 URI 所指定资源的认证方案（Basic 或是 Digest）和带参数提示的质询（challenge）。状态码 401 Unauthorized 响应中，肯定带有首部字段 WWW-Authenticate。</p>
<pre><code class="language-http">WWW-Authenticate: Basic realm=&quot;Usagidesign Auth&quot;
</code></pre>
<p>上述示例中，realm 字段的字符串是为了辨别请求 URI 指定资源所受到的保护策略。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[http-请求首部字段]]></title>
        <id>https://leecss.com/post/http-qing-qiu-shou-bu-zi-duan/</id>
        <link href="https://leecss.com/post/http-qing-qiu-shou-bu-zi-duan/">
        </link>
        <updated>2021-07-20T15:43:16.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>请求首部字段是从客户端往服务器端发送请求报文中所使用的字段，用于补充请求的附加信息、客户端信息、对响应内容相关的优先级等内容。</p>
<h2 id="列表">列表</h2>
<table>
<thead>
<tr>
<th>请求首部</th>
<th>作用（请求报文专用）</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept</td>
<td>能正确接收的媒体类型：<code>application/json</code> <code>text/plain</code></td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>能正确接收的字符集: <code>unicode-1-1</code></td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>能正确接收的内容编码格式列表：<code>gzip deflate</code></td>
</tr>
<tr>
<td>Accept-Language</td>
<td>能正确接收的语言列表：<code>zh-cn,zh;1=0.9,en,1=0.8</code></td>
</tr>
<tr>
<td>Authorization</td>
<td>客户端认证信息：<code>Bearer dSdSdFFlsfdjasd123</code>，一般存token用</td>
</tr>
<tr>
<td>Expect</td>
<td>指定期望条件，并告知服务器只有在满足此期望条件的情况下才能妥善地处理请求。</td>
</tr>
<tr>
<td>From</td>
<td>请求方邮箱地址</td>
</tr>
<tr>
<td>Host</td>
<td>服务器的域名，用于区分单台服务器多个域名的虚拟主机，是HTTP/1.1唯一必须包含的字段。</td>
</tr>
<tr>
<td>If-Match</td>
<td>服务器会比对 If-Match 的字段值和资源的 ETag 值，仅当两者一致时，才会执行请求</td>
</tr>
<tr>
<td>If-None-Match</td>
<td>服务器会比对 If-Match 的字段值和资源的 ETag 值，当两者不一致时，执行请求</td>
</tr>
<tr>
<td>If-Modified-Since</td>
<td>服务器只在所请求的资源在 If-Modified-Since 给定的日期时间之后对内容进行过修改的情况下才会将资源返回</td>
</tr>
<tr>
<td>If-Unmodified-Since</td>
<td>服务器只在所请求的资源在 If-Modified-Since 给定的日期时间之后对内容未进行过修改的情况下才会将资源返回</td>
</tr>
<tr>
<td>If-Range</td>
<td>该字段与Range字段配合使用，If-Range字段值中的条件得到满足时，Range 头字段才会起作用</td>
</tr>
<tr>
<td>Max-Forwards</td>
<td>限制可被代理及网关转发的次数</td>
</tr>
<tr>
<td>Proxy-Authorization</td>
<td>向代理服务器发送验证信息</td>
</tr>
<tr>
<td>Range</td>
<td>请求某个内容的一部分，配合<code>If-Range</code>使用</td>
</tr>
<tr>
<td>Referer</td>
<td>请求发起页面的原始URI</td>
</tr>
<tr>
<td>TE</td>
<td>传输编码方式</td>
</tr>
<tr>
<td>User-Agent</td>
<td>客户端信息</td>
</tr>
</tbody>
</table>
<h3 id="accept">Accept</h3>
<p>Accept 首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可使用 type/subtype 这种形式，一次指定多种媒体类型。</p>
<pre><code>文本文件
text/html, text/plain, text/css ...
application/xhtml+xml, application/xml ...

图片文件
image/jpeg, image/gif, image/png ...

视频文件
video/mpeg, video/quicktime ...

应用程序使用的二进制文件
application/octet-stream, application/zip ...
</code></pre>
<p>比如，如果浏览器不支持 PNG 图片的显示，那 Accept 就不指定image/png，而指定可处理的 image/gif 和 image/jpeg 等图片类型。<br>
若想要给显示的媒体类型增加优先级，则使用 q= 来额外表示权重值，用分号（;）进行分隔。权重值 q 的范围是 0~1（可精确到小数点后 3 位），且 1 为最大值。不指定权重 q 值时，默认权重为 q=1.0。</p>
<pre><code class="language-http">Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/png,*/*;q=0.8
</code></pre>
<h3 id="accept-charset">Accept-Charset</h3>
<p>Accept-Charset 首部字段可用来通知服务器用户代理支持的字符集及字符集的相对优先顺序。另外，可一次性指定多种字符集。与首部字段 Accept 相同的是可用权重 q 值来表示相对优先级。</p>
<pre><code class="language-http">Accept-Charset: iso-8859-5, unicode-1-1;q=0.8
</code></pre>
<h3 id="accept-encoding">Accept-Encoding</h3>
<p>Accept-Encoding 首部字段用来告知服务器用户代理支持的内容编码及内容编码的优先级顺序。可一次性指定多种内容编码。</p>
<pre><code>gzip
由文件压缩程序 gzip（GNU zip）生成的编码格式（RFC1952），采用 Lempel-Ziv 算法（LZ77）及 32 位循环冗余校验（Cyclic Redundancy Check，通称 CRC）。

compress
由 UNIX 文件压缩程序 compress 生成的编码格式，采用 LempelZiv-Welch 算法（LZW）。

deflate
组合使用 zlib 格式（RFC1950）及由 deflate 压缩算法（RFC1951）生成的编码格式。

identity
不执行压缩或不会变化的默认编码格式
</code></pre>
<p>采用权重 q 值来表示相对优先级，这点与首部字段 Accept 相同。另外，也可使用星号（*）作为通配符，指定任意的编码格式。</p>
<pre><code class="language-http">Accept-Encoding: gzip, deflate
</code></pre>
<h3 id="accept-language">Accept-Language</h3>
<p>首部字段 Accept-Language 用来告知服务器用户代理能够处理的自然语言集（指中文或英文等），以及自然语言集的相对优先级。可一次指定多种自然语言集。<br>
和 Accept 首部字段一样，按权重值 q 来表示相对优先级。客户端在服务器有中文版资源的情况下，会请求其返回中文版对应的响应，没有中文版时，则请求返回英文版响应。</p>
<pre><code class="language-http">Accept-Language: zh-cn,zh;q=0.7,en-us,en;q=0.3
</code></pre>
<h3 id="authorization">Authorization</h3>
<p>首部字段 Authorization 是用来告知服务器，用户代理的认证信息（证书值）。通常，想要通过服务器认证的用户代理会在接收到返回的401 状态码响应后，把首部字段 Authorization 加入请求中。共用缓存在接收到含有 Authorization 首部字段的请求时的操作处理会略有差异。</p>
<pre><code class="language-http">Authorization: Basic dWVub3NlbjpwYXNzd29yZA==
</code></pre>
<h3 id="expect">Expect</h3>
<p>客户端使用首部字段 Expect 来告知服务器，期望出现的某种特定行为。</p>
<p>等待状态码 100 响应的客户端在发生请求时，需要指定 Expect:100-continue。</p>
<p>客户端可以利用该首部字段，写明所期望的扩展。虽然 HTTP/1.1 规范只定义了 100-continue（状态码 100 Continue 之意）。</p>
<pre><code class="language-http">Expect: 100-continue
</code></pre>
<p>返回100表示请求头中的期望条件可以得到满足</p>
<p>因服务器无法理解客户端的期望作出回应而发生错误时，会返回状态码 417 Expectation Failed。</p>
<h3 id="from">From</h3>
<p>首部字段 From 用来告知服务器使用用户代理的用户的电子邮件地址。通常，其使用目的就是为了显示搜索引擎等用户代理的负责人的电子邮件联系方式。使用代理时，应尽可能包含 From 首部字段（但可能会因代理不同，将电子邮件地址记录在 User-Agent 首部字段内）。</p>
<pre><code class="language-http">From: webmaster@example.org
</code></pre>
<h3 id="host">Host</h3>
<p>首部字段 Host 会告知服务器，请求的资源所处的互联网主机名和端口号。<u>Host 首部字段在 HTTP/1.1 规范内是唯一一个必须被包含在请求内的首部字段。</u></p>
<pre><code class="language-http">Host: www.hackr.jp
</code></pre>
<p>首部字段 Host 和以单台服务器分配多个域名的虚拟主机的工作机制有很密切的关联，这是首部字段 Host 必须存在的意义。</p>
<p>请求被发送至服务器时，请求中的主机名会用 IP 地址直接替换解决。但如果这时，相同的 IP 地址下部署运行着多个域名，那么服务器就会无法理解究竟是哪个域名对应的请求。因此，就需要使用首部字段 Host 来明确指出请求的主机名。若服务器未设定主机名，那直接发送一个空值即可。如下所示。</p>
<pre><code class="language-http">Host:
</code></pre>
<h3 id="if-match">If-Match</h3>
<p>形如 If-xxx 这种样式的请求首部字段，都可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。</p>
<pre><code class="language-http">If-Match: &quot;123456&quot;
</code></pre>
<p>首部字段 If-Match，属附带条件之一，它会告知服务器匹配资源所用的实体标记（ETag）值。这时的服务器无法使用弱 ETag 值。</p>
<p>服务器会比对 If-Match 的字段值和资源的 ETag 值，仅当两者一致时，才会执行请求。反之，则返回状态码 412 Precondition Failed 的响应。</p>
<p>ETag 之间的比较使用的是强比较算法，即只有在每一个字节都相同的情况下，才可以认为两个文件是相同的。在 ETag 前面添加 W/ 前缀表示可以采用相对宽松的算法。</p>
<p>还可以使用星号（*）指定 If-Match 的字段值。针对这种情况，服务器将会忽略 ETag 的值，只要资源存在就处理请求。</p>
<pre><code class="language-http">If-Match: &quot;bfc13a64729c4290ef5b2c2730249c88ca92d82d&quot;
If-Match: W/&quot;67ab43&quot;, &quot;54ed21&quot;, &quot;7892dd&quot;
If-Match: *
</code></pre>
<h3 id="if-none-match">If-None-Match</h3>
<p>首部字段 If-None-Match 属于附带条件之一。它和首部字段 If-Match作用相反。用于指定 If-None-Match 字段值的实体标记（ETag）值与请求资源的 ETag 不一致时，它就告知服务器处理该请求。</p>
<p>在 GET 或 HEAD 方法中使用首部字段 If-None-Match 可获取最新的资源。因此，这与使用首部字段 If-Modified-Since 时有些类似。</p>
<pre><code class="language-http">If-None-Match: &quot;bfc13a64729c4290ef5b2c2730249c88ca92d82d&quot;
If-None-Match: W/&quot;67ab43&quot;, &quot;54ed21&quot;, &quot;7892dd&quot;
If-None-Match: *
</code></pre>
<h3 id="if-modified-since">If-Modified-Since</h3>
<p>首部字段 If-Modified-Since，属附带条件之一，它会告知服务器若 IfModified-Since 字段值早于资源的更新时间，则希望能处理该请求。而在指定 If-Modified-Since 字段值的日期时间之后，如果请求的资源都没有过更新，则返回状态码 304 Not Modified 的响应。</p>
<p>If-Modified-Since 用于确认代理或客户端拥有的本地资源的有效性。获取资源的更新日期时间，可通过确认首部字段 Last-Modified 来确定。</p>
<pre><code class="language-http">If-Modified-Since: Thu, 15 Apr 2004 00:00:00 GMT
</code></pre>
<h3 id="if-unmodified-since">If-Unmodified-Since</h3>
<p>首部字段 If-Unmodified-Since 和首部字段 If-Modified-Since 的作用相反。它的作用的是告知服务器，指定的请求资源只有在字段值内指定的日期时间之后，未发生更新的情况下，才能处理请求。如果在指定日期时间后发生了更新，则以状态码 412 Precondition Failed 作为响应返回。</p>
<pre><code class="language-http">If-Unmodified-Since: Thu, 03 Jul 2012 00:00:00 GMT
</code></pre>
<h3 id="if-range">If-Range</h3>
<p>该字段与Range字段配合使用，If-Range字段值中的条件得到满足时，Range 头字段才会起作用</p>
<p>首部字段 If-Range 属于附带条件之一。它告知服务器若指定的 If-Range 字段值（ETag 值或者时间）和请求资源的 ETag 值或时间相一致时，则作为范围请求处理。反之，则返回全体资源。</p>
<p>下面我们思考一下不使用首部字段 If-Range 发送请求的情况。服务器端的资源如果更新，那客户端持有资源中的一部分也会随之无效，当然，范围请求作为前提是无效的。这时，服务器会暂且以状态码 412Precondition Failed 作为响应返回，其目的是催促客户端再次发送请求。这样一来，与使用首部字段 If-Range 比起来，就需要花费两倍的功夫。</p>
<pre><code class="language-http">GET /index.html
If-Range: &quot;123456&quot;
Range: bytes=5001-10000
</code></pre>
<h3 id="max-forwards">Max-Forwards</h3>
<p>通过 TRACE 方法或 OPTIONS 方法，发送包含首部字段 MaxForwards 的请求时，该字段以十进制整数形式指定可经过的服务器最大数目。服务器在往下一个服务器转发请求之前，Max-Forwards 的值减 1 后重新赋值。当服务器接收到 Max-Forwards 值为 0 的请求时，则不再进行转发，而是直接返回响应。</p>
<p>使用 HTTP 协议通信时，请求可能会经过代理等多台服务器。途中，如果代理服务器由于某些原因导致请求转发失败，客户端也就等不到服务器返回的响应了。对此，我们无从可知。</p>
<p>可以灵活使用首部字段 Max-Forwards，针对以上问题产生的原因展开调查。由于当 Max-Forwards 字段值为 0 时，服务器就会立即返回响应，由此我们至少可以对以那台服务器为终点的传输路径的通信状况有所把握。</p>
<pre><code class="language-http">Max-Forwards: 10
</code></pre>
<h3 id="proxy-authorization">Proxy-Authorization</h3>
<p>接收到从代理服务器发来的认证质询时，客户端会发送包含首部字段Proxy-Authorization 的请求，以告知服务器认证所需要的信息。</p>
<p>这个行为是与客户端和服务器之间的 HTTP 访问认证相类似的，不同之处在于，认证行为发生在客户端与代理之间。客户端与服务器之间的认证，使用首部字段 Authorization 可起到相同作用。</p>
<pre><code class="language-http">Proxy-Authorization: Basic dGlwOjkpNLAGfFY5
</code></pre>
<h3 id="range">Range</h3>
<pre><code class="language-http">Range: bytes=5001-10000
</code></pre>
<p>对于只需获取部分资源的范围请求，包含首部字段 Range 即可告知服务器资源的指定范围。上面的示例表示请求获取从第 5001 字节至第10000 字节的资源。</p>
<p>接收到附带 Range 首部字段请求的服务器，会在处理请求之后返回状态码为 206 Partial Content 的响应。无法处理该范围请求时，则会返回状态码 200 OK 的响应及全部资源。</p>
<h3 id="referer">Referer</h3>
<p>首部字段 Referer 会告知服务器请求的原始资源的 URI。</p>
<p>客户端一般都会发送 Referer 首部字段给服务器。但当直接在浏览器的地址栏输入 URI，或出于安全性的考虑时，也可以不发送该首部字段。</p>
<p>因为原始资源的 URI 中的查询字符串可能含有 ID 和密码等保密信息，要是写进 Referer 转发给其他服务器，则有可能导致保密信息的泄露。</p>
<p>另外，Referer 的正确的拼写应该是 Referrer，但不知为何，大家一直沿用这个错误的拼写。</p>
<pre><code class="language-http">Referer: http://www.hackr.jp/index.htm
</code></pre>
<h3 id="te">TE</h3>
<pre><code class="language-http">TE: gzip, deflate;q=0.5
</code></pre>
<p>首部字段 TE 会告知服务器客户端能够处理响应的传输编码方式及相对优先级。它和首部字段 Accept-Encoding 的功能很相像，但是用于传输编码。</p>
<p><u>TE是用于传输编码，而Accept-Encoding用于内容编码。</u></p>
<p>首部字段 TE 除指定传输编码之外，还可以指定伴随 trailer 字段的分块传输编码的方式。应用后者时，只需把 trailers 赋值给该字段值。</p>
<pre><code class="language-http">TE: trailers
</code></pre>
<h3 id="user-agent">User-Agent</h3>
<p>User-Agent 用于传达浏览器的种类</p>
<p>首部字段 User-Agent 会将创建请求的浏览器和用户代理名称等信息传达给服务器。</p>
<p>由网络爬虫发起请求时，有可能会在字段内添加爬虫作者的电子邮件地址。此外，如果请求经过代理，那么中间也很可能被添加上代理服务器的名称。</p>
<pre><code class="language-http">User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.84 Safari/537.36 Name
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[http-通用首部字段Cache-Control]]></title>
        <id>https://leecss.com/post/http-tong-yong-shou-bu-zi-duan-cache-control/</id>
        <link href="https://leecss.com/post/http-tong-yong-shou-bu-zi-duan-cache-control/">
        </link>
        <updated>2021-07-19T15:35:46.000Z</updated>
        <content type="html"><![CDATA[<h1 id="http-通用首部字段cache-control">http-通用首部字段Cache-Control</h1>
<h2 id="概述">概述</h2>
<p>通过指定首部字段 Cache-Control 的指令，就能操作缓存的工作机制。</p>
<h2 id="书写格式">书写格式</h2>
<p>指令的参数是可选的，多个指令之间通过“,”分隔。首部字段 CacheControl 的指令可用于请求及响应时。</p>
<pre><code>Cache-Control: private, max-age=0, no-cache
</code></pre>
<h2 id="分类">分类</h2>
<h3 id="缓存请求指令">缓存请求指令</h3>
<table>
<thead>
<tr>
<th>指令</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>no-cache</td>
<td>无</td>
<td>不使用缓存，缓存服务器必须把客户端请求转发给源服务器，在与源服务器进行新鲜度再验证之前，不能提供给客户端使用。</td>
</tr>
<tr>
<td>no-store</td>
<td>无</td>
<td>真正的不使用缓存，任何地方都不缓存请求或响应的任何内容。</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>max-age=60</td>
<td>必需</td>
<td>资源可缓存最大时间(相对时间：秒)，即过期时间、保质期。</td>
</tr>
<tr>
<td>max-stale=60</td>
<td>可省略</td>
<td>缓存资源，只要仍处于 max-stale指定的时间(秒)内，即使过期也照常接收。缓存总时长为max-age和max-stale叠加。</td>
</tr>
<tr>
<td>min-fresh=60</td>
<td>必需</td>
<td>期望在指定时间内(未来60秒内)的响应保持新鲜</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>no-transform</td>
<td>无</td>
<td>代理不可更改媒体类型</td>
</tr>
<tr>
<td>only-if-cached</td>
<td>无</td>
<td>只从缓存获取资源，若有则返回，若无则504</td>
</tr>
</tbody>
</table>
<h3 id="缓存响应指令">缓存响应指令</h3>
<table>
<thead>
<tr>
<th>指令</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>no-cache</td>
<td>无</td>
<td>缓存前必须先确认其有效性</td>
</tr>
<tr>
<td>no-store</td>
<td>无</td>
<td>不缓存请求或响应的任何内容</td>
</tr>
<tr>
<td>public</td>
<td>无</td>
<td>客户端、代理服务器都可利用缓存</td>
</tr>
<tr>
<td>private</td>
<td>无</td>
<td>仅发起请求的客户端可利用缓存</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>max-age=60</td>
<td>必需</td>
<td>针对源服务器，资源可缓存最大时间</td>
</tr>
<tr>
<td>s-maxage=60</td>
<td>必需</td>
<td>针对代理缓存服务器，资源可缓存最大时间</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>must-revalidate</td>
<td>无</td>
<td>可缓存但必须再向源服务器进行确认</td>
</tr>
<tr>
<td>proxy-revalidate</td>
<td>无</td>
<td>代理缓存服务器对缓存的响应有效性再进行确认</td>
</tr>
<tr>
<td>no-transform</td>
<td>无</td>
<td>代理不可更改媒体类型</td>
</tr>
</tbody>
</table>
<h2 id="详解">详解</h2>
<h3 id="no-cache">no-cache</h3>
<p>使用 no-cache 指令的目的是为了防止从缓存中返回过期的资源。</p>
<p><strong>客户端</strong>发送的请求中如果包含 no-cache 指令，则表示客户端将不会接收缓存过的响应。于是，“中间”的缓存服务器必须把客户端请求转发给源服务器。</p>
<p>如果<strong>服务器</strong>返回的响应中包含 no-cache 指令，那么缓存服务器不能对资源进行缓存。源服务器以后也将不再对缓存服务器请求中提出的资源有效性进行确认，且禁止其对响应资源进行缓存操作。</p>
<pre><code>Cache-Control: no-cache
</code></pre>
<p>如果可以使用缓存，则304；不可以使用，则200。</p>
<h3 id="max-age">max-age</h3>
<p>当<strong>客户端</strong>发送的请求中包含 max-age 指令时，如果判定缓存资源的缓存时间数值比指定时间的数值更小，那么客户端就接收缓存的资源。<br>
另外，<u>当指定 max-age 值为 0，那么缓存服务器通常需要将请求转发给源服务器</u>。</p>
<p>当<strong>服务器</strong>返回的响应中包含 max-age 指令时，缓存服务器将不对资源的有效性再作确认，而 max-age 数值代表资源保存为缓存的最长时间。</p>
<pre><code>Cache-Control: max-age=604800（单位：秒）
</code></pre>
<h3 id="min-fresh">min-fresh</h3>
<p>min-fresh 指令要求缓存服务器返回至少还未过指定时间的缓存资源。</p>
<p>比如，当指定 min-fresh 为 60 秒后，过了 60 秒的资源都无法作为响应返回了。</p>
<pre><code>Cache-Control: min-fresh=60（单位：秒）
</code></pre>
<h3 id="max-stale">max-stale</h3>
<p>使用 max-stale 可指示缓存资源，即使过期也照常接收。</p>
<p>如果指令中指定了具体数值，那么即使过期，只要仍处于 max-stale指定的时间内，仍旧会被客户端接收。</p>
<p><u>如果指令未指定参数值，那么无论经过多久，客户端都会接收响应；</u></p>
<pre><code>Cache-Control: max-stale=3600（单位：秒）
</code></pre>
<h3 id="only-if-cached">only-if-cached</h3>
<p>使用 only-if-cached 指令表示客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回。换言之，该指令要求缓存服务器不重新加载响应，也不会再次确认资源有效性。若发生请求缓存服务器的本地缓存无响应，则返回状态码 504 Gateway Timeout。</p>
<pre><code>Cache-Control: only-if-cached
</code></pre>
<h3 id="must-revalidate">must-revalidate</h3>
<p>使用 must-revalidate 指令，代理会向源服务器再次验证即将返回的响应缓存目前是否仍然有效。</p>
<p>若代理无法连通源服务器再次获取有效资源的话，缓存必须给客户端一条 504（Gateway Timeout）状态码。</p>
<p>另外，使用 must-revalidate 指令会忽略请求的 max-stale 指令（即使已经在首部使用了 max-stale，也不会再有效果）。</p>
<pre><code>Cache-Control: must-revalidate
</code></pre>
<h3 id="proxy-revalidate">proxy-revalidate</h3>
<p>proxy-revalidate 指令要求所有的缓存服务器在接收到客户端带有该指令的请求返回响应之前，必须再次验证缓存的有效性。</p>
<pre><code>Cache-Control: proxy-revalidate
</code></pre>
<h3 id="no-transform">no-transform</h3>
<p>有时为了提高性能，缓存或代理会有压缩图片等类似操作</p>
<p>使用 no-transform 指令规定无论是在请求还是响应中，缓存都不能改变实体主体的媒体类型。<br>
这样做可防止缓存或代理压缩图片等类似操作</p>
<h2 id="浏览器缓存机制">浏览器缓存机制</h2>
<p>以下总结自<a href="https://blog.csdn.net/kkdelta/article/details/100576096">网络</a>，以后确认具体过程。</p>
<p>1、当前缓存是否过期？2、服务器中的文件是否可用？</p>
<p><strong>第一步：判断当前缓存是否过期</strong></p>
<p>浏览器请求server.js文件，</p>
<p>假如文件还在缓存有效期内，则直接使用缓存，不会重新发起请求。</p>
<p>假如文件缓存过期，则重新发起请求。</p>
<p><strong>第二步：判断服务器中的文件是否可用</strong></p>
<p>服务器判断请求的server.js文件是否在缓存有效期内，若有效，则返回响应头304，浏览器直接使用过期缓存；</p>
<p>若文件已过期，服务器判断文件是否有改动，无改动，则返回响应头304，浏览器直接使用过期缓存；</p>
<p>若文件有改动，则返回200，并返回新文件。</p>
<h2 id="cache-control使用图解">cache-control使用图解</h2>
<figure data-type="image" tabindex="1"><img src="https://leecss.com/post-images/1626740943823.webp" alt="" loading="lazy"></figure>
<h2 id="目前仍有的疑问">目前仍有的疑问</h2>
<p>1、缓存总时长为max-age和max-stale叠加，取值为相加值，还是最大值？</p>
<p>2、must-revalidate和proxy-revalidate区别？</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[http-通用首部字段]]></title>
        <id>https://leecss.com/post/http-tong-yong-shou-bu-zi-duan/</id>
        <link href="https://leecss.com/post/http-tong-yong-shou-bu-zi-duan/">
        </link>
        <updated>2021-07-18T23:08:49.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>通用首部字段是指，请求报文和响应报文双方都会使用的首部。</p>
<h2 id="列表">列表</h2>
<table>
<thead>
<tr>
<th>通用首部</th>
<th>作用（请求报文和响应报文都可能使用）</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cache-Control</td>
<td>控制缓存的行为</td>
</tr>
<tr>
<td>Connection</td>
<td>管理持久连接：决定当前的事务完成后，是否会关闭网络连接</td>
</tr>
<tr>
<td>Date</td>
<td>创建报文时间</td>
</tr>
<tr>
<td>Pragma</td>
<td>兼容HTTP/1.0字段：只用于请求报文，客户端要求中间服务器不返回缓存的资源</td>
</tr>
<tr>
<td>Trailer</td>
<td>允许发送方在分块发送的消息后面添加额外的元信息，常用于分块传输编码中。</td>
</tr>
<tr>
<td>Transfer-Encoding</td>
<td>规定了传输报文主体时采用的编码方式：<code>chunked</code>分块传输</td>
</tr>
<tr>
<td>Upgrade</td>
<td>要求客户端使用的升级协议，需配合<code>Connection: Upgrade</code>一起使用：<code>websocket</code></td>
</tr>
<tr>
<td>Via</td>
<td>代理服务器相关信息，每经过一个代理服务器就会添加相关信息，用逗号分割</td>
</tr>
<tr>
<td>Warning</td>
<td>缓存相关问题的警告</td>
</tr>
</tbody>
</table>
<h3 id="cache-control">Cache-Control</h3>
<p>可缓存性</p>
<p><code>public</code>（客户端、代理服务器都可利用缓存）</p>
<p><code>private</code>（发起请求的浏览器才可以缓存,代理服务器不可用缓存）</p>
<p><code>no-cache</code>（本地可以用使用缓存，但需要服务器验证后才能使用）</p>
<p><code>no-store</code>（不做任何缓存）</p>
<p>到期</p>
<p><code>max-age=200</code>（服务器缓存到期时间， 秒）</p>
<p><code>s-maxage=200</code> (代理服务器缓存的到期时间， 秒)</p>
<h3 id="connection">Connection</h3>
<p>管理持久连接：决定当前的事务完成后，是否会关闭网络连接。</p>
<p>Http协议1.1之后默认都是keep-alive（持久连接），1.0则是close（非持久连接）。</p>
<pre><code>Connection: keep-alive
Connection: close
</code></pre>
<h3 id="date">Date</h3>
<p>表明创建 HTTP 报文的日期和时间。</p>
<pre><code>Date: Tue, 03 Jul 2012 04:40:59 GMT
</code></pre>
<h3 id="pragma">Pragma</h3>
<p>Pragma 是 HTTP/1.1 之前版本的历史遗留字段，仅作为与 HTTP/1.0的向后兼容而定义。</p>
<p>规范定义的形式唯一，如下所示。</p>
<pre><code>Pragma: no-cache
</code></pre>
<p>该首部字段属于通用首部字段，但只用在客户端发送的请求中。客户端会要求所有的中间服务器不返回缓存的资源。</p>
<p>所有的中间服务器如果都能以 HTTP/1.1 为基准，那直接采用 CacheControl: no-cache 指定缓存的处理方式是最为理想的。但要整体掌握全部中间服务器使用的 HTTP 协议版本却是不现实的。因此，发送的请求会同时含有下面两个首部字段。</p>
<pre><code>Cache-Control: no-cache
Pragma: no-cache
</code></pre>
<h3 id="trailer">Trailer</h3>
<p>首部字段 Trailer 会事先说明在报文主体后记录了哪些首部字段。该首部字段可应用在 HTTP/1.1 版本分块传输编码时。</p>
<pre><code>HTTP/1.1 200 OK
Date: Tue, 03 Jul 2012 04:40:56 GMT
Content-Type: text/html
...
Transfer-Encoding: chunked
Trailer: Expires
...(报文主体)...
0
Expires: Tue, 28 Sep 2004 23:59:59 GMT
</code></pre>
<p>以上用例中，指定首部字段 Trailer 的值为 Expires，在报文主体之后（分块长度 0 之后）出现了首部字段 Expires。</p>
<h3 id="transfer-encoding">Transfer-Encoding</h3>
<p>规定了传输报文主体时采用的编码方式。</p>
<p>HTTP/1.1 的传输编码方式仅对分块传输编码有效。</p>
<pre><code>HTTP/1.1 200 OK
Date: Tue, 03 Jul 2012 04:40:56 GMT
Cache-Control: public, max-age=604800
Content-Type: text/javascript; charset=utf-8
Expires: Tue, 10 Jul 2012 04:40:56 GMT
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
Content-Encoding: gzip
Transfer-Encoding: chunked
Connection: keep-alive
cf0 ←16进制(10进制为3312)
...3312字节分块数据...
392 ←16进制(10进制为914)
...914字节分块数据...
0
</code></pre>
<h3 id="upgrade">Upgrade</h3>
<p>首部字段 Upgrade 用于检测 HTTP 协议及其他协议是否可使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议。</p>
<pre><code>GET /index.htm HTTP/1.1
Upgrade: TLS/1.0
Connection: Upgrade
------------------&gt;
&lt;------------------
HTTP/1.1 101 Switching Protocols
Upgrade: TLS/1.0, HTTP/1.1
Connection: Upgrade
</code></pre>
<p>上图用例中，首部字段 Upgrade 指定的值为 TLS/1.0。请注意此处两个字段首部字段的对应关系，Connection 的值被指定为 Upgrade。Upgrade 首部字段产生作用的 Upgrade 对象仅限于客户端和邻接服务器之间。因此，使用首部字段 Upgrade 时，还需要额外指定Connection:Upgrade。</p>
<p>对于附有首部字段 Upgrade 的请求，服务器可用 101 Switching Protocols 状态码作为响应返回。</p>
<h3 id="via">Via</h3>
<p>使用首部字段 Via 是为了追踪客户端与服务器之间的请求和响应报文的传输路径。</p>
<p>报文经过代理或网关时，会先在首部字段 Via 中附加该服务器的信息，然后再进行转发。</p>
<p>首部字段 Via 不仅用于追踪报文的转发，还可避免请求回环的发生。所以必须在经过代理时附加该首部字段内容。</p>
<pre><code>客户端: 
GET / HTTP/1.1

代理服务器A: 
GET / HTTP/1.1
Via: 1.0 gw.hackr.jp (Squid/3.1)

代理服务器B:
GET / HTTP/1.1
Via: 1.0 gw.hackr.jp (Squid/3.1), 1.1 a1.example.net(Squid/2.7)

源服务器
</code></pre>
<p>上图用例中，在经过代理服务器 A 时，Via 首部附加了“1.0 gw.hackr.jp (Squid/3.1)”这样的字符串值。行头的 1.0 是指接收请求的97服务器上应用的 HTTP 协议版本。接下来经过代理服务器 B 时亦是如此，在 Via 首部附加服务器信息，也可增加 1 个新的 Via 首部写入服务器信息。</p>
<p>Via 首部是为了追踪传输路径，所以经常会和 TRACE 方法一起使用。比如，代理服务器接收到由 TRACE 方法发送过来的请求（其中Max-Forwards: 0）时，代理服务器就不能再转发该请求了。这种情况下，代理服务器会将自身的信息附加到 Via 首部后，返回该请求的响应。</p>
<h3 id="warning">Warning</h3>
<p>用于告知用户一些与缓存相关的问题的警告。</p>
<p>Warning 首部的格式如下。最后的日期时间部分可省略。</p>
<pre><code>Warning: [警告码][警告的主机:端口号]“[警告内容]”([日期时间])
Warning: 112 gw.hacker.jp:8080  &quot;cache down&quot; &quot; Wed, 21 Oct 2015 07:28:00 GMT&quot;
</code></pre>
<p><strong>警告码表</strong></p>
<table>
<thead>
<tr>
<th>警告码</th>
<th>警告内容</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>110</td>
<td>Response is stale</td>
<td>响应已过期：由缓存服务器提供的响应已过期（设置的失效时间已过）。</td>
</tr>
<tr>
<td>111</td>
<td>Revalidation failed</td>
<td>再验证失败：由于无法访问服务器，响应验证失败。</td>
</tr>
<tr>
<td>112</td>
<td>Disconnection operation</td>
<td>断开连接操作：缓存服务器断开连接。</td>
</tr>
<tr>
<td>113</td>
<td>Heuristic expiration</td>
<td>试探性过期：响应的使用期超过24小时（有效缓存的设定时间大于24小时的情况下）</td>
</tr>
<tr>
<td>199</td>
<td>Miscellaneous warning</td>
<td>杂项警告：任意的警告内容</td>
</tr>
<tr>
<td>214</td>
<td>Transformation applied</td>
<td>使用了转换：由代理服务器添加，如果它对返回的展现内容进行了任何转换，比如改变了内容编码、媒体类型等。</td>
</tr>
<tr>
<td>299</td>
<td>Miscellaneous persistent warning</td>
<td>持久杂项警告：任意的警告内容</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[http-首部字段]]></title>
        <id>https://leecss.com/post/http-shou-bu-zi-duan/</id>
        <link href="https://leecss.com/post/http-shou-bu-zi-duan/">
        </link>
        <updated>2021-07-18T04:59:53.000Z</updated>
        <content type="html"><![CDATA[<h2 id="http-首部字段结构">HTTP 首部字段结构</h2>
<p>HTTP 首部字段是由首部字段名和字段值构成的，中间用冒号“:” 分<br>
隔。</p>
<pre><code>首部字段名: 字段值
</code></pre>
<p>例如，在 HTTP 首部中以 Content-Type 这个字段来表示报文主体的 对<br>
象类型。</p>
<pre><code>Content-Type: text/html
</code></pre>
<p>就以上述示例来看，首部字段名为 Content-Type，字符串 text/html 是<br>
字段值。<br>
另外，字段值对应单个 HTTP 首部字段可以有多个值，如下所示。</p>
<pre><code>Keep-Alive: timeout=15, max=100
</code></pre>
<h2 id="4-种-http-首部字段类型">4 种 HTTP 首部字段类型</h2>
<p>HTTP 首部字段根据实际用途被分为以下 4 种类型。</p>
<h3 id="1-通用首部字段general-header-fields">1、通用首部字段（General Header Fields）</h3>
<p>请求报文和响应报文两方都会使用的首部。</p>
<h3 id="2-请求首部字段request-header-fields">2、请求首部字段（Request Header Fields）</h3>
<p>从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。</p>
<h3 id="3-响应首部字段response-header-fields">3、响应首部字段（Response Header Fields）</h3>
<p>从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。</p>
<h3 id="4-实体首部字段entity-header-fields">4、实体首部字段（Entity Header Fields）</h3>
<p>针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。</p>
<h2 id="http11-首部字段一览">HTTP/1.1 首部字段一览</h2>
<h3 id="通用首部字段">通用首部字段</h3>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cache-Control</td>
<td>控制缓存的行为</td>
</tr>
<tr>
<td>Connection</td>
<td>逐跳首部、连接的管理</td>
</tr>
<tr>
<td>Date</td>
<td>创建报文的日期时间</td>
</tr>
<tr>
<td>Pragma</td>
<td>报文指令</td>
</tr>
<tr>
<td>Trailer</td>
<td>报文末端的首部一览</td>
</tr>
<tr>
<td>Transfer-Encoding</td>
<td>指定报文主体的传输编码方式</td>
</tr>
<tr>
<td>Upgrade</td>
<td>升级为其他协议</td>
</tr>
<tr>
<td>Via</td>
<td>代理服务器的相关信息</td>
</tr>
<tr>
<td>Warning</td>
<td>错误通知</td>
</tr>
</tbody>
</table>
<h3 id="请求首部字段">请求首部字段</h3>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept</td>
<td>用户代理可处理的媒体类型</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>优先的字符集</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>优先的内容编码</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>优先的语言（自然语言）</td>
</tr>
<tr>
<td>Authorization Web</td>
<td>认证信息</td>
</tr>
<tr>
<td>Expect</td>
<td>期待服务器的特定行为</td>
</tr>
<tr>
<td>From</td>
<td>用户的电子邮箱地址</td>
</tr>
<tr>
<td>Host</td>
<td>请求资源所在服务器</td>
</tr>
<tr>
<td>If-Match</td>
<td>比较实体标记（ETag）</td>
</tr>
<tr>
<td>If-Modified-Since</td>
<td>比较资源的更新时间</td>
</tr>
<tr>
<td>If-None-Match</td>
<td>比较实体标记（与 If-Match 相反）</td>
</tr>
<tr>
<td>If-Range</td>
<td>资源未更新时发送实体 Byte 的范围请求</td>
</tr>
<tr>
<td>If-Unmodified-Since</td>
<td>比较资源的更新时间（与If-Modified-Since相反）</td>
</tr>
<tr>
<td>Max-Forwards</td>
<td>最大传输逐跳数</td>
</tr>
<tr>
<td>Proxy-Authorization</td>
<td>代理服务器要求客户端的认证信息</td>
</tr>
<tr>
<td>Range</td>
<td>实体的字节范围请求</td>
</tr>
<tr>
<td>Referer</td>
<td>对请求中 URI 的原始获取方</td>
</tr>
<tr>
<td>TE</td>
<td>传输编码的优先级</td>
</tr>
<tr>
<td>User-Agent HTTP</td>
<td>客户端程序的信息</td>
</tr>
</tbody>
</table>
<h3 id="响应首部字段">响应首部字段</h3>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept-Ranges</td>
<td>是否接受字节范围请求</td>
</tr>
<tr>
<td>Age</td>
<td>推算资源创建经过时间</td>
</tr>
<tr>
<td>ETag</td>
<td>资源的匹配信息</td>
</tr>
<tr>
<td>Location</td>
<td>令客户端重定向至指定URI</td>
</tr>
<tr>
<td>Proxy-Authenticate</td>
<td>代理服务器对客户端的认证信息</td>
</tr>
<tr>
<td>Retry-After</td>
<td>对再次发起请求的时机要求</td>
</tr>
<tr>
<td>Server HTTP</td>
<td>服务器的安装信息</td>
</tr>
<tr>
<td>Vary</td>
<td>代理服务器缓存的管理信息</td>
</tr>
<tr>
<td>WWW-Authenticate</td>
<td>服务器对客户端的认证信息</td>
</tr>
</tbody>
</table>
<h3 id="实体首部字段">实体首部字段</h3>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Allow</td>
<td>资源可支持的HTTP方法</td>
</tr>
<tr>
<td>Content-Encoding</td>
<td>实体主体适用的编码方式</td>
</tr>
<tr>
<td>Content-Language</td>
<td>实体主体的自然语言</td>
</tr>
<tr>
<td>Content-Length</td>
<td>实体主体的大小（单位：字节）</td>
</tr>
<tr>
<td>Content-Location</td>
<td>替代对应资源的URI</td>
</tr>
<tr>
<td>Content-MD5</td>
<td>实体主体的报文摘要</td>
</tr>
<tr>
<td>Content-Range</td>
<td>实体主体的位置范围</td>
</tr>
<tr>
<td>Content-Type</td>
<td>实体主体的媒体类型</td>
</tr>
<tr>
<td>Expires</td>
<td>实体主体过期的日期时间</td>
</tr>
<tr>
<td>Last-Modified</td>
<td>资源的最后修改日期时间</td>
</tr>
</tbody>
</table>
<h2 id="非-http11-首部字段">非 HTTP/1.1 首部字段</h2>
<p>在 HTTP 协议通信交互中使用到的首部字段，不限于 RFC2616 中定义的 47 种首部字段。还有 Cookie、Set-Cookie 和 Content-Disposition等在其他 RFC 中定义的首部字段，它们的使用频率也很高。</p>
<p>这些非正式的首部字段统一归纳在 RFC4229 HTTP Header Field Registrations 中。</p>
<h2 id="end-to-end-首部和-hop-by-hop-首部">End-to-end 首部和 Hop-by-hop 首部</h2>
<p>HTTP 首部字段将定义成缓存代理和非缓存代理的行为，分成 2 种类<br>
型。</p>
<h3 id="端到端首部end-to-end-header">端到端首部（End-to-end Header）</h3>
<p>分在此类别中的首部会转发给请求 / 响应对应的最终接收目标，且必须保存在由缓存生成的响应中，另外规定它必须被转发。</p>
<h3 id="逐跳首部hop-by-hop-header">逐跳首部（Hop-by-hop Header）</h3>
<p>分在此类别中的首部只对单次转发有效，会因通过缓存或代理而不再转发。HTTP/1.1 和之后版本中，如果要使用 hop-by-hop 首部，需提供 Connection 首部字段。</p>
<p>下面列举了 HTTP/1.1 中的逐跳首部字段。除这 8 个首部字段之外，其他所有字段都属于端到端首部。</p>
<ul>
<li>Connection</li>
<li>Keep-Alive</li>
<li>Proxy-Authenticate</li>
<li>Proxy-Authorization</li>
<li>Trailer</li>
<li>TE</li>
<li>Transfer-Encoding</li>
<li>Upgrade</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[electron-增量更新]]></title>
        <id>https://leecss.com/post/electron-zeng-liang-geng-xin/</id>
        <link href="https://leecss.com/post/electron-zeng-liang-geng-xin/">
        </link>
        <updated>2021-07-16T11:49:28.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>先介绍一下技术构成，项目是完整的vue项目，在现有项目上完成electron打包及更新。</p>
<p>打包使用的vue-cli-plugin-electron-builder插件，增量更新为具体的代码实现，并没有用到electron-updater。</p>
<h2 id="思路">思路</h2>
<p>1、比较本地和远程的版本</p>
<p>本地的版本可以放在一个app.txt文件中，或者通过变量获取。</p>
<p>远程的版本通过服务端文件（yml或者json）获取</p>
<p>比较版本，若相同则不更新，返回。</p>
<p>若不同，则提示更新，或直接进入更新流程</p>
<p>2、更新流程：通过线上增量包文件地址，进行下载</p>
<p>3、将zip压缩包解压缩</p>
<p>4、重新加载</p>
<h2 id="详解">详解</h2>
<h3 id="一-vue-cli-plugin-electron-builder">一、vue-cli-plugin-electron-builder</h3>
<p>安装vue-cli-plugin-electron-builder</p>
<pre><code>vue add electron-builder@2.0.0-rc.6
</code></pre>
<p>版本选择9.0.0</p>
<h2 id="二-新建vueconfigjs">二、新建vue.config.js</h2>
<p>1、重点是：<strong>&quot;asar&quot;: false,</strong></p>
<p>这句话的意思是，打包的时候<code>resources</code>下就不产生<code>app.asar</code>，而是一个app文件夹，而这个文件夹呢是可以直接进行替换的，里面的内容就是我们的前端整个项目的打包，就是渲染进程。所以，我们每次只需要替换前端的打包就可以了，而不需要每次都安装替换整个app</p>
<p>2、将app图标放到public文件夹下</p>
<pre><code class="language-js">module.exports = {
  pluginOptions: {
    electronBuilder: {
      builderOptions: {
        //productName: &quot;ebopo&quot;, // 项目名,这也是生成的exe文件的前缀名
        copyright: 'Copyright © Ambow',  // 应用程序版权行
        publish: [{
          &quot;provider&quot;: &quot;generic&quot;,
          &quot;channel&quot;: &quot;latest&quot;,
          &quot;url&quot;: &quot;http://ambow-ebopo.oss-cn-beijing.aliyuncs.com/common/electron/&quot;,
        }],
        &quot;win&quot;: {//win相关配置
          &quot;icon&quot;: &quot;./public/app.ico&quot;,//图标，当前图标在根目录下，注意这里有两个坑
          &quot;target&quot;: [
              {
                  &quot;target&quot;: &quot;nsis&quot;,//利用nsis制作安装程序
                  &quot;arch&quot;: [
                      &quot;x64&quot;,//64位
                      &quot;ia32&quot;//32位
                  ]
              }
          ]
        },
        &quot;asar&quot;: false,
        &quot;nsis&quot;: {
          &quot;oneClick&quot;: false, // 是否一键安装
          &quot;allowElevation&quot;: true, // 允许请求提升。 如果为false，则用户必须使用提升的权限重新启动安装程序。          
          &quot;allowToChangeInstallationDirectory&quot;: true, // 允许修改安装目录
          &quot;installerIcon&quot;: &quot;./public/app.ico&quot;,// 安装图标
          &quot;uninstallerIcon&quot;: &quot;./public/app.ico&quot;,//卸载图标
          &quot;installerHeaderIcon&quot;: &quot;./public/app.ico&quot;, // 安装时头部图标
          &quot;createDesktopShortcut&quot;: true, // 创建桌面图标
          &quot;createStartMenuShortcut&quot;: true,// 创建开始菜单图标
          &quot;shortcutName&quot;: &quot;ebopo&quot;, // 图标名称
        },
      }
    }
  }
}
</code></pre>
<h2 id="三-配置信息">三、配置信息</h2>
<p>background.js</p>
<pre><code class="language-js">
let win

function createWindow() {
  win = new BrowserWindow({
    width: 800,
    height: 600,     
    icon: `${__static}/app.ico`, // app内左上角图标
    webPreferences: {
      webSecurity: false, //取消跨域限制
      nodeIntegration:true, //开启node
    }
  })
}
</code></pre>
<p>package.json</p>
<pre><code class="language-js">// 打包exe前缀名称,及项目内左上角显示名称
&quot;name&quot;: &quot;ebopo&quot;,
// 版本号
&quot;version&quot;: &quot;1.0.0&quot;,
&quot;author&quot;: &quot;leecss&quot;,
&quot;description&quot;: &quot;electronApp&quot;,
</code></pre>
<h2 id="四-新增electron目录及设置菜单">四、新增electron目录及设置菜单</h2>
<p>在src文件夹下新建electron目录，在目录中新建menu.js</p>
<pre><code class="language-js">import { BrowserWindow, Menu, app} from 'electron'

let template = [{
  label: '查看',
  submenu: [{
    label: '重载',
    accelerator: 'CmdOrCtrl+R',
    click: (item, focusedWindow) =&gt; {
      if (focusedWindow) {
        // 重载之后, 刷新并关闭所有之前打开的次要窗体
        if (focusedWindow.id === 1) {
          BrowserWindow.getAllWindows().forEach(win =&gt; {
            if (win.id &gt; 1) win.close()
          })
        }
        focusedWindow.reload()
      }
    }
  }, {
    label: '切换全屏',
    accelerator: (() =&gt; {
      if (process.platform === 'darwin') {
        return 'Ctrl+Command+F'
      } else {
        return 'F11'
      }
    })(),
    click: (item, focusedWindow) =&gt; {
      if (focusedWindow) {
        focusedWindow.setFullScreen(!focusedWindow.isFullScreen())
      }
    }
  }]
}, {
  label: '窗口',
  role: 'window',
  submenu: [{
    label: '最小化',
    accelerator: 'CmdOrCtrl+M',
    role: 'minimize'
  }, {
    label: '关闭',
    accelerator: 'CmdOrCtrl+W',
    role: 'close'
  }]
}, {
  label: '帮助',
  role: 'help',
  submenu: [     
    {
      label: `版本` + app.getVersion(),
      enabled: false      
    },
    {
      label: '切换开发者工具',
      accelerator: (() =&gt; {
        if (process.platform === 'darwin') {
          return 'Alt+Command+I'
        } else {
          return 'Ctrl+Shift+I'
        }
      })(),
      click: (item, focusedWindow) =&gt; {
        if (focusedWindow) {
          focusedWindow.toggleDevTools()
        }
      }
    }
  ]
}]

var list = Menu.buildFromTemplate(template)
Menu.setApplicationMenu(list)
</code></pre>
<p>修改background.js ，在主进程中引入菜单</p>
<pre><code class="language-js">async function createWindow() {
+	require('./electron/menu.js')
}
</code></pre>
<h2 id="五-添加调试及日志文件输出">五、添加调试及日志文件输出</h2>
<pre><code>npm i  electron-log
</code></pre>
<p>在electron目录下新建log.js</p>
<pre><code class="language-js">import log from 'electron-log'

log.transports.file.level = 'silly'
log.transports.console.level = false // 禁用console输出

export default log
</code></pre>
<p>在background.js 中使用</p>
<pre><code class="language-js">import log from './electron/log'

log.warn('hello')
</code></pre>
<p>日志文件查看：文件main.log存储位置</p>
<pre><code>C:\Users\{用户}\AppData\Roaming\{appName}\logs
</code></pre>
<h2 id="六-更新流程比较版本">六、更新流程：比较版本</h2>
<p>安装并引入axios</p>
<pre><code>npm i axios
</code></pre>
<p>background.js</p>
<pre><code>import axios from 'axios'
</code></pre>
<p>比较版本，若相同则返回，不相同则更新</p>
<pre><code>async function createWindow() {
  require('./electron/menu.js')
  // Create the browser window.
  win = new BrowserWindow({
    width: 800,
    height: 600,
    icon: `${__static}/app.ico`, // app内左上角图标
    webPreferences: {      
      webSecurity: false, //取消跨域限制
      nodeIntegration:true, //开启node
    }
  })

  if (process.env.WEBPACK_DEV_SERVER_URL) {
    // Load the url of the dev server if in development mode
    await win.loadURL(process.env.WEBPACK_DEV_SERVER_URL)
    if (!process.env.IS_TEST) win.webContents.openDevTools()
  } else {
    createProtocol('app')
    // Load the index.html when not in development
    win.loadURL('app://./index.html')
    
    
    
    log.warn('hello')
    // 判断是否热更新，版本对比
    const updateUrl = 'http://ambow-ebopo.oss-cn-beijing.aliyuncs.com/common/electron'
    const currentVersion = app.getVersion()
    log.warn('currentVersion',currentVersion)    
    axios({
      url: updateUrl + '/latest.yml',
      method: 'GET'
    }).then(res =&gt; {      
      const remoteVersion = JSON.stringify(res.data).split('\\n')[0].split(' ')[1]
      log.warn('remoteVersion',remoteVersion)      
      if (currentVersion === remoteVersion) {
        log.warn('版本相同，无需更新')
        return;
      }
      // 热更新
      const updateZipUrl = updateUrl + '/app.zip'
      increment(updateZipUrl)      
    })
    
    
    
  }
}
</code></pre>
<h2 id="七-更新流程下载远程更新包appzip">七、更新流程：下载远程更新包app.zip</h2>
<p>在electron目录中新建downloadFile.js</p>
<p>下载文件需要两个参数：下载路径，保存路径</p>
<p>下载文件返回一个参数：保存路径</p>
<p>安装fs-extra</p>
<pre><code>npm i fs-extra
</code></pre>
<pre><code class="language-js">const request = require('request')
const fs = require('fs')
const fse = require('fs-extra')
const path = require('path')
import log from './log'

function download(url, targetPath, cb = () =&gt; { }) {
  let status
  const req = request({
    method: 'GET',
    uri: encodeURI(url)
  })
  try {
    const stream = fs.createWriteStream(targetPath)
    let len = 0
    let cur = 0
    req.pipe(stream)
    req.on('response', (data) =&gt; {
      len = parseInt(data.headers['content-length'])
    })
    req.on('data', (chunk) =&gt; {
      cur += chunk.length
      const progress = (100 * cur / len).toFixed(2)
      status = 'progressing'
      cb(status, progress)
    })
    req.on('end', function () {
      if (req.response.statusCode === 200) {
        if (len === cur) {
          console.log(targetPath + ' Download complete ')
          status = 'completed'
          cb(status, 100)
        } else {
          stream.end()
          removeFile(targetPath)
          status = 'error'
          cb(status, '网络波动，下载文件不全')
        }
      } else {
        stream.end()
        removeFile(targetPath)
        status = 'error'
        cb(status, req.response.statusMessage)
      }
    })
    req.on('error', (e) =&gt; {
      stream.end()
      removeFile(targetPath)
      if (len !== cur) {
        status = 'error'
        cb(status, '网络波动，下载失败')
      } else {
        status = 'error'
        cb(status, e)
      }
    })
  } catch (error) {
    console.log(error)
  }
}

function removeFile(targetPath) {
  try {
    fse.removeSync(targetPath)
  } catch (error) {
    console.log(error)
  }
}

export default async function downloadFile({ url, targetPath, folder = './' }, cb = () =&gt; { }) {  
  log.warn('download-url',url)
  log.warn('download-saveurl',targetPath)
  if (!targetPath || !url) {
    throw new Error('targetPath or url is nofind')
  }
  try {
    await fse.ensureDirSync(path.join(targetPath, folder))
  } catch (error) {
    throw new Error(error)
  }
  return new Promise((resolve, reject) =&gt; {
    const name = url.split('/').pop()
    const filePath = path.join(targetPath, folder, name)
    download(url, filePath, (status, result) =&gt; {
      if (status === 'completed') {
        resolve(filePath)
      }
      if (status === 'error') {
        reject(result)
      }
      if (status === 'progressing') {
        cb &amp;&amp; cb(result)
      }
    })
  })
}
</code></pre>
<h2 id="八-更新流程将下载的appzip解压缩并删除">八、更新流程：将下载的app.zip解压缩并删除</h2>
<p>在electron目录中新建increment.js</p>
<p>解压缩需要一个参数：加压压缩包的路径</p>
<p>在文件下载完成后执行</p>
<p>安装adm-zip</p>
<pre><code>npm i adm-zip
</code></pre>
<pre><code class="language-js">import downloadFile from './downloadFile'
import { app } from 'electron'
const fse = require('fs-extra')
const AdmZip = require('adm-zip')
import log from './log'

export default async (updateZipUrl) =&gt; {  
  const resourcesPath = process.resourcesPath
  downloadFile({ url: updateZipUrl, targetPath: resourcesPath }).then(async (filePath) =&gt; {
    log.warn('unzip-filePath',filePath)
    const zip = new AdmZip(filePath)
    zip.extractAllToAsync(resourcesPath, true, (err) =&gt; {
      if (err) {
        console.error(err)
        return
      }      
      fse.removeSync(filePath)      
      setTimeout(() =&gt; {
        log.warn('relaunch')
        app.relaunch()
        app.exit(0)                
      }, 2000);
    })
  }).catch(err =&gt; {
    console.log(err)
  })
}
</code></pre>
<p>在background.js引入并调用</p>
<pre><code class="language-js">import increment from './electron/increment'
</code></pre>
<pre><code class="language-js">// 热更新
const updateZipUrl = updateUrl + '/app.zip'
increment(updateZipUrl)
</code></pre>
<h2 id="九-更新流程将更新重启替换为重新加载">九、更新流程：将更新重启替换为重新加载</h2>
<p>在electron目录下新建global.js</p>
<pre><code class="language-js">global.sharedObject = {
  win: ''
}

export default global
</code></pre>
<p>在background.js引入并调用</p>
<pre><code>import global from './electron/global'
</code></pre>
<pre><code class="language-js">async function createWindow() {
  require('./electron/menu.js')
  // Create the browser window.
  win = new BrowserWindow({
    width: 800,
    height: 600,
    icon: `${__static}/app.ico`, // app内左上角图标
    webPreferences: {      
      webSecurity: false, //取消跨域限制
      nodeIntegration:true, //开启node
    }
  })

  if (process.env.WEBPACK_DEV_SERVER_URL) {
    // Load the url of the dev server if in development mode
    await win.loadURL(process.env.WEBPACK_DEV_SERVER_URL)
    if (!process.env.IS_TEST) win.webContents.openDevTools()
  } else {
    createProtocol('app')
    // Load the index.html when not in development
    win.loadURL('app://./index.html')

    log.warn('hello')
    // 判断是否热更新，版本对比
    const updateUrl = 'http://ambow-ebopo.oss-cn-beijing.aliyuncs.com/common/electron'
    const currentVersion = app.getVersion()
    log.warn('currentVersion',currentVersion)    
    axios({
      url: updateUrl + '/latest.yml',
      method: 'GET'
    }).then(res =&gt; {      
      const remoteVersion = JSON.stringify(res.data).split('\\n')[0].split(' ')[1]
      log.warn('remoteVersion',remoteVersion)      
      if (currentVersion === remoteVersion) {
        log.warn('版本相同，无需更新')
        return;
      }
      // 热更新
      const updateZipUrl = updateUrl + '/app.zip'
      increment(updateZipUrl)      
    })

  }



  global.sharedObject.win = win
  win.on('closed', () =&gt; {
    win = null
    global.sharedObject.win = null
  })


  
}
</code></pre>
<p>在increment.js中引入并调用</p>
<pre><code class="language-js">import downloadFile from './downloadFile'
import global from './global'
const fse = require('fs-extra')
const AdmZip = require('adm-zip')
import log from './log'

export default async (updateZipUrl) =&gt; {  
  const resourcesPath = process.resourcesPath
  downloadFile({ url: updateZipUrl, targetPath: resourcesPath }).then(async (filePath) =&gt; {
    log.warn('unzip-filePath',filePath)
    const zip = new AdmZip(filePath)
    zip.extractAllToAsync(resourcesPath, true, (err) =&gt; {
      if (err) {
        console.error(err)
        return
      }      
      fse.removeSync(filePath)      
      setTimeout(() =&gt; {        
        log.warn('relaunch')
        global.sharedObject.win.webContents.reloadIgnoringCache()          
      }, 2000);
    })
  }).catch(err =&gt; {
    console.log(err)
  })
}
</code></pre>
<p>setTimeout是为了演示效果，最后去掉。</p>
<h2 id="十-遇到的问题">十、遇到的问题</h2>
<p>更新时报错，如下：</p>
<pre><code>Error: EPERM: operation not permitted
</code></pre>
<p>原因是没有管理员权限，且安装时选择的为所有用户安装。</p>
<p>方案一：运行时选择：以管理员身份运行</p>
<p>方案二：下载时，仅为当前用户安装</p>
<p>解决方案：</p>
<p>在设置上，不给用户选择为所有用户安装的机会，默认一键安装，设置如下</p>
<pre><code class="language-json">&quot;nsis&quot;: {
    &quot;oneClick&quot;: true, // 是否一键安装          
    &quot;installerIcon&quot;: &quot;./public/app.ico&quot;,// 安装图标
    &quot;uninstallerIcon&quot;: &quot;./public/app.ico&quot;,//卸载图标
    &quot;installerHeaderIcon&quot;: &quot;./public/app.ico&quot;, // 安装时头部图标
    &quot;createDesktopShortcut&quot;: true, // 创建桌面图标
    &quot;createStartMenuShortcut&quot;: true,// 创建开始菜单图标
    &quot;shortcutName&quot;: &quot;ebopo&quot;, // 图标名称
},
</code></pre>
<h2 id="十一-在ts项目中使用">十一、在ts项目中使用</h2>
<p>electron-log的使用要用ts文件，并且用any声明，其他相似问题同理。</p>
<p>log.ts</p>
<pre><code class="language-typescript">const log:any = require('electron-log');

log.transports.file.level = 'silly'
log.transports.console.level = false // 禁用console输出

export default log
</code></pre>
<h2 id="github地址">GitHub地址</h2>
<p><a href="https://github.com/lee-css/vue-cli-electron-update-part">vue-cli-electron-update-part</a></p>
<h2 id="参考">参考</h2>
<p><a href="https://xuxin123.com/electron/increment-update1/">https://xuxin123.com/electron/increment-update1/</a></p>
<h2 id="文档">文档</h2>
<p><a href="https://nklayman.github.io/vue-cli-plugin-electron-builder/">https://nklayman.github.io/vue-cli-plugin-electron-builder/</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[http-XMLHttpRequest Level2]]></title>
        <id>https://leecss.com/post/http-xmlhttprequest-level2/</id>
        <link href="https://leecss.com/post/http-xmlhttprequest-level2/">
        </link>
        <updated>2021-07-15T22:49:03.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p><a href="https://en.wikipedia.org/wiki/XMLHttpRequest">XMLHttpRequest</a>是一个浏览器接口，使得Javascript可以进行HTTP(S)通信。</p>
<p>最早，微软在IE 5引进了这个接口。因为它太有用，其他浏览器也模仿部署了，ajax操作因此得以诞生。</p>
<p>但是，这个接口一直没有标准化，每家浏览器的实现或多或少有点不同。HTML 5的概念形成后，W3C开始考虑标准化这个接口。2008年2月，就提出了<a href="https://dev.w3.org/2006/webapi/XMLHttpRequest-2/">XMLHttpRequest Level 2</a> 草案。</p>
<h2 id="一-老版本的xmlhttprequest对象"><strong>一、老版本的XMLHttpRequest对象</strong></h2>
<p>在介绍新版本之前，我们先回顾一下老版本的用法。</p>
<p>首先，新建一个XMLHttpRequest的实例。</p>
<blockquote>
<p>var xhr = new XMLHttpRequest();</p>
</blockquote>
<p>然后，向远程主机发出一个HTTP请求。</p>
<blockquote>
<p>xhr.open('GET', 'example.php');</p>
<p>xhr.send();</p>
</blockquote>
<p>接着，就等待远程主机做出回应。这时需要监控XMLHttpRequest对象的状态变化，指定回调函数。</p>
<blockquote>
<p>xhr.onreadystatechange = function(){</p>
<p>if ( xhr.readyState == 4 &amp;&amp; xhr.status == 200 ) {</p>
<p>alert( xhr.responseText );</p>
<p>} else {</p>
<p>alert( xhr.statusText );</p>
<p>}</p>
<p>};</p>
</blockquote>
<p>上面的代码包含了老版本XMLHttpRequest对象的主要属性：</p>
<blockquote>
<p>* xhr.readyState：XMLHttpRequest对象的状态，等于4表示数据已经接收完毕。</p>
<p>* xhr.status：服务器返回的状态码，等于200表示一切正常。</p>
<p>* xhr.responseText：服务器返回的文本数据</p>
<p>* xhr.responseXML：服务器返回的XML格式的数据</p>
<p>* xhr.statusText：服务器返回的状态文本。</p>
</blockquote>
<h2 id="二-老版本的缺点"><strong>二、老版本的缺点</strong></h2>
<p>老版本的XMLHttpRequest对象有以下几个缺点：</p>
<blockquote>
<p>* 只支持文本数据的传送，无法用来读取和上传二进制文件。</p>
<p>* 传送和接收数据时，没有进度信息，只能提示有没有完成。</p>
<p>* 受到<a href="https://www.w3.org/Security/wiki/Same_Origin_Policy">&quot;同域限制&quot;</a>（Same Origin Policy），只能向同一域名的服务器请求数据。</p>
</blockquote>
<h2 id="三-新版本的功能"><strong>三、新版本的功能</strong></h2>
<p>新版本的XMLHttpRequest对象，针对老版本的缺点，做出了大幅改进。</p>
<blockquote>
<p>* 可以设置HTTP请求的时限。</p>
<p>* 可以使用FormData对象管理表单数据。</p>
<p>* 可以上传文件。</p>
<p>* 可以请求不同域名下的数据（跨域请求）。</p>
<p>* 可以获取服务器端的二进制数据。</p>
<p>* 可以获得数据传输的进度信息。</p>
</blockquote>
<p>下面，我就一一介绍这些新功能。</p>
<h2 id="四-http请求的时限"><strong>四、HTTP请求的时限</strong></h2>
<p>有时，ajax操作很耗时，而且无法预知要花多少时间。如果网速很慢，用户可能要等很久。</p>
<p>新版本的XMLHttpRequest对象，增加了timeout属性，可以设置HTTP请求的时限。</p>
<blockquote>
<p>xhr.timeout = 3000;</p>
</blockquote>
<p>上面的语句，将最长等待时间设为3000毫秒。过了这个时限，就自动停止HTTP请求。与之配套的还有一个timeout事件，用来指定回调函数。</p>
<blockquote>
<p>xhr.ontimeout = function(event){</p>
<p>alert('请求超时！');</p>
<p>}</p>
</blockquote>
<p>目前，Opera、Firefox和IE 10支持该属性，IE 8和IE 9的这个属性属于XDomainRequest对象，而Chrome和Safari还不支持。</p>
<h2 id="五-formdata对象"><strong>五、FormData对象</strong></h2>
<p>ajax操作往往用来传递表单数据。为了方便表单处理，HTML 5新增了一个FormData对象，可以模拟表单。</p>
<p>首先，新建一个FormData对象。</p>
<blockquote>
<p>var formData = new FormData();</p>
</blockquote>
<p>然后，为它添加表单项。</p>
<blockquote>
<p>formData.append('username', '张三');</p>
<p>formData.append('id', 123456);</p>
</blockquote>
<p>最后，直接传送这个FormData对象。这与提交网页表单的效果，完全一样。</p>
<blockquote>
<p>xhr.send(formData);</p>
</blockquote>
<p>FormData对象也可以用来获取网页表单的值。</p>
<blockquote>
<p>var form = document.getElementById('myform');</p>
<p>var formData = new FormData(form);</p>
<p>formData.append('secret', '123456'); // 添加一个表单项</p>
<p>xhr.open('POST', form.action);</p>
<p>xhr.send(formData);</p>
</blockquote>
<h2 id="六-上传文件"><strong>六、上传文件</strong></h2>
<p>新版XMLHttpRequest对象，不仅可以发送文本信息，还可以上传文件。</p>
<p>假定files是一个&quot;选择文件&quot;的表单元素（input[type=&quot;file&quot;]），我们将它装入FormData对象。</p>
<blockquote>
<p>var formData = new FormData();</p>
<p>for (var i = 0; i &lt; files.length;i++) {</p>
<p>formData.append('files[]', files[i]);</p>
<p>}</p>
</blockquote>
<p>然后，发送这个FormData对象。</p>
<blockquote>
<p>xhr.send(formData);</p>
</blockquote>
<h2 id="七-跨域资源共享cors"><strong>七、跨域资源共享（CORS）</strong></h2>
<p>新版本的XMLHttpRequest对象，可以向不同域名的服务器发出HTTP请求。这叫做<a href="https://en.wikipedia.org/wiki/Cross-Origin_Resource_Sharing">&quot;跨域资源共享&quot;</a>（Cross-origin resource sharing，简称CORS）。</p>
<p>使用&quot;跨域资源共享&quot;的前提，是浏览器必须支持这个功能，而且服务器端必须同意这种&quot;跨域&quot;。如果能够满足上面的条件，则代码的写法与不跨域的请求完全一样。</p>
<blockquote>
<p>xhr.open('GET', 'http://other.server/and/path/to/script');</p>
</blockquote>
<p>目前，除了IE 8和IE 9，主流浏览器都支持CORS，IE 10也将支持这个功能。服务器端的设置，请参考<a href="https://developer.mozilla.org/en-US/docs/Server-Side_Access_Control">《Server-Side Access Control》</a>。</p>
<h2 id="八-接收二进制数据方法a改写mimetype"><strong>八、接收二进制数据（方法A：改写MIMEType）</strong></h2>
<p>老版本的XMLHttpRequest对象，只能从服务器取回文本数据（否则它的名字就不用XML起首了），新版则可以取回二进制数据。</p>
<p>这里又分成两种做法。较老的做法是改写数据的MIMEType，将服务器返回的二进制数据伪装成文本数据，并且告诉浏览器这是用户自定义的字符集。</p>
<blockquote>
<p>xhr.overrideMimeType(&quot;text/plain; charset=x-user-defined&quot;);</p>
</blockquote>
<p>然后，用responseText属性接收服务器返回的二进制数据。</p>
<blockquote>
<p>var binStr = xhr.responseText;</p>
</blockquote>
<p>由于这时，浏览器把它当做文本数据，所以还必须再一个个字节地还原成二进制数据。</p>
<blockquote>
<p>for (var i = 0, len = binStr.length; i &lt; len; ++i) {</p>
<p>var c = binStr.charCodeAt(i);</p>
<p>var byte = c &amp; 0xff;</p>
<p>}</p>
</blockquote>
<p>最后一行的位运算&quot;c &amp; 0xff&quot;，表示在每个字符的两个字节之中，只保留后一个字节，将前一个字节扔掉。原因是浏览器解读字符的时候，会把字符自动<a href="https://web.archive.org/web/20080821092906/http://mgran.blogspot.com/2006/08/downloading-binary-streams-with.html">解读</a>成Unicode的0xF700-0xF7ff区段。</p>
<h2 id="八-接收二进制数据方法bresponsetype属性"><strong>八、接收二进制数据（方法B：responseType属性）</strong></h2>
<p>从服务器取回二进制数据，较新的方法是使用新增的responseType属性。如果服务器返回文本数据，这个属性的值是&quot;TEXT&quot;，这是默认值。较新的浏览器还支持其他值，也就是说，可以接收其他格式的数据。</p>
<p>你可以把responseType设为blob，表示服务器传回的是二进制对象。</p>
<blockquote>
<p>var xhr = new XMLHttpRequest();</p>
<p>xhr.open('GET', '/path/to/image.png');</p>
<p>xhr.responseType = 'blob';</p>
</blockquote>
<p>接收数据的时候，用浏览器自带的Blob对象即可。</p>
<blockquote>
<p>var blob = new Blob([xhr.response], {type: 'image/png'});</p>
</blockquote>
<p>注意，是读取xhr.response，而不是xhr.responseText。</p>
<p>你还可以将responseType设为arraybuffer，把二进制数据装在一个数组里。</p>
<blockquote>
<p>var xhr = new XMLHttpRequest();</p>
<p>xhr.open('GET', '/path/to/image.png');</p>
<p>xhr.responseType = &quot;arraybuffer&quot;;</p>
</blockquote>
<p>接收数据的时候，需要遍历这个数组。</p>
<blockquote>
<p>var arrayBuffer = xhr.response;</p>
<p>if (arrayBuffer) {</p>
<p>var byteArray = new Uint8Array(arrayBuffer);</p>
<p>for (var i = 0; i &lt; byteArray.byteLength; i++) {</p>
<p>// do something</p>
<p>}<br>
　　}</p>
</blockquote>
<p>更详细的讨论，请看<a href="https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest/Sending_and_Receiving_Binary_Data">Sending and Receiving Binary Data</a>。</p>
<h2 id="九-进度信息"><strong>九、进度信息</strong></h2>
<p>新版本的XMLHttpRequest对象，传送数据的时候，有一个progress事件，用来返回进度信息。</p>
<p>它分成上传和下载两种情况。下载的progress事件属于XMLHttpRequest对象，上传的progress事件属于XMLHttpRequest.upload对象。</p>
<p>我们先定义progress事件的回调函数。</p>
<blockquote>
<p>xhr.onprogress = updateProgress;</p>
<p>xhr.upload.onprogress = updateProgress;</p>
</blockquote>
<p>然后，在回调函数里面，使用这个事件的一些属性。</p>
<blockquote>
<p>function updateProgress(event) {</p>
<p>if (event.lengthComputable) {</p>
<p>var percentComplete = event.loaded / event.total;</p>
<p>}</p>
<p>}</p>
</blockquote>
<p>上面的代码中，event.total是需要传输的总字节，event.loaded是已经传输的字节。如果event.lengthComputable不为真，则event.total等于0。</p>
<p>与progress事件相关的，还有其他五个事件，可以分别指定回调函数：</p>
<blockquote>
<p>* load事件：传输成功完成。</p>
<p>* abort事件：传输被用户取消。</p>
<p>* error事件：传输中出现错误。</p>
<p>* loadstart事件：传输开始。</p>
<p>* loadEnd事件：传输结束，但是不知道成功还是失败。</p>
</blockquote>
<h2 id="十-阅读材料"><strong>十、阅读材料</strong></h2>
<p>1. <a href="https://dev.opera.com/articles/view/xhr2/">Introduction to XMLHttpRequest Level 2</a>： 新功能的综合介绍。</p>
<p>2. <a href="https://www.html5rocks.com/en/tutorials/file/xhr2/">New Tricks in XMLHttpRequest 2</a>：一些用法的介绍。</p>
<p>3. <a href="https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest/Using_XMLHttpRequest">Using XMLHttpRequest</a>：一些高级用法，主要针对Firefox浏览器。</p>
<p>4. <a href="https://developer.mozilla.org/en-US/docs/HTTP_access_control">HTTP Access Control</a>：CORS综述。</p>
<p>5. <a href="https://dev.opera.com/articles/view/dom-access-control-using-cross-origin-resource-sharing/">DOM access control using cross-origin resource sharing</a>：CORS的9种HTTP头信息</p>
<p>6. <a href="https://developer.mozilla.org/en-US/docs/Server-Side_Access_Control">Server-Side Access Control</a>：服务器端CORS设置。</p>
<p>7. <a href="http://enable-cors.org/">Enable CORS</a>：服务端CORS设置。</p>
<h2 id="转载">转载</h2>
<blockquote>
<p>阮一峰</p>
<p><a href="http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html">http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html</a></p>
</blockquote>
<h2 id="推荐阅读">推荐阅读</h2>
<p><a href="https://www.html5rocks.com/zh/tutorials/file/xhr2/">https://www.html5rocks.com/zh/tutorials/file/xhr2/</a></p>
]]></content>
    </entry>
</feed>