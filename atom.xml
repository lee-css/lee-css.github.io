<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://leecss.com</id>
    <title>当下</title>
    <updated>2021-07-15T23:57:26.447Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://leecss.com"/>
    <link rel="self" href="https://leecss.com/atom.xml"/>
    <logo>https://leecss.com/images/avatar.png</logo>
    <icon>https://leecss.com/favicon.ico</icon>
    <rights>All rights reserved 2021, 当下</rights>
    <entry>
        <title type="html"><![CDATA[http-XMLHttpRequest Level2]]></title>
        <id>https://leecss.com/post/http-xmlhttprequest-level2/</id>
        <link href="https://leecss.com/post/http-xmlhttprequest-level2/">
        </link>
        <updated>2021-07-15T22:49:03.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p><a href="https://en.wikipedia.org/wiki/XMLHttpRequest">XMLHttpRequest</a>是一个浏览器接口，使得Javascript可以进行HTTP(S)通信。</p>
<p>最早，微软在IE 5引进了这个接口。因为它太有用，其他浏览器也模仿部署了，ajax操作因此得以诞生。</p>
<p>但是，这个接口一直没有标准化，每家浏览器的实现或多或少有点不同。HTML 5的概念形成后，W3C开始考虑标准化这个接口。2008年2月，就提出了<a href="https://dev.w3.org/2006/webapi/XMLHttpRequest-2/">XMLHttpRequest Level 2</a> 草案。</p>
<h2 id="一-老版本的xmlhttprequest对象"><strong>一、老版本的XMLHttpRequest对象</strong></h2>
<p>在介绍新版本之前，我们先回顾一下老版本的用法。</p>
<p>首先，新建一个XMLHttpRequest的实例。</p>
<blockquote>
<p>var xhr = new XMLHttpRequest();</p>
</blockquote>
<p>然后，向远程主机发出一个HTTP请求。</p>
<blockquote>
<p>xhr.open('GET', 'example.php');</p>
<p>xhr.send();</p>
</blockquote>
<p>接着，就等待远程主机做出回应。这时需要监控XMLHttpRequest对象的状态变化，指定回调函数。</p>
<blockquote>
<p>xhr.onreadystatechange = function(){</p>
<p>if ( xhr.readyState == 4 &amp;&amp; xhr.status == 200 ) {</p>
<p>alert( xhr.responseText );</p>
<p>} else {</p>
<p>alert( xhr.statusText );</p>
<p>}</p>
<p>};</p>
</blockquote>
<p>上面的代码包含了老版本XMLHttpRequest对象的主要属性：</p>
<blockquote>
<p>* xhr.readyState：XMLHttpRequest对象的状态，等于4表示数据已经接收完毕。</p>
<p>* xhr.status：服务器返回的状态码，等于200表示一切正常。</p>
<p>* xhr.responseText：服务器返回的文本数据</p>
<p>* xhr.responseXML：服务器返回的XML格式的数据</p>
<p>* xhr.statusText：服务器返回的状态文本。</p>
</blockquote>
<h2 id="二-老版本的缺点"><strong>二、老版本的缺点</strong></h2>
<p>老版本的XMLHttpRequest对象有以下几个缺点：</p>
<blockquote>
<p>* 只支持文本数据的传送，无法用来读取和上传二进制文件。</p>
<p>* 传送和接收数据时，没有进度信息，只能提示有没有完成。</p>
<p>* 受到<a href="https://www.w3.org/Security/wiki/Same_Origin_Policy">&quot;同域限制&quot;</a>（Same Origin Policy），只能向同一域名的服务器请求数据。</p>
</blockquote>
<h2 id="三-新版本的功能"><strong>三、新版本的功能</strong></h2>
<p>新版本的XMLHttpRequest对象，针对老版本的缺点，做出了大幅改进。</p>
<blockquote>
<p>* 可以设置HTTP请求的时限。</p>
<p>* 可以使用FormData对象管理表单数据。</p>
<p>* 可以上传文件。</p>
<p>* 可以请求不同域名下的数据（跨域请求）。</p>
<p>* 可以获取服务器端的二进制数据。</p>
<p>* 可以获得数据传输的进度信息。</p>
</blockquote>
<p>下面，我就一一介绍这些新功能。</p>
<h2 id="四-http请求的时限"><strong>四、HTTP请求的时限</strong></h2>
<p>有时，ajax操作很耗时，而且无法预知要花多少时间。如果网速很慢，用户可能要等很久。</p>
<p>新版本的XMLHttpRequest对象，增加了timeout属性，可以设置HTTP请求的时限。</p>
<blockquote>
<p>xhr.timeout = 3000;</p>
</blockquote>
<p>上面的语句，将最长等待时间设为3000毫秒。过了这个时限，就自动停止HTTP请求。与之配套的还有一个timeout事件，用来指定回调函数。</p>
<blockquote>
<p>xhr.ontimeout = function(event){</p>
<p>alert('请求超时！');</p>
<p>}</p>
</blockquote>
<p>目前，Opera、Firefox和IE 10支持该属性，IE 8和IE 9的这个属性属于XDomainRequest对象，而Chrome和Safari还不支持。</p>
<h2 id="五-formdata对象"><strong>五、FormData对象</strong></h2>
<p>ajax操作往往用来传递表单数据。为了方便表单处理，HTML 5新增了一个FormData对象，可以模拟表单。</p>
<p>首先，新建一个FormData对象。</p>
<blockquote>
<p>var formData = new FormData();</p>
</blockquote>
<p>然后，为它添加表单项。</p>
<blockquote>
<p>formData.append('username', '张三');</p>
<p>formData.append('id', 123456);</p>
</blockquote>
<p>最后，直接传送这个FormData对象。这与提交网页表单的效果，完全一样。</p>
<blockquote>
<p>xhr.send(formData);</p>
</blockquote>
<p>FormData对象也可以用来获取网页表单的值。</p>
<blockquote>
<p>var form = document.getElementById('myform');</p>
<p>var formData = new FormData(form);</p>
<p>formData.append('secret', '123456'); // 添加一个表单项</p>
<p>xhr.open('POST', form.action);</p>
<p>xhr.send(formData);</p>
</blockquote>
<h2 id="六-上传文件"><strong>六、上传文件</strong></h2>
<p>新版XMLHttpRequest对象，不仅可以发送文本信息，还可以上传文件。</p>
<p>假定files是一个&quot;选择文件&quot;的表单元素（input[type=&quot;file&quot;]），我们将它装入FormData对象。</p>
<blockquote>
<p>var formData = new FormData();</p>
<p>for (var i = 0; i &lt; files.length;i++) {</p>
<p>formData.append('files[]', files[i]);</p>
<p>}</p>
</blockquote>
<p>然后，发送这个FormData对象。</p>
<blockquote>
<p>xhr.send(formData);</p>
</blockquote>
<h2 id="七-跨域资源共享cors"><strong>七、跨域资源共享（CORS）</strong></h2>
<p>新版本的XMLHttpRequest对象，可以向不同域名的服务器发出HTTP请求。这叫做<a href="https://en.wikipedia.org/wiki/Cross-Origin_Resource_Sharing">&quot;跨域资源共享&quot;</a>（Cross-origin resource sharing，简称CORS）。</p>
<p>使用&quot;跨域资源共享&quot;的前提，是浏览器必须支持这个功能，而且服务器端必须同意这种&quot;跨域&quot;。如果能够满足上面的条件，则代码的写法与不跨域的请求完全一样。</p>
<blockquote>
<p>xhr.open('GET', 'http://other.server/and/path/to/script');</p>
</blockquote>
<p>目前，除了IE 8和IE 9，主流浏览器都支持CORS，IE 10也将支持这个功能。服务器端的设置，请参考<a href="https://developer.mozilla.org/en-US/docs/Server-Side_Access_Control">《Server-Side Access Control》</a>。</p>
<h2 id="八-接收二进制数据方法a改写mimetype"><strong>八、接收二进制数据（方法A：改写MIMEType）</strong></h2>
<p>老版本的XMLHttpRequest对象，只能从服务器取回文本数据（否则它的名字就不用XML起首了），新版则可以取回二进制数据。</p>
<p>这里又分成两种做法。较老的做法是改写数据的MIMEType，将服务器返回的二进制数据伪装成文本数据，并且告诉浏览器这是用户自定义的字符集。</p>
<blockquote>
<p>xhr.overrideMimeType(&quot;text/plain; charset=x-user-defined&quot;);</p>
</blockquote>
<p>然后，用responseText属性接收服务器返回的二进制数据。</p>
<blockquote>
<p>var binStr = xhr.responseText;</p>
</blockquote>
<p>由于这时，浏览器把它当做文本数据，所以还必须再一个个字节地还原成二进制数据。</p>
<blockquote>
<p>for (var i = 0, len = binStr.length; i &lt; len; ++i) {</p>
<p>var c = binStr.charCodeAt(i);</p>
<p>var byte = c &amp; 0xff;</p>
<p>}</p>
</blockquote>
<p>最后一行的位运算&quot;c &amp; 0xff&quot;，表示在每个字符的两个字节之中，只保留后一个字节，将前一个字节扔掉。原因是浏览器解读字符的时候，会把字符自动<a href="https://web.archive.org/web/20080821092906/http://mgran.blogspot.com/2006/08/downloading-binary-streams-with.html">解读</a>成Unicode的0xF700-0xF7ff区段。</p>
<h2 id="八-接收二进制数据方法bresponsetype属性"><strong>八、接收二进制数据（方法B：responseType属性）</strong></h2>
<p>从服务器取回二进制数据，较新的方法是使用新增的responseType属性。如果服务器返回文本数据，这个属性的值是&quot;TEXT&quot;，这是默认值。较新的浏览器还支持其他值，也就是说，可以接收其他格式的数据。</p>
<p>你可以把responseType设为blob，表示服务器传回的是二进制对象。</p>
<blockquote>
<p>var xhr = new XMLHttpRequest();</p>
<p>xhr.open('GET', '/path/to/image.png');</p>
<p>xhr.responseType = 'blob';</p>
</blockquote>
<p>接收数据的时候，用浏览器自带的Blob对象即可。</p>
<blockquote>
<p>var blob = new Blob([xhr.response], {type: 'image/png'});</p>
</blockquote>
<p>注意，是读取xhr.response，而不是xhr.responseText。</p>
<p>你还可以将responseType设为arraybuffer，把二进制数据装在一个数组里。</p>
<blockquote>
<p>var xhr = new XMLHttpRequest();</p>
<p>xhr.open('GET', '/path/to/image.png');</p>
<p>xhr.responseType = &quot;arraybuffer&quot;;</p>
</blockquote>
<p>接收数据的时候，需要遍历这个数组。</p>
<blockquote>
<p>var arrayBuffer = xhr.response;</p>
<p>if (arrayBuffer) {</p>
<p>var byteArray = new Uint8Array(arrayBuffer);</p>
<p>for (var i = 0; i &lt; byteArray.byteLength; i++) {</p>
<p>// do something</p>
<p>}<br>
　　}</p>
</blockquote>
<p>更详细的讨论，请看<a href="https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest/Sending_and_Receiving_Binary_Data">Sending and Receiving Binary Data</a>。</p>
<h2 id="九-进度信息"><strong>九、进度信息</strong></h2>
<p>新版本的XMLHttpRequest对象，传送数据的时候，有一个progress事件，用来返回进度信息。</p>
<p>它分成上传和下载两种情况。下载的progress事件属于XMLHttpRequest对象，上传的progress事件属于XMLHttpRequest.upload对象。</p>
<p>我们先定义progress事件的回调函数。</p>
<blockquote>
<p>xhr.onprogress = updateProgress;</p>
<p>xhr.upload.onprogress = updateProgress;</p>
</blockquote>
<p>然后，在回调函数里面，使用这个事件的一些属性。</p>
<blockquote>
<p>function updateProgress(event) {</p>
<p>if (event.lengthComputable) {</p>
<p>var percentComplete = event.loaded / event.total;</p>
<p>}</p>
<p>}</p>
</blockquote>
<p>上面的代码中，event.total是需要传输的总字节，event.loaded是已经传输的字节。如果event.lengthComputable不为真，则event.total等于0。</p>
<p>与progress事件相关的，还有其他五个事件，可以分别指定回调函数：</p>
<blockquote>
<p>* load事件：传输成功完成。</p>
<p>* abort事件：传输被用户取消。</p>
<p>* error事件：传输中出现错误。</p>
<p>* loadstart事件：传输开始。</p>
<p>* loadEnd事件：传输结束，但是不知道成功还是失败。</p>
</blockquote>
<h2 id="十-阅读材料"><strong>十、阅读材料</strong></h2>
<p>1. <a href="https://dev.opera.com/articles/view/xhr2/">Introduction to XMLHttpRequest Level 2</a>： 新功能的综合介绍。</p>
<p>2. <a href="https://www.html5rocks.com/en/tutorials/file/xhr2/">New Tricks in XMLHttpRequest 2</a>：一些用法的介绍。</p>
<p>3. <a href="https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest/Using_XMLHttpRequest">Using XMLHttpRequest</a>：一些高级用法，主要针对Firefox浏览器。</p>
<p>4. <a href="https://developer.mozilla.org/en-US/docs/HTTP_access_control">HTTP Access Control</a>：CORS综述。</p>
<p>5. <a href="https://dev.opera.com/articles/view/dom-access-control-using-cross-origin-resource-sharing/">DOM access control using cross-origin resource sharing</a>：CORS的9种HTTP头信息</p>
<p>6. <a href="https://developer.mozilla.org/en-US/docs/Server-Side_Access_Control">Server-Side Access Control</a>：服务器端CORS设置。</p>
<p>7. <a href="http://enable-cors.org/">Enable CORS</a>：服务端CORS设置。</p>
<h2 id="转载">转载</h2>
<blockquote>
<p>阮一峰</p>
<p><a href="http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html">http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html</a></p>
</blockquote>
<h2 id="推荐阅读">推荐阅读</h2>
<p><a href="https://www.html5rocks.com/zh/tutorials/file/xhr2/">https://www.html5rocks.com/zh/tutorials/file/xhr2/</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[http-XMLHttpRequest]]></title>
        <id>https://leecss.com/post/http-xmlhttprequest/</id>
        <link href="https://leecss.com/post/http-xmlhttprequest/">
        </link>
        <updated>2021-07-15T14:49:23.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>XMLHttpRequest详解</p>
<h2 id="ajax和xmlhttprequest"><code>Ajax</code>和<code>XMLHttpRequest</code></h2>
<p>我们通常将<code>Ajax</code>等同于<code>XMLHttpRequest</code>，但细究起来它们两个是属于不同维度的2个概念。</p>
<blockquote>
<p>以下是我认为对<code>Ajax</code>较为准确的解释：（摘自<a href="https://link.segmentfault.com/?url=http%3A%2F%2Fwww.tutorialspoint.com%2Fajax%2Fwhat_is_ajax.htm">what is Ajax</a>）<br>
AJAX stands for Asynchronous JavaScript and XML. AJAX is a new technique for creating better, faster, and more interactive web applications with the help of XML, HTML, CSS, and Java Script.</p>
<p>AJAX is based on the following open standards:</p>
<ul>
<li>Browser-based presentation using HTML and Cascading Style Sheets (CSS).</li>
<li>Data is stored in XML format and fetched from the server.</li>
<li>Behind-the-scenes data fetches using XMLHttpRequest objects in the browser.</li>
<li>JavaScript to make everything happen.</li>
</ul>
</blockquote>
<p>从上面的解释中可以知道：<code>ajax</code>是一种技术方案，但并不是一种<strong>新技术</strong>。它依赖的是现有的<code>CSS</code>/<code>HTML</code>/<code>Javascript</code>，而其中最核心的依赖是浏览器提供的<code>XMLHttpRequest</code>对象，是这个对象使得浏览器可以发出<code>HTTP</code>请求与接收<code>HTTP</code>响应。</p>
<p>所以我用一句话来总结两者的关系：我们使用<code>XMLHttpRequest</code>对象来发送一个<code>Ajax</code>请求。</p>
<h2 id="xmlhttprequest的发展历程"><code>XMLHttpRequest</code>的发展历程</h2>
<p><code>XMLHttpRequest</code>一开始只是微软浏览器提供的一个接口，后来各大浏览器纷纷效仿也提供了这个接口，再后来W3C对它进行了标准化，提出了<a href="https://link.segmentfault.com/?url=https%3A%2F%2Fwww.w3.org%2FTR%2FXMLHttpRequest%2F"><code>XMLHttpRequest</code>标准</a>。<code>XMLHttpRequest</code>标准又分为<code>Level 1</code>和<code>Level 2</code>。<br>
<code>XMLHttpRequest Level 1</code>主要存在以下缺点：</p>
<ul>
<li>受同源策略的限制，不能发送跨域请求；</li>
<li>不能发送二进制文件（如图片、视频、音频等），只能发送纯文本数据；</li>
<li>在发送和获取数据的过程中，无法实时获取进度信息，只能判断是否完成；</li>
</ul>
<p>那么<code>Level 2</code>对<code>Level 1</code> 进行了改进，<code>XMLHttpRequest Level 2</code>中新增了以下功能：</p>
<ul>
<li>可以发送跨域请求，在服务端允许的情况下；</li>
<li>支持发送和接收二进制数据；</li>
<li>新增formData对象，支持发送表单数据；</li>
<li>发送和获取数据时，可以获取进度信息；</li>
<li>可以设置请求的超时时间；</li>
</ul>
<h2 id="xmlhttprequest兼容性"><code>XMLHttpRequest</code>兼容性</h2>
<p>关于<code>xhr</code>的浏览器兼容性，大家可以直接查看“Can I use”这个网站提供的结果<a href="https://link.segmentfault.com/?url=http%3A%2F%2Fcaniuse.com%2F%23search%3DXMLHttpRequest">XMLHttpRequest兼容性</a>，下面提供一个截图。</p>
<figure data-type="image" tabindex="1"><img src="https://leecss.com/post-images/1626360606163.png" alt="" loading="lazy"></figure>
<p>从图中可以看到：</p>
<ul>
<li>IE8/IE9、Opera Mini 完全不支持<code>xhr</code>对象</li>
<li>IE10/IE11部分支持，不支持 <code>xhr.responseType</code>为<code>json</code></li>
<li>部分浏览器不支持设置请求超时，即无法使用<code>xhr.timeout</code></li>
<li>部分浏览器不支持<code>xhr.responseType</code>为<code>blob</code></li>
</ul>
<h2 id="细说xmlhttprequest如何使用">细说<code>XMLHttpRequest</code>如何使用</h2>
<p>先来看一段使用<code>XMLHttpRequest</code>发送<code>Ajax</code>请求的简单示例代码。</p>
<pre><code class="language-js">function sendAjax() {
  //构造表单数据
  var formData = new FormData();
  formData.append('username', 'johndoe');
  formData.append('id', 123456);
  //创建xhr对象 
  var xhr = new XMLHttpRequest();
  //设置xhr请求的超时时间
  xhr.timeout = 3000;
  //设置响应返回的数据格式
  xhr.responseType = &quot;text&quot;;
  //创建一个 post 请求，采用异步
  xhr.open('POST', '/server', true);
  //注册相关事件回调处理函数
  xhr.onload = function(e) { 
    if(this.status == 200||this.status == 304){
        alert(this.responseText);
    }
  };
  xhr.ontimeout = function(e) { ... };
  xhr.onerror = function(e) { ... };
  xhr.upload.onprogress = function(e) { ... };
  
  //发送数据
  xhr.send(formData);
}
</code></pre>
<p>上面是一个使用<code>xhr</code>发送表单数据的示例，整个流程可以参考注释。</p>
<p>接下来我将站在使用者的角度，以问题的形式介绍<code>xhr</code>的基本使用。<br>
我对每一个问题涉及到的知识点都会进行比较细致地介绍，有些知识点可能是你平时忽略关注的。</p>
<h3 id="如何设置request-header">如何设置request header</h3>
<p>在发送<code>Ajax</code>请求（实质是一个<a href="https://link.segmentfault.com/?url=http%3A%2F%2Fwww.tutorialspoint.com%2Fhttp%2Fhttp_header_fields.htm">HTTP</a>请求）时，我们可能需要设置一些请求头部信息，比如<code>content-type</code>、<code>connection</code>、<code>cookie</code>、<code>accept-xxx</code>等。<code>xhr</code>提供了<code>setRequestHeader</code>来允许我们修改请求 header。</p>
<blockquote>
<pre><code>void setRequestHeader(DOMString header, DOMString value);
</code></pre>
</blockquote>
<p><strong>注意点</strong>：</p>
<ul>
<li>方法的第一个参数 header 大小写不敏感，即可以写成<code>content-type</code>，也可以写成<code>Content-Type</code>，甚至写成<code>content-Type</code>;</li>
<li><code>Content-Type</code>的默认值与具体发送的数据类型有关，请参考本文【可以发送什么类型的数据】一节；</li>
<li><code>setRequestHeader</code>必须在<code>open()</code>方法之后，<code>send()</code>方法之前调用，否则会抛错；</li>
<li><code>setRequestHeader</code>可以调用多次，最终的值不会采用覆盖<code>override</code>的方式，而是采用追加<code>append</code>的方式。下面是一个示例代码：</li>
</ul>
<pre><code class="language-js">var client = new XMLHttpRequest();
client.open('GET', 'demo.cgi');
client.setRequestHeader('X-Test', 'one');
client.setRequestHeader('X-Test', 'two');
// 最终request header中&quot;X-Test&quot;为: one, two
client.send();
</code></pre>
<h3 id="如何获取response-header">如何获取response header</h3>
<p><code>xhr</code>提供了2个用来获取响应头部的方法：<code>getAllResponseHeaders</code>和<code>getResponseHeader</code>。前者是获取 response 中的所有header 字段，后者只是获取某个指定 header 字段的值。另外，<code>getResponseHeader(header)</code>的<code>header</code>参数不区分大小写。</p>
<blockquote>
<pre><code>DOMString getAllResponseHeaders();`
`DOMString getResponseHeader(DOMString header);
</code></pre>
</blockquote>
<p><em>这2个方法看起来简单，但却处处是坑儿。</em></p>
<p>你是否遇到过下面的坑儿?——反正我是遇到了。。。</p>
<ol>
<li>使用<code>getAllResponseHeaders()</code>看到的所有<code>response header</code>与实际在控制台 <code>Network</code> 中看到的 <code>response header</code> 不一样</li>
<li>使用<code>getResponseHeader()</code>获取某个 <code>header</code> 的值时，浏览器抛错<code>Refused to get unsafe header &quot;XXX&quot;</code></li>
</ol>
<p>经过一番寻找最终在 <a href="https://link.segmentfault.com/?url=http%3A%2F%2Fstackoverflow.com%2Fquestions%2F7462968%2Frestrictions-of-xmlhttprequests-getresponseheader">Stack Overflow找到了答案</a>。</p>
<ul>
<li>原因1：<a href="https://link.segmentfault.com/?url=https%3A%2F%2Fwww.w3.org%2FTR%2FXMLHttpRequest%2F">W3C的 xhr 标准中做了限制</a>，规定客户端无法获取 response 中的 <code>Set-Cookie</code>、<code>Set-Cookie2</code>这2个字段，无论是同域还是跨域请求；</li>
<li>原因2：<a href="https://link.segmentfault.com/?url=https%3A%2F%2Fwww.w3.org%2FTR%2Fcors%2F%23access-control-allow-credentials-response-header">W3C 的 cors 标准对于跨域请求也做了限制</a>，规定对于跨域请求，客户端允许获取的response header字段只限于“<code>simple response header</code>”和“<code>Access-Control-Expose-Headers</code>” （两个名词的解释见下方）。</li>
</ul>
<blockquote>
<p>&quot;<code>simple response header</code>&quot;包括的 header 字段有：<code>Cache-Control</code>,<code>Content-Language</code>,<code>Content-Type</code>,<code>Expires</code>,<code>Last-Modified</code>,<code>Pragma</code>;<br>
&quot;<code>Access-Control-Expose-Headers</code>&quot;：首先得注意是&quot;<code>Access-Control-Expose-Headers</code>&quot;进行<strong>跨域请求</strong>时响应头部中的一个字段，对于同域请求，响应头部是没有这个字段的。这个字段中列举的 header 字段就是服务器允许暴露给客户端访问的字段。</p>
</blockquote>
<p>所以<code>getAllResponseHeaders()</code>只能拿到*<strong>限制以外*</strong>（即被视为<code>safe</code>）的header字段，而不是全部字段；而调用<code>getResponseHeader(header)</code>方法时，<code>header</code>参数必须是***限制以外***的header字段，否则调用就会报<code>Refused to get unsafe header</code>的错误。</p>
<h3 id="如何指定xhrresponse的数据类型">如何指定<code>xhr.response</code>的数据类型</h3>
<p>有些时候我们希望<code>xhr.response</code>返回的就是我们想要的数据类型。比如：响应返回的数据是纯JSON字符串，但我们期望最终通过<code>xhr.response</code>拿到的直接就是一个 js 对象，我们该怎么实现呢？<br>
有2种方法可以实现，一个是<code>level 1</code>就提供的<code>overrideMimeType()</code>方法，另一个是<code>level 2</code>才提供的<code>xhr.responseType</code>属性。</p>
<h4 id="xhroverridemimetype"><code>xhr.overrideMimeType()</code></h4>
<p><code>overrideMimeType</code>是<code>xhr level 1</code>就有的方法，所以浏览器兼容性良好。这个方法的作用就是用来重写<code>response</code>的<code>content-type</code>，这样做有什么意义呢？比如：server 端给客户端返回了一份<code>document</code>或者是 <code>xml</code>文档，我们希望最终通过<code>xhr.response</code>拿到的就是一个<code>DOM</code>对象，那么就可以用<code>xhr.overrideMimeType('text/xml; charset = utf-8')</code>来实现。</p>
<p>再举一个使用场景，我们都知道<code>xhr level 1</code>不支持直接传输blob二进制数据，那如果真要传输 blob 该怎么办呢？当时就是利用<code>overrideMimeType</code>方法来解决这个问题的。</p>
<p>下面是一个获取图片文件的代码示例：</p>
<pre><code class="language-js">var xhr = new XMLHttpRequest();
//向 server 端获取一张图片
xhr.open('GET', '/path/to/image.png', true);

// 这行是关键！
//将响应数据按照纯文本格式来解析，字符集替换为用户自己定义的字符集
xhr.overrideMimeType('text/plain; charset=x-user-defined');

xhr.onreadystatechange = function(e) {
  if (this.readyState == 4 &amp;&amp; this.status == 200) {
    //通过 responseText 来获取图片文件对应的二进制字符串
    var binStr = this.responseText;
    //然后自己再想方法将逐个字节还原为二进制数据
    for (var i = 0, len = binStr.length; i &lt; len; ++i) {
      var c = binStr.charCodeAt(i);
      //String.fromCharCode(c &amp; 0xff);
      var byte = c &amp; 0xff; 
    }
  }
};

xhr.send();
</code></pre>
<p>代码示例中<code>xhr</code>请求的是一张图片，通过将 <code>response</code> 的 <code>content-type</code> 改为'text/plain; charset=x-user-defined'，使得 <code>xhr</code> 以纯文本格式来解析接收到的blob 数据，最终用户通过<code>this.responseText</code>拿到的就是图片文件对应的二进制字符串，最后再将其转换为 blob 数据。</p>
<h4 id="xhrresponsetype"><code>xhr.responseType</code></h4>
<p><code>responseType</code>是<code>xhr level 2</code>新增的属性，用来指定<code>xhr.response</code>的数据类型，目前还存在些兼容性问题，可以参考本文的【<code>XMLHttpRequest</code>的兼容性】这一小节。那么<code>responseType</code>可以设置为哪些格式呢，我简单做了一个表，如下：</p>
<table>
<thead>
<tr>
<th>值</th>
<th><code>xhr.response</code> 数据类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&quot;&quot;</code></td>
<td><code>String</code>字符串</td>
<td>默认值(在不设置<code>responseType</code>时)</td>
</tr>
<tr>
<td><code>&quot;text&quot;</code></td>
<td><code>String</code>字符串</td>
<td></td>
</tr>
<tr>
<td><code>&quot;document&quot;</code></td>
<td><code>Document</code>对象</td>
<td>希望返回 <code>XML</code> 格式数据时使用</td>
</tr>
<tr>
<td><code>&quot;json&quot;</code></td>
<td><code>javascript</code> 对象</td>
<td>存在兼容性问题，IE10/IE11不支持</td>
</tr>
<tr>
<td><code>&quot;blob&quot;</code></td>
<td><code>Blob</code>对象</td>
<td></td>
</tr>
<tr>
<td><code>&quot;arrayBuffer&quot;</code></td>
<td><code>ArrayBuffer</code>对象</td>
<td></td>
</tr>
</tbody>
</table>
<p>下面是同样是获取一张图片的代码示例，相比<code>xhr.overrideMimeType</code>,用<code>xhr.response</code>来实现简单得多。</p>
<pre><code class="language-js">var xhr = new XMLHttpRequest();
xhr.open('GET', '/path/to/image.png', true);
//可以将`xhr.responseType`设置为`&quot;blob&quot;`也可以设置为`&quot; arrayBuffer&quot;`
//xhr.responseType = 'arrayBuffer';
xhr.responseType = 'blob';

xhr.onload = function(e) {
  if (this.status == 200) {
    var blob = this.response;
    ...
  }
};

xhr.send();
</code></pre>
<h4 id="小结">小结</h4>
<p>虽然在<code>xhr level 2</code>中，2者是共同存在的。但其实不难发现，<code>xhr.responseType</code>就是用来取代<code>xhr.overrideMimeType()</code>的，<code>xhr.responseType</code>功能强大的多，<code>xhr.overrideMimeType()</code>能做到的<code>xhr.responseType</code>都能做到。所以我们现在完全可以摒弃使用<code>xhr.overrideMimeType()</code>了。</p>
<h3 id="如何获取response数据">如何获取response数据</h3>
<pre><code>xhr`提供了3个属性来获取请求返回的数据，分别是：`xhr.response`、`xhr.responseText`、`xhr.responseXML
</code></pre>
<ul>
<li><code>xhr.response</code>
<ul>
<li>默认值：空字符串<code>&quot;&quot;</code></li>
<li>当请求完成时，此属性才有正确的值</li>
<li>请求未完成时，此属性的值可能是<code>&quot;&quot;</code>或者 <code>null</code>，具体与 <code>xhr.responseType</code>有关：当<code>responseType</code>为<code>&quot;&quot;</code>或<code>&quot;text&quot;</code>时，值为<code>&quot;&quot;</code>；<code>responseType</code>为其他值时，值为 <code>null</code></li>
</ul>
</li>
<li><code>xhr.responseText</code>
<ul>
<li>默认值为空字符串<code>&quot;&quot;</code></li>
<li>只有当 <code>responseType</code> 为<code>&quot;text&quot;</code>、<code>&quot;&quot;</code>时，<code>xhr</code>对象上才有此属性，此时才能调用<code>xhr.responseText</code>，否则抛错</li>
<li>只有当请求成功时，才能拿到正确值。以下2种情况下值都为空字符串<code>&quot;&quot;</code>：请求未完成、请求失败</li>
</ul>
</li>
<li><code>xhr.responseXML</code>
<ul>
<li>默认值为 <code>null</code></li>
<li>只有当 <code>responseType</code> 为<code>&quot;text&quot;</code>、<code>&quot;&quot;</code>、<code>&quot;document&quot;</code>时，<code>xhr</code>对象上才有此属性，此时才能调用<code>xhr.responseXML</code>，否则抛错</li>
<li>只有当请求成功且返回数据被正确解析时，才能拿到正确值。以下3种情况下值都为<code>null</code>：请求未完成、请求失败、请求成功但返回数据无法被正确解析时</li>
</ul>
</li>
</ul>
<h3 id="如何追踪ajax请求的当前状态">如何追踪<code>ajax</code>请求的当前状态</h3>
<p>在发一个<code>ajax</code>请求后，如果想追踪请求当前处于哪种状态，该怎么做呢？</p>
<p>用<code>xhr.readyState</code>这个属性即可追踪到。这个属性是只读属性，总共有5种可能值，分别对应<code>xhr</code>不同的不同阶段。每次<code>xhr.readyState</code>的值发生变化时，都会触发<code>xhr.onreadystatechange</code>事件，我们可以在这个事件中进行相关状态判断。</p>
<pre><code class="language-js">  xhr.onreadystatechange = function () {
    switch(xhr.readyState){
      case 1://OPENED
        //do something
            break;
      case 2://HEADERS_RECEIVED
        //do something
        break;
      case 3://LOADING
        //do something
        break;
      case 4://DONE
        //do something
        break;
    }
</code></pre>
<table>
<thead>
<tr>
<th>值</th>
<th>状态</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0</code></td>
<td><code>UNSENT</code> (初始状态，未打开)</td>
<td>此时<code>xhr</code>对象被成功构造，<code>open()</code>方法还未被调用</td>
</tr>
<tr>
<td><code>1</code></td>
<td><code>OPENED</code> (已打开，未发送)</td>
<td><code>open()</code>方法已被成功调用，<code>send()</code>方法还未被调用。注意：只有<code>xhr</code>处于<code>OPENED</code>状态，才能调用<code>xhr.setRequestHeader()</code>和<code>xhr.send()</code>,否则会报错</td>
</tr>
<tr>
<td><code>2</code></td>
<td><code>HEADERS_RECEIVED</code> (已获取响应头)</td>
<td><code>send()</code>方法已经被调用, 响应头和响应状态已经返回</td>
</tr>
<tr>
<td><code>3</code></td>
<td><code>LOADING</code> (正在下载响应体)</td>
<td>响应体(<code>response entity body</code>)正在下载中，此状态下通过<code>xhr.response</code>可能已经有了响应数据</td>
</tr>
<tr>
<td><code>4</code></td>
<td><code>DONE</code> (整个数据传输过程结束)</td>
<td>整个数据传输过程结束，不管本次请求是成功还是失败</td>
</tr>
</tbody>
</table>
<h3 id="如何设置请求的超时时间">如何设置请求的超时时间</h3>
<p>如果请求过了很久还没有成功，为了不会白白占用的网络资源，我们一般会主动终止请求。<code>XMLHttpRequest</code>提供了<code>timeout</code>属性来允许设置请求的超时时间。</p>
<blockquote>
<pre><code>xhr.timeout
</code></pre>
</blockquote>
<p>单位：milliseconds 毫秒<br>
默认值：<code>0</code>，即不设置超时</p>
<p>很多同学都知道：从*<strong>请求开始*</strong> 算起，若超过 <code>timeout</code> 时间请求还没有结束（包括成功/失败），则会触发ontimeout事件，主动结束该请求。</p>
<p>【那么到底什么时候才算是*<strong>请求开始*</strong> ？】<br>
——<code>xhr.onloadstart</code>事件触发的时候，也就是你调用<code>xhr.send()</code>方法的时候。<br>
因为<code>xhr.open()</code>只是创建了一个连接，但并没有真正开始数据的传输，而<code>xhr.send()</code>才是真正开始了数据的传输过程。只有调用了<code>xhr.send()</code>，才会触发<code>xhr.onloadstart</code> 。</p>
<p>【那么什么时候才算是*<strong>请求结束*</strong> ？】<br>
—— <code>xhr.loadend</code>事件触发的时候。</p>
<p>另外，还有2个需要注意的坑儿：</p>
<ol>
<li>可以在 <code>send()</code>之后再设置此<code>xhr.timeout</code>，但计时起始点仍为调用<code>xhr.send()</code>方法的时刻。</li>
<li>当<code>xhr</code>为一个<code>sync</code>同步请求时，<code>xhr.timeout</code>必须置为<code>0</code>，否则会抛错。原因可以参考本文的【如何发一个同步请求】一节。</li>
</ol>
<h3 id="如何发一个同步请求">如何发一个同步请求</h3>
<p><code>xhr</code>默认发的是异步请求，但也支持发同步请求（当然实际开发中应该尽量避免使用）。到底是异步还是同步请求，由<code>xhr.open（）</code>传入的<code>async</code>参数决定。</p>
<blockquote>
<pre><code>open(method, url [, async = true [, username = null [, password = null]]])
</code></pre>
</blockquote>
<ul>
<li><code>method</code>: 请求的方式，如<code>GET/POST/HEADER</code>等，这个参数不区分大小写</li>
<li><code>url</code>: 请求的地址，可以是相对地址如<code>example.php</code>，这个<strong>相对</strong>是相对于当前网页的<code>url</code>路径；也可以是绝对地址如<code>http://www.example.com/example.php</code></li>
<li><code>async</code>: 默认值为<code>true</code>，即为异步请求，若<code>async=false</code>，则为同步请求</li>
</ul>
<p>在我认真研读W3C 的 xhr 标准前，我总以为同步请求和异步请求只是阻塞和非阻塞的区别，其他什么事件触发、参数设置应该是一样的，事实证明我错了。</p>
<p>W3C 的 xhr标准中关于<code>open()</code>方法有这样一段说明：</p>
<blockquote>
<p>Throws an &quot;InvalidAccessError&quot; exception if async is false, the JavaScript global environment is a document environment, and either the timeout attribute is not zero, the withCredentials attribute is true, or the responseType attribute is not the empty string.</p>
</blockquote>
<p>从上面一段说明可以知道，当<code>xhr</code>为同步请求时，有如下限制：</p>
<ul>
<li><code>xhr.timeout</code>必须为<code>0</code></li>
<li><code>xhr.withCredentials</code>必须为 <code>false</code></li>
<li><code>xhr.responseType</code>必须为<code>&quot;&quot;</code>（注意置为<code>&quot;text&quot;</code>也不允许）</li>
</ul>
<p>若上面任何一个限制不满足，都会抛错，而对于异步请求，则没有这些参数设置上的限制。</p>
<p>之前说过页面中应该尽量避免使用<code>sync</code>同步请求，为什么呢？<br>
因为我们无法设置请求超时时间（<code>xhr.timeout</code>为<code>0</code>，即不限时）。在不限制超时的情况下，有可能同步请求一直处于<code>pending</code>状态，服务端迟迟不返回响应，这样整个页面就会一直阻塞，无法响应用户的其他交互。</p>
<p>另外，标准中并没有提及同步请求时事件触发的限制，但实际开发中我确实遇到过部分应该触发的事件并没有触发的现象。如在 chrome中，当<code>xhr</code>为同步请求时，在<code>xhr.readyState</code>由<code>2</code>变成<code>3</code>时，并不会触发 <code>onreadystatechange</code>事件，<code>xhr.upload.onprogress</code>和 <code>xhr.onprogress</code>事件也不会触发。</p>
<h3 id="如何获取上传-下载的进度">如何获取上传、下载的进度</h3>
<p>在上传或者下载比较大的文件时，实时显示当前的上传、下载进度是很普遍的产品需求。<br>
我们可以通过<code>onprogress</code>事件来实时显示进度，默认情况下这个事件每50ms触发一次。需要注意的是，上传过程和下载过程触发的是不同对象的<code>onprogress</code>事件：</p>
<ul>
<li>上传触发的是<code>xhr.upload</code>对象的 <code>onprogress</code>事件</li>
<li>下载触发的是<code>xhr</code>对象的<code>onprogress</code>事件</li>
</ul>
<pre><code class="language-js">xhr.onprogress = updateProgress;
xhr.upload.onprogress = updateProgress;
function updateProgress(event) {
    if (event.lengthComputable) {
      var completedPercent = event.loaded / event.total;
    }
 }
</code></pre>
<h3 id="可以发送什么类型的数据">可以发送什么类型的数据</h3>
<blockquote>
<p>void send(data);</p>
</blockquote>
<p><code>xhr.send(data)</code>的参数data可以是以下几种类型：</p>
<ul>
<li><code>ArrayBuffer</code></li>
<li><code>Blob</code></li>
<li><code>Document</code></li>
<li><code>DOMString</code></li>
<li><code>FormData</code></li>
<li><code>null</code></li>
</ul>
<p>如果是 GET/HEAD请求，<code>send()</code>方法一般不传参或传 <code>null</code>。不过即使你真传入了参数，参数也最终被忽略，<code>xhr.send(data)</code>中的data会被置为 <code>null</code>.</p>
<p><code>xhr.send(data)</code>中data参数的数据类型会影响请求头部<code>content-type</code>的默认值：</p>
<ul>
<li>如果<code>data</code>是 <code>Document</code> 类型，同时也是<code>HTML Document</code>类型，则<code>content-type</code>默认值为<code>text/html;charset=UTF-8</code>;否则为<code>application/xml;charset=UTF-8</code>；</li>
<li>如果<code>data</code>是 <code>DOMString</code> 类型，<code>content-type</code>默认值为<code>text/plain;charset=UTF-8</code>；</li>
<li>如果<code>data</code>是 <code>FormData</code> 类型，<code>content-type</code>默认值为<code>multipart/form-data; boundary=[xxx]</code></li>
<li>如果<code>data</code>是其他类型，则不会设置<code>content-type</code>的默认值</li>
</ul>
<p>当然这些只是<code>content-type</code>的默认值，但如果用<code>xhr.setRequestHeader()</code>手动设置了中<code>content-type</code>的值，以上默认值就会被覆盖。</p>
<p>另外需要注意的是，若在断网状态下调用<code>xhr.send(data)</code>方法，则会抛错：<code>Uncaught NetworkError: Failed to execute 'send' on 'XMLHttpRequest'</code>。一旦程序抛出错误，如果不 catch 就无法继续执行后面的代码，所以调用 <code>xhr.send(data)</code>方法时，应该用 <code>try-catch</code>捕捉错误。</p>
<pre><code class="language-js">try{
    xhr.send(data)
  }catch(e) {
    //doSomething...
  };
</code></pre>
<h3 id="xhrwithcredentials与-cors-什么关系"><code>xhr.withCredentials</code>与 <code>CORS</code> 什么关系</h3>
<blockquote>
<p>我们都知道，在发同域请求时，浏览器会将<code>cookie</code>自动加在<code>request header</code>中。但大家是否遇到过这样的场景：在发送跨域请求时，<code>cookie</code>并没有自动加在<code>request header</code>中。</p>
</blockquote>
<p>造成这个问题的原因是：在<code>CORS</code>标准中做了规定，默认情况下，浏览器在发送跨域请求时，不能发送任何认证信息（<code>credentials</code>）如&quot;<code>cookies</code>&quot;和&quot;<code>HTTP authentication schemes</code>&quot;。除非<code>xhr.withCredentials</code>为<code>true</code>（<code>xhr</code>对象有一个属性叫<code>withCredentials</code>，默认值为<code>false</code>）。</p>
<p>所以根本原因是<code>cookies</code>也是一种认证信息，在跨域请求中，<code>client</code>端必须手动设置<code>xhr.withCredentials=true</code>，且<code>server</code>端也必须允许<code>request</code>能携带认证信息（即<code>response header</code>中包含<code>Access-Control-Allow-Credentials:true</code>），这样浏览器才会自动将<code>cookie</code>加在<code>request header</code>中。</p>
<p>另外，要特别注意一点，一旦跨域<code>request</code>能够携带认证信息，<code>server</code>端一定不能将<code>Access-Control-Allow-Origin</code>设置为<code>*</code>，而必须设置为请求页面的域名。</p>
<h2 id="xhr相关事件"><code>xhr</code>相关事件</h2>
<h3 id="事件分类">事件分类</h3>
<p><code>xhr</code>相关事件有很多，有时记起来还挺容易混乱。但当我了解了具体代码实现后，就容易理清楚了。下面是<code>XMLHttpRequest</code>的部分实现代码：</p>
<pre><code class="language-js">interface XMLHttpRequestEventTarget : EventTarget {
  // event handlers
  attribute EventHandler onloadstart;
  attribute EventHandler onprogress;
  attribute EventHandler onabort;
  attribute EventHandler onerror;
  attribute EventHandler onload;
  attribute EventHandler ontimeout;
  attribute EventHandler onloadend;
};

interface XMLHttpRequestUpload : XMLHttpRequestEventTarget {

};

interface XMLHttpRequest : XMLHttpRequestEventTarget {
  // event handler
  attribute EventHandler onreadystatechange;
  readonly attribute XMLHttpRequestUpload upload;
};
</code></pre>
<p>从代码中我们可以看出：</p>
<ol>
<li><code>XMLHttpRequestEventTarget</code>接口定义了7个事件：
<ul>
<li><code>onloadstart</code></li>
<li><code>onprogress</code></li>
<li><code>onabort</code></li>
<li><code>ontimeout</code></li>
<li><code>onerror</code></li>
<li><code>onload</code></li>
<li><code>onloadend</code></li>
</ul>
</li>
<li>每一个<code>XMLHttpRequest</code>里面都有一个<code>upload</code>属性，而<code>upload</code>是一个<code>XMLHttpRequestUpload</code>对象</li>
<li><code>XMLHttpRequest</code>和<code>XMLHttpRequestUpload</code>都继承了同一个<code>XMLHttpRequestEventTarget</code>接口，所以<code>xhr</code>和<code>xhr.upload</code>都有第一条列举的7个事件</li>
<li><code>onreadystatechange</code>是<code>XMLHttpRequest</code>独有的事件</li>
</ol>
<p>所以这么一看就很清晰了：<br>
<code>xhr</code>一共有8个相关事件：7个<code>XMLHttpRequestEventTarget</code>事件+1个独有的<code>onreadystatechange</code>事件；而<code>xhr.upload</code>只有7个<code>XMLHttpRequestEventTarget</code>事件。</p>
<h3 id="事件触发条件">事件触发条件</h3>
<p>下面是我自己整理的一张<code>xhr</code>相关事件触发条件表，其中最需要注意的是 <code>onerror</code> 事件的触发条件。</p>
<table>
<thead>
<tr>
<th>事件</th>
<th>触发条件</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>onreadystatechange</code></td>
<td>每当<code>xhr.readyState</code>改变时触发；但<code>xhr.readyState</code>由非<code>0</code>值变为<code>0</code>时不触发。</td>
</tr>
<tr>
<td><code>onloadstart</code></td>
<td>调用<code>xhr.send()</code>方法后立即触发，若<code>xhr.send()</code>未被调用则不会触发此事件。</td>
</tr>
<tr>
<td><code>onprogress</code></td>
<td><code>xhr.upload.onprogress</code>在上传阶段(即<code>xhr.send()</code>之后，<code>xhr.readystate=2</code>之前)触发，每50ms触发一次；<code>xhr.onprogress</code>在下载阶段（即<code>xhr.readystate=3</code>时）触发，每50ms触发一次。</td>
</tr>
<tr>
<td><code>onload</code></td>
<td>当请求成功完成时触发，此时<code>xhr.readystate=4</code></td>
</tr>
<tr>
<td><code>onloadend</code></td>
<td>当请求结束（包括请求成功和请求失败）时触发</td>
</tr>
<tr>
<td><code>onabort</code></td>
<td>当调用<code>xhr.abort()</code>后触发</td>
</tr>
<tr>
<td><code>ontimeout</code></td>
<td><code>xhr.timeout</code>不等于0，由请求开始即<code>onloadstart</code>开始算起，当到达<code>xhr.timeout</code>所设置时间请求还未结束即<code>onloadend</code>，则触发此事件。</td>
</tr>
<tr>
<td><code>onerror</code></td>
<td>在请求过程中，若发生<code>Network error</code>则会触发此事件（若发生<code>Network error</code>时，上传还没有结束，则会先触发<code>xhr.upload.onerror</code>，再触发<code>xhr.onerror</code>；若发生<code>Network error</code>时，上传已经结束，则只会触发<code>xhr.onerror</code>）。<strong>注意</strong>，只有发生了网络层级别的异常才会触发此事件，对于应用层级别的异常，如响应返回的<code>xhr.statusCode</code>是<code>4xx</code>时，并不属于<code>Network error</code>，所以不会触发<code>onerror</code>事件，而是会触发<code>onload</code>事件。</td>
</tr>
</tbody>
</table>
<h3 id="事件触发顺序">事件触发顺序</h3>
<p>当请求一切正常时，相关的事件触发顺序如下：</p>
<ol>
<li>触发<code>xhr.onreadystatechange</code>(之后每次<code>readyState</code>变化时，都会触发一次)</li>
<li>触发<code>xhr.onloadstart</code><br>
//上传阶段开始：</li>
<li>触发<code>xhr.upload.onloadstart</code></li>
<li>触发<code>xhr.upload.onprogress</code></li>
<li>触发<code>xhr.upload.onload</code></li>
<li>触发<code>xhr.upload.onloadend</code><br>
//上传结束，下载阶段开始：</li>
<li>触发<code>xhr.onprogress</code></li>
<li>触发<code>xhr.onload</code></li>
<li>触发<code>xhr.onloadend</code></li>
</ol>
<h4 id="发生aborttimeouterror异常的处理">发生<code>abort</code>/<code>timeout</code>/<code>error</code>异常的处理</h4>
<p>在请求的过程中，有可能发生 <code>abort</code>/<code>timeout</code>/<code>error</code>这3种异常。那么一旦发生这些异常，<code>xhr</code>后续会进行哪些处理呢？后续处理如下：</p>
<ol>
<li>一旦发生<code>abort</code>或<code>timeout</code>或<code>error</code>异常，先立即中止当前请求</li>
<li>将 <code>readystate</code> 置为<code>4</code>，并触发 <code>xhr.onreadystatechange</code>事件</li>
<li>如果上传阶段还没有结束，则依次触发以下事件：
<ul>
<li><code>xhr.upload.onprogress</code></li>
<li><code>xhr.upload.[onabort或ontimeout或onerror]</code></li>
<li><code>xhr.upload.onloadend</code></li>
</ul>
</li>
<li>触发 <code>xhr.onprogress</code>事件</li>
<li>触发 <code>xhr.[onabort或ontimeout或onerror]</code>事件</li>
<li>触发<code>xhr.onloadend</code> 事件</li>
</ol>
<h4 id="在哪个xhr事件中注册成功回调">在哪个<code>xhr</code>事件中注册成功回调？</h4>
<p>从上面介绍的事件中，可以知道若<code>xhr</code>请求成功，就会触发<code>xhr.onreadystatechange</code>和<code>xhr.onload</code>两个事件。 那么我们到底要将成功回调注册在哪个事件中呢？我倾向于 <code>xhr.onload</code>事件，因为<code>xhr.onreadystatechange</code>是每次<code>xhr.readyState</code>变化时都会触发，而不是<code>xhr.readyState=4</code>时才触发。</p>
<pre><code class="language-js">xhr.onload = function () {
    //如果请求成功
    if(xhr.status == 200){
      //do successCallback
    }
  }
</code></pre>
<p>上面的示例代码是很常见的写法：先判断<code>http</code>状态码是否是<code>200</code>，如果是，则认为请求是成功的，接着执行成功回调。这样的判断是有坑儿的，比如当返回的<code>http</code>状态码不是<code>200</code>，而是<code>201</code>时，请求虽然也是成功的，但并没有执行成功回调逻辑。所以更靠谱的判断方法应该是：当<code>http</code>状态码为<code>2xx</code>或<code>304</code>时才认为成功。</p>
<pre><code class="language-js">  xhr.onload = function () {
    //如果请求成功
    if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304){
      //do successCallback
    }
  }
</code></pre>
<h2 id="参考资料">参考资料</h2>
<p><a href="https://www.w3.org/TR/XMLHttpRequest/">w3</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest">MDN</a></p>
<h2 id="转载">转载</h2>
<blockquote>
<h3 id="ruoyiqing">ruoyiqing</h3>
<p><a href="https://segmentfault.com/a/1190000004322487">https://segmentfault.com/a/1190000004322487</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[github-连接错误Connection reset by 13.229.188.59 port 22 ssh]]></title>
        <id>https://leecss.com/post/github-lian-jie-cuo-wu-connection-reset-by-1322918859-port-22-ssh/</id>
        <link href="https://leecss.com/post/github-lian-jie-cuo-wu-connection-reset-by-1322918859-port-22-ssh/">
        </link>
        <updated>2021-07-15T00:41:06.000Z</updated>
        <content type="html"><![CDATA[<h1 id="github-连接错误connection-reset-by-1322918859-port-22-ssh">github-连接错误Connection reset by 13.229.188.59 port 22 ssh</h1>
<h2 id="概述">概述</h2>
<p>当你想连接GitHub提交时，发现无法提交，报错如下：</p>
<pre><code>Connection reset by 13.229.188.59 port 22 ssh
</code></pre>
<h2 id="解决">解决</h2>
<p>在Windows防火墙中设置22端口</p>
<p>1、控制面板-系统和安全-Windows Defender防火墙-高级设置</p>
<p>2、选择<strong>入站规则</strong>-<strong>新建规则</strong></p>
<p>3、选择<strong>端口</strong></p>
<p>4、特定本地端口：输入<strong>22</strong></p>
<p>5、选择<strong>允许连接</strong></p>
<p>6、输入<strong>名称</strong>和<strong>描述</strong>，自定义，也可如下</p>
<p>名称：22in</p>
<p>描述：Connection reset by 13.229.188.59 port 22 ssh</p>
<h2 id="其他方法">其他方法</h2>
<p>更改防火墙禁掉的22端口，ssh本来使用的22，可以在https端口使用ssh</p>
<p>1、要测试通过 HTTPS 端口的 SSH 是否可行，请运行以下 SSH 命令：</p>
<pre><code class="language-shell">$ ssh -T -p 443 git@ssh.github.com
&gt; Hi username! You've successfully authenticated, but GitHub does not
&gt; provide shell access.
</code></pre>
<p>如果这样有效，万事大吉！</p>
<p>2、如果您能在端口 443 上通过 SSH 连接到 <code>git@ssh.github.com</code>，则可以覆盖您的 SSH 设置以强制与 GitHub 的任何连接均通过该服务器和端口运行。</p>
<p>要在您的 ssh 配置中设置此项，编辑位于 <code>~/.ssh/config</code> 的文件，添加以下部分：</p>
<pre><code>Host github.com
  Hostname ssh.github.com
  Port 443
  User git
</code></pre>
<p>您可以通过再次连接到 GitHub 测试此项是否有效：</p>
<pre><code class="language-shell">$ ssh -T git@github.com
&gt; Hi username! You've successfully authenticated, but GitHub does not
&gt; provide shell access.
</code></pre>
<h2 id="文档">文档</h2>
<p><a href="https://docs.github.com/cn/github/authenticating-to-github/troubleshooting-ssh/using-ssh-over-the-https-port">https://docs.github.com/cn/github/authenticating-to-github/troubleshooting-ssh/using-ssh-over-the-https-port</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[http-跨域CORS]]></title>
        <id>https://leecss.com/post/http-kua-yu-cors/</id>
        <link href="https://leecss.com/post/http-kua-yu-cors/">
        </link>
        <updated>2021-07-14T15:15:19.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>CORS是一个W3C标准，全称是&quot;跨域资源共享&quot;（Cross-origin resource sharing）。</p>
<p>它允许浏览器向跨源服务器，发出<a href="https://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html"><code>XMLHttpRequest</code></a>请求，从而克服了AJAX只能<a href="https://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html">同源</a>使用的限制。</p>
<h2 id="一-简介">一、简介</h2>
<p>CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。</p>
<p>整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p>
<p>因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p>
<h2 id="二-两种请求">二、两种请求</h2>
<p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p>
<p>只要同时满足以下两大条件，就属于简单请求。</p>
<blockquote>
<p>（1) 请求方法是以下三种方法之一：</p>
<ul>
<li>HEAD</li>
<li>GET</li>
<li>POST</li>
</ul>
<p>（2）HTTP的头信息不超出以下几种字段：</p>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
<li>Content-Type：只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></li>
</ul>
</blockquote>
<p>这是为了兼容表单（form），因为历史上表单一直可以发出跨域请求。AJAX 的跨域设计就是，只要表单可以发，AJAX 就可以直接发。</p>
<p>凡是不同时满足上面两个条件，就属于非简单请求。</p>
<p>浏览器对这两种请求的处理，是不一样的。</p>
<h2 id="三-简单请求">三、简单请求</h2>
<h3 id="31-基本流程">3.1 基本流程</h3>
<p>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个<code>Origin</code>字段。</p>
<p>下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个<code>Origin</code>字段。</p>
<blockquote>
<pre><code class="language-http">GET /cors HTTP/1.1
Origin: http://api.bob.com
Host: api.alice.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
</code></pre>
</blockquote>
<p>上面的头信息中，<code>Origin</code>字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p>
<p>如果<code>Origin</code>指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含<code>Access-Control-Allow-Origin</code>字段（详见下文），就知道出错了，从而抛出一个错误，被<code>XMLHttpRequest</code>的<code>onerror</code>回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。</p>
<p>如果<code>Origin</code>指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p>
<blockquote>
<pre><code class="language-http">Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Credentials: true
Access-Control-Expose-Headers: FooBar
Content-Type: text/html; charset=utf-8
</code></pre>
</blockquote>
<p>上面的头信息之中，有三个与CORS请求相关的字段，都以<code>Access-Control-</code>开头。</p>
<p><strong>（1）Access-Control-Allow-Origin</strong></p>
<p>该字段是必须的。它的值要么是请求时<code>Origin</code>字段的值，要么是一个<code>*</code>，表示接受任意域名的请求。</p>
<p><strong>（2）Access-Control-Allow-Credentials</strong></p>
<p>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为<code>true</code>，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为<code>true</code>，如果服务器不要浏览器发送Cookie，删除该字段即可。</p>
<p><strong>（3）Access-Control-Expose-Headers</strong></p>
<p>该字段可选。CORS请求时，<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到6个基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定。上面的例子指定，<code>getResponseHeader('FooBar')</code>可以返回<code>FooBar</code>字段的值。</p>
<h3 id="32-withcredentials-属性">3.2 withCredentials 属性</h3>
<p>上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定<code>Access-Control-Allow-Credentials</code>字段。</p>
<blockquote>
<pre><code class="language-http">Access-Control-Allow-Credentials: true
</code></pre>
</blockquote>
<p>另一方面，开发者必须在AJAX请求中打开<code>withCredentials</code>属性。</p>
<blockquote>
<pre><code class="language-javascript">var xhr = new XMLHttpRequest();
xhr.withCredentials = true;
</code></pre>
</blockquote>
<p>否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。</p>
<p>但是，如果省略<code>withCredentials</code>设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭<code>withCredentials</code>。</p>
<blockquote>
<pre><code class="language-javascript">xhr.withCredentials = false;
</code></pre>
</blockquote>
<p>需要注意的是，如果要发送Cookie，<code>Access-Control-Allow-Origin</code>就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的<code>document.cookie</code>也无法读取服务器域名下的Cookie。</p>
<h2 id="四-非简单请求">四、非简单请求</h2>
<h3 id="41-预检请求">4.1 预检请求</h3>
<p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是<code>PUT</code>或<code>DELETE</code>，或者<code>Content-Type</code>字段的类型是<code>application/json</code>。</p>
<p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为&quot;预检&quot;请求（preflight）。</p>
<p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错。</p>
<p>下面是一段浏览器的JavaScript脚本。</p>
<blockquote>
<pre><code class="language-javascript">var url = 'http://api.alice.com/cors';
var xhr = new XMLHttpRequest();
xhr.open('PUT', url, true);
xhr.setRequestHeader('X-Custom-Header', 'value');
xhr.send();
</code></pre>
</blockquote>
<p>上面代码中，HTTP请求的方法是<code>PUT</code>，并且发送一个自定义头信息<code>X-Custom-Header</code>。</p>
<p>浏览器发现，这是一个非简单请求，就自动发出一个&quot;预检&quot;请求，要求服务器确认可以这样请求。下面是这个&quot;预检&quot;请求的HTTP头信息。</p>
<blockquote>
<pre><code class="language-http">OPTIONS /cors HTTP/1.1
Origin: http://api.bob.com
Access-Control-Request-Method: PUT
Access-Control-Request-Headers: X-Custom-Header
Host: api.alice.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
</code></pre>
</blockquote>
<p>&quot;预检&quot;请求用的请求方法是<code>OPTIONS</code>，表示这个请求是用来询问的。头信息里面，关键字段是<code>Origin</code>，表示请求来自哪个源。</p>
<p>除了<code>Origin</code>字段，&quot;预检&quot;请求的头信息包括两个特殊字段。</p>
<p><strong>（1）Access-Control-Request-Method</strong></p>
<p>该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是<code>PUT</code>。</p>
<p><strong>（2）Access-Control-Request-Headers</strong></p>
<p>该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是<code>X-Custom-Header</code>。</p>
<h3 id="42-预检请求的回应">4.2 预检请求的回应</h3>
<p>服务器收到&quot;预检&quot;请求以后，检查了<code>Origin</code>、<code>Access-Control-Request-Method</code>和<code>Access-Control-Request-Headers</code>字段以后，确认允许跨源请求，就可以做出回应。</p>
<blockquote>
<pre><code class="language-http">HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:15:39 GMT
Server: Apache/2.0.61 (Unix)
Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
Content-Type: text/html; charset=utf-8
Content-Encoding: gzip
Content-Length: 0
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Content-Type: text/plain
</code></pre>
</blockquote>
<p>上面的HTTP回应中，关键的是<code>Access-Control-Allow-Origin</code>字段，表示<code>http://api.bob.com</code>可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。</p>
<blockquote>
<pre><code class="language-http">Access-Control-Allow-Origin: *
</code></pre>
</blockquote>
<p>如果服务器否定了&quot;预检&quot;请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被<code>XMLHttpRequest</code>对象的<code>onerror</code>回调函数捕获。控制台会打印出如下的报错信息。</p>
<blockquote>
<pre><code class="language-bash">XMLHttpRequest cannot load http://api.alice.com.
Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.
</code></pre>
</blockquote>
<p>服务器回应的其他CORS相关字段如下。</p>
<blockquote>
<pre><code class="language-http">Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
Access-Control-Allow-Credentials: true
Access-Control-Max-Age: 1728000
</code></pre>
</blockquote>
<p><strong>（1）Access-Control-Allow-Methods</strong></p>
<p>该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次&quot;预检&quot;请求。</p>
<p><strong>（2）Access-Control-Allow-Headers</strong></p>
<p>如果浏览器请求包括<code>Access-Control-Request-Headers</code>字段，则<code>Access-Control-Allow-Headers</code>字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在&quot;预检&quot;中请求的字段。</p>
<p><strong>（3）Access-Control-Allow-Credentials</strong></p>
<p>该字段与简单请求时的含义相同。</p>
<p><strong>（4）Access-Control-Max-Age</strong></p>
<p>该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。</p>
<h3 id="43-浏览器的正常请求和回应">4.3 浏览器的正常请求和回应</h3>
<p>一旦服务器通过了&quot;预检&quot;请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个<code>Origin</code>头信息字段。服务器的回应，也都会有一个<code>Access-Control-Allow-Origin</code>头信息字段。</p>
<p>下面是&quot;预检&quot;请求之后，浏览器的正常CORS请求。</p>
<blockquote>
<pre><code class="language-http">PUT /cors HTTP/1.1
Origin: http://api.bob.com
Host: api.alice.com
X-Custom-Header: value
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
</code></pre>
</blockquote>
<p>上面头信息的<code>Origin</code>字段是浏览器自动添加的。</p>
<p>下面是服务器正常的回应。</p>
<blockquote>
<pre><code class="language-http">Access-Control-Allow-Origin: http://api.bob.com
Content-Type: text/html; charset=utf-8
</code></pre>
</blockquote>
<p>上面头信息中，<code>Access-Control-Allow-Origin</code>字段是每次回应都必定包含的。</p>
<h2 id="五-与jsonp的比较">五、与JSONP的比较</h2>
<p>CORS与JSONP的使用目的相同，但是比JSONP更强大。</p>
<p>JSONP只支持<code>GET</code>请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</p>
<h2 id="转载">转载</h2>
<blockquote>
<p>阮一峰</p>
<p><a href="https://www.ruanyifeng.com/blog/2016/04/cors.html">https://www.ruanyifeng.com/blog/2016/04/cors.html</a></p>
</blockquote>
<h2 id="推荐阅读">推荐阅读</h2>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">MDN-CORS</a></p>
<p><a href="https://juejin.cn/post/6844904126246027278">10种跨域解决方案</a></p>
<p><a href="https://segmentfault.com/a/1190000011145364">前端常见跨域解决方案</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[http-浏览器同源政策及其规避方法]]></title>
        <id>https://leecss.com/post/http-kua-yu/</id>
        <link href="https://leecss.com/post/http-kua-yu/">
        </link>
        <updated>2021-07-13T13:37:13.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>**「同源策略」**是一个重要的安全策略，它用于限制一个<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Origin">origin</a>的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。</p>
<p>--来源 MDN</p>
<h2 id="一-概述">一、概述</h2>
<h3 id="11-含义">1.1 含义</h3>
<p>1995年，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策。</p>
<p>最初，它的含义是指，A网页设置的 Cookie，B网页不能打开，除非这两个网页&quot;同源&quot;。所谓&quot;同源&quot;指的是&quot;三个相同&quot;。</p>
<blockquote>
<ul>
<li>协议相同</li>
<li>域名相同</li>
<li>端口相同</li>
</ul>
</blockquote>
<p>举例来说，<code>http://www.example.com/dir/page.html</code>这个网址，协议是<code>http://</code>，域名是<code>www.example.com</code>，端口是<code>80</code>（默认端口可以省略）。它的同源情况如下。</p>
<blockquote>
<ul>
<li><code>http://www.example.com/dir2/other.html</code>：同源</li>
<li><code>http://example.com/dir/other.html</code>：不同源（域名不同）</li>
<li><code>http://v2.www.example.com/dir/other.html</code>：不同源（域名不同）</li>
<li><code>http://www.example.com:81/dir/other.html</code>：不同源（端口不同）</li>
</ul>
</blockquote>
<h3 id="12-目的">1.2 目的</h3>
<p>同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。</p>
<p>设想这样一种情况：A网站是一家银行，用户登录以后，又去浏览其他网站。如果其他网站可以读取A网站的 Cookie，会发生什么？</p>
<p>很显然，如果 Cookie 包含隐私（比如存款总额），这些信息就会泄漏。更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。</p>
<p>由此可见，&quot;同源政策&quot;是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了。</p>
<h3 id="13-限制范围">1.3 限制范围</h3>
<p>随着互联网的发展，&quot;同源政策&quot;越来越严格。目前，如果非同源，共有三种行为受到限制。</p>
<blockquote>
<p>（1） Cookie、LocalStorage 和 IndexDB 无法读取。</p>
<p>（2） DOM 无法获得。</p>
<p>（3） AJAX 请求不能发送。</p>
</blockquote>
<p>虽然这些限制是必要的，但是有时很不方便，合理的用途也受到影响。下面，我将详细介绍，如何规避上面三种限制。</p>
<h2 id="二-cookie">二、Cookie</h2>
<p>Cookie 是服务器写入浏览器的一小段信息，只有同源的网页才能共享。但是，两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置<code>document.domain</code>共享 Cookie。</p>
<p>举例来说，A网页是<code>http://w1.example.com/a.html</code>，B网页是<code>http://w2.example.com/b.html</code>，那么只要设置相同的<code>document.domain</code>，两个网页就可以共享Cookie。</p>
<blockquote>
<pre><code class="language-javascript">document.domain = 'example.com';
</code></pre>
</blockquote>
<p>现在，A网页通过脚本设置一个 Cookie。</p>
<blockquote>
<pre><code class="language-javascript">document.cookie = &quot;test1=hello&quot;;
</code></pre>
</blockquote>
<p>B网页就可以读到这个 Cookie。</p>
<blockquote>
<pre><code class="language-javascript">var allCookie = document.cookie;
</code></pre>
</blockquote>
<p>注意，这种方法只适用于 Cookie 和 iframe 窗口，LocalStorage 和 IndexDB 无法通过这种方法，规避同源政策，而要使用下文介绍的PostMessage API。</p>
<p>另外，服务器也可以在设置Cookie的时候，指定Cookie的所属域名为一级域名，比如<code>.example.com</code>。</p>
<blockquote>
<pre><code class="language-http">Set-Cookie: key=value; domain=.example.com; path=/
</code></pre>
</blockquote>
<p>这样的话，二级域名和三级域名不用做任何设置，都可以读取这个Cookie。</p>
<h2 id="三-iframe">三、iframe</h2>
<p>如果两个网页不同源，就无法拿到对方的DOM。典型的例子是<code>iframe</code>窗口和<code>window.open</code>方法打开的窗口，它们与父窗口无法通信。</p>
<p>比如，父窗口运行下面的命令，如果<code>iframe</code>窗口不是同源，就会报错。</p>
<blockquote>
<pre><code class="language-javascript">document.getElementById(&quot;myIFrame&quot;).contentWindow.document
// Uncaught DOMException: Blocked a frame from accessing a cross-origin frame.
</code></pre>
</blockquote>
<p>上面命令中，父窗口想获取子窗口的DOM，因为跨源导致报错。</p>
<p>反之亦然，子窗口获取主窗口的DOM也会报错。</p>
<blockquote>
<pre><code class="language-javascript">window.parent.document.body
// 报错
</code></pre>
</blockquote>
<p>如果两个窗口一级域名相同，只是二级域名不同，那么设置上一节介绍的<code>document.domain</code>属性，就可以规避同源政策，拿到DOM。</p>
<p>对于完全不同源的网站，目前有三种方法，可以解决跨域窗口的通信问题。</p>
<blockquote>
<ul>
<li>片段识别符（fragment identifier）</li>
<li>window.name</li>
<li>跨文档通信API（Cross-document messaging）</li>
</ul>
</blockquote>
<h3 id="31-片段识别符">3.1 片段识别符</h3>
<p>片段标识符（fragment identifier）指的是，URL的<code>#</code>号后面的部分，比如<code>http://example.com/x.html#fragment</code>的<code>#fragment</code>。如果只是改变片段标识符，页面不会重新刷新。</p>
<p>父窗口可以把信息，写入子窗口的片段标识符。</p>
<blockquote>
<pre><code class="language-javascript">var src = originURL + '#' + data;
document.getElementById('myIFrame').src = src;
</code></pre>
</blockquote>
<p>子窗口通过监听<code>hashchange</code>事件得到通知。</p>
<blockquote>
<pre><code class="language-javascript">window.onhashchange = checkMessage;

function checkMessage() {
  var message = window.location.hash;
  // ...
}
</code></pre>
</blockquote>
<p>同样的，子窗口也可以改变父窗口的片段标识符。</p>
<blockquote>
<pre><code class="language-javascript">parent.location.href= target + &quot;#&quot; + hash;
</code></pre>
</blockquote>
<h3 id="32-windowname">3.2 window.name</h3>
<p>浏览器窗口有<code>window.name</code>属性。这个属性的最大特点是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。</p>
<p>父窗口先打开一个子窗口，载入一个不同源的网页，该网页将信息写入<code>window.name</code>属性。</p>
<blockquote>
<pre><code class="language-javascript">window.name = data;
</code></pre>
</blockquote>
<p>接着，子窗口跳回一个与主窗口同域的网址。</p>
<blockquote>
<pre><code class="language-javascript">location = 'http://parent.url.com/xxx.html';
</code></pre>
</blockquote>
<p>然后，主窗口就可以读取子窗口的<code>window.name</code>了。</p>
<blockquote>
<pre><code class="language-javascript">var data = document.getElementById('myFrame').contentWindow.name;
</code></pre>
</blockquote>
<p>这种方法的优点是，<code>window.name</code>容量很大，可以放置非常长的字符串；缺点是必须监听子窗口<code>window.name</code>属性的变化，影响网页性能。</p>
<h3 id="33-windowpostmessage">3.3 window.postMessage</h3>
<p>上面两种方法都属于破解，HTML5为了解决这个问题，引入了一个全新的API：跨文档通信 API（Cross-document messaging）。</p>
<p>这个API为<code>window</code>对象新增了一个<code>window.postMessage</code>方法，允许跨窗口通信，不论这两个窗口是否同源。</p>
<p>举例来说，父窗口<code>http://aaa.com</code>向子窗口<code>http://bbb.com</code>发消息，调用<code>postMessage</code>方法就可以了。</p>
<blockquote>
<pre><code class="language-javascript">var popup = window.open('http://bbb.com', 'title');
popup.postMessage('Hello World!', 'http://bbb.com');
</code></pre>
</blockquote>
<p><code>postMessage</code>方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源（origin），即&quot;协议 + 域名 + 端口&quot;。也可以设为<code>*</code>，表示不限制域名，向所有窗口发送。</p>
<p>子窗口向父窗口发送消息的写法类似。</p>
<blockquote>
<pre><code class="language-javascript">window.opener.postMessage('Nice to see you', 'http://aaa.com');
</code></pre>
</blockquote>
<p>父窗口和子窗口都可以通过<code>message</code>事件，监听对方的消息。</p>
<blockquote>
<pre><code class="language-javascript">window.addEventListener('message', function(e) {
  console.log(e.data);
},false);
</code></pre>
</blockquote>
<p><code>message</code>事件的事件对象<code>event</code>，提供以下三个属性。</p>
<blockquote>
<ul>
<li><code>event.source</code>：发送消息的窗口</li>
<li><code>event.origin</code>: 消息发向的网址</li>
<li><code>event.data</code>: 消息内容</li>
</ul>
</blockquote>
<p>下面的例子是，子窗口通过<code>event.source</code>属性引用父窗口，然后发送消息。</p>
<blockquote>
<pre><code class="language-javascript">window.addEventListener('message', receiveMessage);
function receiveMessage(event) {
  event.source.postMessage('Nice to see you!', '*');
}
</code></pre>
</blockquote>
<p><code>event.origin</code>属性可以过滤不是发给本窗口的消息。</p>
<blockquote>
<pre><code class="language-javascript">window.addEventListener('message', receiveMessage);
function receiveMessage(event) {
  if (event.origin !== 'http://aaa.com') return;
  if (event.data === 'Hello World') {
      event.source.postMessage('Hello', event.origin);
  } else {
    console.log(event.data);
  }
}
</code></pre>
</blockquote>
<h3 id="34-localstorage">3.4 LocalStorage</h3>
<p>通过<code>window.postMessage</code>，读写其他窗口的 LocalStorage 也成为了可能。</p>
<p>下面是一个例子，主窗口写入iframe子窗口的<code>localStorage</code>。</p>
<blockquote>
<pre><code class="language-javascript">window.onmessage = function(e) {
  if (e.origin !== 'http://bbb.com') {
    return;
  }
  var payload = JSON.parse(e.data);
  localStorage.setItem(payload.key, JSON.stringify(payload.data));
};
</code></pre>
</blockquote>
<p>上面代码中，子窗口将父窗口发来的消息，写入自己的LocalStorage。</p>
<p>父窗口发送消息的代码如下。</p>
<blockquote>
<pre><code class="language-javascript">var win = document.getElementsByTagName('iframe')[0].contentWindow;
var obj = { name: 'Jack' };
win.postMessage(JSON.stringify({key: 'storage', data: obj}), 'http://bbb.com');
</code></pre>
</blockquote>
<p>加强版的子窗口接收消息的代码如下。</p>
<blockquote>
<pre><code class="language-javascript">window.onmessage = function(e) {
  if (e.origin !== 'http://bbb.com') return;
  var payload = JSON.parse(e.data);
  switch (payload.method) {
    case 'set':
      localStorage.setItem(payload.key, JSON.stringify(payload.data));
      break;
    case 'get':
      var parent = window.parent;
      var data = localStorage.getItem(payload.key);
      parent.postMessage(data, 'http://aaa.com');
      break;
    case 'remove':
      localStorage.removeItem(payload.key);
      break;
  }
};
</code></pre>
</blockquote>
<p>加强版的父窗口发送消息代码如下。</p>
<blockquote>
<pre><code class="language-javascript">var win = document.getElementsByTagName('iframe')[0].contentWindow;
var obj = { name: 'Jack' };
// 存入对象
win.postMessage(JSON.stringify({key: 'storage', method: 'set', data: obj}), 'http://bbb.com');
// 读取对象
win.postMessage(JSON.stringify({key: 'storage', method: &quot;get&quot;}), &quot;*&quot;);
window.onmessage = function(e) {
  if (e.origin != 'http://aaa.com') return;
  // &quot;Jack&quot;
  console.log(JSON.parse(e.data).name);
};
</code></pre>
</blockquote>
<h2 id="四-ajax">四、AJAX</h2>
<p>同源政策规定，AJAX请求只能发给同源的网址，否则就报错。</p>
<p>除了架设服务器代理（浏览器请求同源服务器，再由后者请求外部服务），有三种方法规避这个限制。</p>
<blockquote>
<ul>
<li>JSONP</li>
<li>WebSocket</li>
<li>CORS</li>
</ul>
</blockquote>
<h3 id="41-jsonp">4.1 JSONP</h3>
<p>JSONP是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，老式浏览器全部支持，服务器改造非常小。</p>
<p>它的基本思想是，网页通过添加一个<code>&lt;script&gt;</code>元素，向服务器请求JSON数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。</p>
<p>首先，网页动态插入<code>&lt;script&gt;</code>元素，由它向跨源网址发出请求。</p>
<blockquote>
<pre><code class="language-javascript">function addScriptTag(src) {
  var script = document.createElement('script');
  script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;);
  script.src = src;
  document.body.appendChild(script);
}

window.onload = function () {
  addScriptTag('http://example.com/ip?callback=foo');
}

function foo(data) {
  console.log('Your public IP address is: ' + data.ip);
};
</code></pre>
</blockquote>
<p>上面代码通过动态添加<code>&lt;script&gt;</code>元素，向服务器<code>example.com</code>发出请求。注意，该请求的查询字符串有一个<code>callback</code>参数，用来指定回调函数的名字，这对于JSONP是必需的。</p>
<p>服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。</p>
<blockquote>
<pre><code class="language-javascript">foo({
  &quot;ip&quot;: &quot;8.8.8.8&quot;
});
</code></pre>
</blockquote>
<p>由于<code>&lt;script&gt;</code>元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了<code>foo</code>函数，该函数就会立即调用。作为参数的JSON数据被视为JavaScript对象，而不是字符串，因此避免了使用<code>JSON.parse</code>的步骤。</p>
<h3 id="42-websocket">4.2 WebSocket</h3>
<p>WebSocket是一种通信协议，使用<code>ws://</code>（非加密）和<code>wss://</code>（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。</p>
<p>下面是一个例子，浏览器发出的WebSocket请求的头信息（摘自<a href="https://en.wikipedia.org/wiki/WebSocket">维基百科</a>）。</p>
<blockquote>
<pre><code class="language-http">GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
Origin: http://example.com
</code></pre>
</blockquote>
<p>上面代码中，有一个字段是<code>Origin</code>，表示该请求的请求源（origin），即发自哪个域名。</p>
<p>正是因为有了<code>Origin</code>这个字段，所以WebSocket才没有实行同源政策。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。</p>
<blockquote>
<pre><code class="language-http">HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=
Sec-WebSocket-Protocol: chat
</code></pre>
</blockquote>
<h3 id="43-cors">4.3 CORS</h3>
<p>CORS是跨源资源分享（Cross-Origin Resource Sharing）的缩写。它是W3C标准，是跨源AJAX请求的根本解决方法。相比JSONP只能发<code>GET</code>请求，CORS允许任何类型的请求。</p>
<h2 id="转载">转载</h2>
<blockquote>
<p>阮一峰</p>
<p><a href="https://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html">https://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[http-curl命令行]]></title>
        <id>https://leecss.com/post/http-curl-ming-ling-xing/</id>
        <link href="https://leecss.com/post/http-curl-ming-ling-xing/">
        </link>
        <updated>2021-07-12T13:39:28.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p><a href="http://curl.haxx.se/">curl</a>是一种命令行工具，作用是发出网络请求，然后得到和提取数据，显示在&quot;标准输出&quot;（stdout）上面。</p>
<p><strong>一、查看网页源码</strong></p>
<p>直接在curl命令后加上网址，就可以看到网页源码。我们以网址baidu.com为例（选择该网址，主要因为它的网页代码较短）：</p>
<pre><code class="language-shell">curl baidu.com
</code></pre>
<pre><code class="language-html">&lt;html&gt;
&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;url=http://www.baidu.com/&quot;&gt;
&lt;/html&gt;
</code></pre>
<p>页面会重定向到百度</p>
<p>如果要把这个网页保存下来，可以使用<code>-o</code>参数，这就相当于使用wget命令了。</p>
<pre><code class="language-sh">curl -o [文件名] baidu.com
</code></pre>
<pre><code class="language-sh">curl -o baudu.html baidu.com
</code></pre>
<p><strong>二、显示头信息</strong></p>
<p><code>-i</code>参数可以显示http response的头信息，连同网页代码一起。</p>
<p><code>-I</code>参数则是只显示http response的头信息。</p>
<pre><code class="language-sh">curl -i baidu.com
</code></pre>
<pre><code class="language-shell">HTTP/1.1 200 OK                                                   
Date: Sun, 06 Jun 2021 08:49:54 GMT                               
Server: Apache                                                    
Last-Modified: Tue, 12 Jan 2010 13:48:00 GMT                      
ETag: &quot;51-47cf7e6ee8400&quot;                                          
Accept-Ranges: bytes                                              
Content-Length: 81                                                
Cache-Control: max-age=86400                                      
Expires: Mon, 07 Jun 2021 08:49:54 GMT                            
Connection: Keep-Alive                                            
Content-Type: text/html                                           
                                                                  
&lt;html&gt;                                                            
&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;url=http://www.baidu.com/&quot;&gt; 
&lt;/html&gt;                                                           
</code></pre>
<p><strong>三、显示通信过程</strong></p>
<p><code>-v</code>参数可以显示一次http通信的整个过程，包括端口连接和http request头信息。</p>
<pre><code class="language-sh">curl -v baidu.com
</code></pre>
<pre><code class="language-shell">* Rebuilt URL to: baidu.com/
*   Trying 220.181.38.148...
* TCP_NODELAY set
* Connected to baidu.com (220.181.38.148) port 80 (#0)
&gt; GET / HTTP/1.1
&gt; Host: baidu.com
&gt; User-Agent: curl/7.55.1
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 200 OK
&lt; Date: Sun, 06 Jun 2021 08:53:20 GMT
&lt; Server: Apache
&lt; Last-Modified: Tue, 12 Jan 2010 13:48:00 GMT
&lt; ETag: &quot;51-47cf7e6ee8400&quot;
&lt; Accept-Ranges: bytes
&lt; Content-Length: 81
&lt; Cache-Control: max-age=86400
&lt; Expires: Mon, 07 Jun 2021 08:53:20 GMT
&lt; Connection: Keep-Alive
&lt; Content-Type: text/html
&lt;
&lt;html&gt;
&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;url=http://www.baidu.com/&quot;&gt;
&lt;/html&gt;
* Connection #0 to host baidu.com left intact
</code></pre>
<p>如果你觉得上面的信息还不够，那么下面的命令可以查看更详细的通信过程。</p>
<pre><code class="language-sh">curl --trace output.txt baidu.com
</code></pre>
<pre><code class="language-sh">curl --trace-ascii output.txt baidu.com
</code></pre>
<p>推荐阅读</p>
<blockquote>
<p>阮一峰</p>
<p><a href="http://www.ruanyifeng.com/blog/2019/09/curl-reference.html">http://www.ruanyifeng.com/blog/2019/09/curl-reference.html</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[http-使用node创建一个简单的web服务]]></title>
        <id>https://leecss.com/post/http-shi-yong-node-chuang-jian-yi-ge-jian-dan-de-web-fu-wu/</id>
        <link href="https://leecss.com/post/http-shi-yong-node-chuang-jian-yi-ge-jian-dan-de-web-fu-wu/">
        </link>
        <updated>2021-07-12T12:47:16.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>电脑上安装好node,新建server.js文件，使用<code>node server.js</code>运行该文件。</p>
<h2 id="代码">代码</h2>
<pre><code class="language-js">const http = require('http')

http.createServer(function (request, response) {
    console.log('request come', request.url)

    response.end('123')
}).listen(8888)

console.log('server listening on 8888')
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[http-状态码]]></title>
        <id>https://leecss.com/post/http-zhuang-tai-ma/</id>
        <link href="https://leecss.com/post/http-zhuang-tai-ma/">
        </link>
        <updated>2021-07-09T00:05:15.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。</p>
<p>HTTP状态码的英文为HTTP Status Code。</p>
<p>下面是常见的HTTP状态码：</p>
<ul>
<li>200 - 请求成功</li>
<li>301 - 资源（网页等）被永久转移到其它URL</li>
<li>404 - 请求的资源（网页等）不存在</li>
<li>500 - 内部服务器错误</li>
</ul>
<h2 id="http状态码分类">HTTP状态码分类</h2>
<p>HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型：</p>
<table>
<thead>
<tr>
<th style="text-align:left">分类</th>
<th style="text-align:left">分类描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1**</td>
<td style="text-align:left">信息，服务器收到请求，需要请求者继续执行操作</td>
</tr>
<tr>
<td style="text-align:left">2**</td>
<td style="text-align:left">成功，操作被成功接收并处理</td>
</tr>
<tr>
<td style="text-align:left">3**</td>
<td style="text-align:left">重定向，需要进一步的操作以完成请求</td>
</tr>
<tr>
<td style="text-align:left">4**</td>
<td style="text-align:left">客户端错误，请求包含语法错误或无法完成请求</td>
</tr>
<tr>
<td style="text-align:left">5**</td>
<td style="text-align:left">服务器错误，服务器在处理请求的过程中发生了错误</td>
</tr>
</tbody>
</table>
<p>HTTP状态码列表:</p>
<table>
<thead>
<tr>
<th style="text-align:left">状态码</th>
<th style="text-align:left">状态码英文名称</th>
<th style="text-align:left">中文描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">100</td>
<td style="text-align:left">Continue</td>
<td style="text-align:left">继续。客户端应继续其请求</td>
</tr>
<tr>
<td style="text-align:left">101</td>
<td style="text-align:left">Switching Protocols</td>
<td style="text-align:left">切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">200</td>
<td style="text-align:left">OK</td>
<td style="text-align:left">请求成功。一般用于GET与POST请求</td>
</tr>
<tr>
<td style="text-align:left">201</td>
<td style="text-align:left">Created</td>
<td style="text-align:left">已创建。成功请求并创建了新的资源</td>
</tr>
<tr>
<td style="text-align:left">202</td>
<td style="text-align:left">Accepted</td>
<td style="text-align:left">已接受。已经接受请求，但未处理完成</td>
</tr>
<tr>
<td style="text-align:left">203</td>
<td style="text-align:left">Non-Authoritative Information</td>
<td style="text-align:left">非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td>
</tr>
<tr>
<td style="text-align:left">204</td>
<td style="text-align:left">No Content</td>
<td style="text-align:left">无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td>
</tr>
<tr>
<td style="text-align:left">205</td>
<td style="text-align:left">Reset Content</td>
<td style="text-align:left">重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td>
</tr>
<tr>
<td style="text-align:left">206</td>
<td style="text-align:left">Partial Content</td>
<td style="text-align:left">部分内容。服务器成功处理了部分GET请求</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">300</td>
<td style="text-align:left">Multiple Choices</td>
<td style="text-align:left">多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td>
</tr>
<tr>
<td style="text-align:left">301</td>
<td style="text-align:left">Moved Permanently</td>
<td style="text-align:left">永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td>
</tr>
<tr>
<td style="text-align:left">302</td>
<td style="text-align:left">Found</td>
<td style="text-align:left">临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td>
</tr>
<tr>
<td style="text-align:left">303</td>
<td style="text-align:left">See Other</td>
<td style="text-align:left">查看其它地址。与301类似。使用GET和POST请求查看</td>
</tr>
<tr>
<td style="text-align:left">304</td>
<td style="text-align:left">Not Modified</td>
<td style="text-align:left">未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td>
</tr>
<tr>
<td style="text-align:left">305</td>
<td style="text-align:left">Use Proxy</td>
<td style="text-align:left">使用代理。所请求的资源必须通过代理访问</td>
</tr>
<tr>
<td style="text-align:left">306</td>
<td style="text-align:left">Unused</td>
<td style="text-align:left">已经被废弃的HTTP状态码</td>
</tr>
<tr>
<td style="text-align:left">307</td>
<td style="text-align:left">Temporary Redirect</td>
<td style="text-align:left">临时重定向。与302类似。使用GET请求重定向</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">400</td>
<td style="text-align:left">Bad Request</td>
<td style="text-align:left">客户端请求的语法错误，服务器无法理解</td>
</tr>
<tr>
<td style="text-align:left">401</td>
<td style="text-align:left">Unauthorized</td>
<td style="text-align:left">请求要求用户的身份认证</td>
</tr>
<tr>
<td style="text-align:left">402</td>
<td style="text-align:left">Payment Required</td>
<td style="text-align:left">保留，将来使用</td>
</tr>
<tr>
<td style="text-align:left">403</td>
<td style="text-align:left">Forbidden</td>
<td style="text-align:left">服务器理解请求客户端的请求，但是拒绝执行此请求</td>
</tr>
<tr>
<td style="text-align:left">404</td>
<td style="text-align:left">Not Found</td>
<td style="text-align:left">服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置&quot;您所请求的资源无法找到&quot;的个性页面</td>
</tr>
<tr>
<td style="text-align:left">405</td>
<td style="text-align:left">Method Not Allowed</td>
<td style="text-align:left">客户端请求中的方法被禁止</td>
</tr>
<tr>
<td style="text-align:left">406</td>
<td style="text-align:left">Not Acceptable</td>
<td style="text-align:left">服务器无法根据客户端请求的内容特性完成请求</td>
</tr>
<tr>
<td style="text-align:left">407</td>
<td style="text-align:left">Proxy Authentication Required</td>
<td style="text-align:left">请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td>
</tr>
<tr>
<td style="text-align:left">408</td>
<td style="text-align:left">Request Time-out</td>
<td style="text-align:left">服务器等待客户端发送的请求时间过长，超时</td>
</tr>
<tr>
<td style="text-align:left">409</td>
<td style="text-align:left">Conflict</td>
<td style="text-align:left">服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</td>
</tr>
<tr>
<td style="text-align:left">410</td>
<td style="text-align:left">Gone</td>
<td style="text-align:left">客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td>
</tr>
<tr>
<td style="text-align:left">411</td>
<td style="text-align:left">Length Required</td>
<td style="text-align:left">服务器无法处理客户端发送的不带Content-Length的请求信息</td>
</tr>
<tr>
<td style="text-align:left">412</td>
<td style="text-align:left">Precondition Failed</td>
<td style="text-align:left">客户端请求信息的先决条件错误</td>
</tr>
<tr>
<td style="text-align:left">413</td>
<td style="text-align:left">Request Entity Too Large</td>
<td style="text-align:left">由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td>
</tr>
<tr>
<td style="text-align:left">414</td>
<td style="text-align:left">Request-URI Too Large</td>
<td style="text-align:left">请求的URI过长（URI通常为网址），服务器无法处理</td>
</tr>
<tr>
<td style="text-align:left">415</td>
<td style="text-align:left">Unsupported Media Type</td>
<td style="text-align:left">服务器无法处理请求附带的媒体格式</td>
</tr>
<tr>
<td style="text-align:left">416</td>
<td style="text-align:left">Requested range not satisfiable</td>
<td style="text-align:left">客户端请求的范围无效</td>
</tr>
<tr>
<td style="text-align:left">417</td>
<td style="text-align:left">Expectation Failed</td>
<td style="text-align:left">服务器无法满足Expect的请求头信息</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">500</td>
<td style="text-align:left">Internal Server Error</td>
<td style="text-align:left">服务器内部错误，无法完成请求</td>
</tr>
<tr>
<td style="text-align:left">501</td>
<td style="text-align:left">Not Implemented</td>
<td style="text-align:left">服务器不支持请求的功能，无法完成请求</td>
</tr>
<tr>
<td style="text-align:left">502</td>
<td style="text-align:left">Bad Gateway</td>
<td style="text-align:left">作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td>
</tr>
<tr>
<td style="text-align:left">503</td>
<td style="text-align:left">Service Unavailable</td>
<td style="text-align:left">由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td>
</tr>
<tr>
<td style="text-align:left">504</td>
<td style="text-align:left">Gateway Time-out</td>
<td style="text-align:left">充当网关或代理的服务器，未及时从远端服务器获取请求</td>
</tr>
<tr>
<td style="text-align:left">505</td>
<td style="text-align:left">HTTP Version not supported</td>
<td style="text-align:left">服务器不支持请求的HTTP协议的版本，无法完成处理</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[http-请求方法]]></title>
        <id>https://leecss.com/post/http-qing-qiu-fang-fa/</id>
        <link href="https://leecss.com/post/http-qing-qiu-fang-fa/">
        </link>
        <updated>2021-07-09T00:02:01.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>根据 HTTP 标准，HTTP 请求可以使用多种请求方法。</p>
<p>HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。</p>
<p>HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。</p>
<h2 id="方法">方法</h2>
<p><strong>幂等</strong>是说这个请求可以重复发送多次相同请求求，会返回相同的响应消息</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>请求指定的页面信息，并返回实体主体</td>
</tr>
<tr>
<td>HEAD</td>
<td>类似于 GET请求，但只返回响应报头，不返回响应正文</td>
</tr>
<tr>
<td>POST (非)</td>
<td>向指定资源提交数据（例如提交表单或者上传文件） 数据被包含在请求体中 POST请求可能会导致新的资源的建立和/或已有资源的修改</td>
</tr>
<tr>
<td>PUT</td>
<td>从客户端向服务器传送的数据取代指定的文档的内容</td>
</tr>
<tr>
<td>DELETE</td>
<td>请求服务器删除指定的页面</td>
</tr>
<tr>
<td>CONNECT</td>
<td>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>允许客户端查看服务器的性能</td>
</tr>
<tr>
<td>TRACE</td>
<td>回显服务器收到的请求，主要用于测试或诊断</td>
</tr>
<tr>
<td>PATCH(非)</td>
<td>是对 PUT 方法的补充，用来对已知资源进行局部更新 。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>GET：get方法一般用于获取服务器资源</p>
<p>POST：post方法一般用于传输实体主体</p>
<p>PUT：put方法一般用于传输文件</p>
<p>DELETE：delete方法用于删除文件</p>
<p>HEAD：head方法用于获取报文首部，不返回报文主体</p>
<p>OPTIONS：options方法用于询问请求URI资源支持的方法</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[http-报文]]></title>
        <id>https://leecss.com/post/http-bao-wen/</id>
        <link href="https://leecss.com/post/http-bao-wen/">
        </link>
        <updated>2021-07-08T15:04:50.000Z</updated>
        <content type="html"><![CDATA[<h2 id="http报文结构">HTTP报文结构</h2>
<p>用于HTTP协议交互的信息被称为HTTP报文。请求端（客户端）的HTTP报文叫做<strong>请求报文</strong>，响应端（服务器端）的叫做<strong>响应报文</strong>。HTTP报文本身是由多行（用CR+LF作换行符）数据构成的字符串文本。 HTTP报文大致可分为<strong>请求行/响应行、报文首部和报文主体</strong>两块。两者由最初出现的空行（CR+LF）来划分。</p>
<figure data-type="image" tabindex="1"><img src="https://leecss.com/post-images/1625756720174.png" alt="" loading="lazy"></figure>
<h3 id="请求报文">请求报文</h3>
<p>请求报文的请求行主要三个部分组成：请求方法、URI地址和HTTP协议版本号。</p>
<pre><code>POST /test/hi-there.txt HTTP/1.1
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://leecss.com/post-images/1625756732543.jpg" alt="" loading="lazy"></figure>
<h3 id="响应报文">响应报文</h3>
<p>响应报文的响应行主要三个部分组成：HTTP协议版本号、HTTP状态码和状态描述。</p>
<pre><code>HTTP/1.1 200 OK
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://leecss.com/post-images/1625756742764.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
</feed>